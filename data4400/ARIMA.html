<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Series Analysis Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding-bottom: 40px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .card-header {
            background-color: #4361ee;
            color: white;
            font-weight: 600;
            padding: 12px 20px;
        }
        .card-body {
            padding: 20px;
            background-color: white;
        }
        h1, h2, h3 {
            color: #2b2d42;
        }
        .btn-group {
            margin-bottom: 15px;
        }
        .btn-primary {
            background-color: #4361ee;
            border-color: #4361ee;
        }
        .btn-primary:hover {
            background-color: #3a56d4;
            border-color: #3a56d4;
        }
        .btn-outline-primary {
            color: #4361ee;
            border-color: #4361ee;
        }
        .btn-outline-primary:hover {
            background-color: #4361ee;
            border-color: #4361ee;
        }
        .plot-container {
            height: 400px;
            width: 100%;
            margin-bottom: 20px;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: inline-block;
            width: 100%;
            margin-bottom: 5px;
        }
        .form-range {
            width: 100%;
        }
        .tooltip-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #4361ee;
            color: white;
            text-align: center;
            font-size: 12px;
            line-height: 16px;
            cursor: help;
            margin-left: 5px;
        }
        .parameter-value {
            display: inline-block;
            min-width: 30px;
            text-align: center;
            font-weight: bold;
        }
        .tooltip-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
            max-width: 300px;
        }
        .tooltip-icon:hover + .tooltip-content {
            display: block;
        }
        .formula-container {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            overflow-x: auto;
        }
        .theory-section {
            background-color: #f0f3f8;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            margin-bottom: 20px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .theory-section.expanded {
            max-height: 1000px;
        }
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #4361ee;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .collapsible-header {
            cursor: pointer;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .collapsible-header:hover {
            background-color: #dee2e6;
        }
        .collapsible-header::after {
            content: "+";
            font-weight: bold;
        }
        .collapsible-header.active::after {
            content: "-";
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            text-align: center;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
        .best-model {
            background-color: #d4edda;
            font-weight: bold;
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .plot-container {
                height: 300px;
            }
            .card-body {
                padding: 15px;
            }
            .slider-container {
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center my-4">Time Series Analysis Dashboard</h1>
        
        <div class="card">
            <div class="card-header">
                Interactive Time Series Plot
            </div>
            <div class="card-body">
                <div class="btn-group" role="group">
                    <button id="raw-data-btn" class="btn btn-primary active">Raw Data</button>
                    <button id="diff1-btn" class="btn btn-outline-primary">1st Differencing</button>
                    <button id="seasonal-diff-btn" class="btn btn-outline-primary">Seasonal Differencing</button>
                    <button id="log-return-btn" class="btn btn-outline-primary">Log Returns</button>
                </div>
                <div id="time-series-plot" class="plot-container"></div>
                
                <div class="collapsible-header">Learn about differencing and transformation</div>
                <div class="theory-section">
                    <h4>Why do we difference time series data?</h4>
                    <p>Differencing is a technique used to make a non-stationary time series stationary by removing trends and seasonality:</p>
                    <ul>
                        <li><strong>First Differencing:</strong> Removes trend by taking the difference between consecutive observations. The formula is: 
                            <div class="formula-container">
                                \[ \nabla Y_t = Y_t - Y_{t-1} \]
                            </div>
                            This helps stabilize the mean by removing linear trends.
                        </li>
                        <li><strong>Seasonal Differencing:</strong> Removes seasonality by taking the difference between an observation and the same observation from the previous season. The formula is:
                            <div class="formula-container">
                                \[ \nabla_s Y_t = Y_t - Y_{t-s} \]
                            </div>
                            where \(s\) is the seasonal period (e.g., 4 for quarterly data, 12 for monthly data).
                        </li>
                        <li><strong>Log Returns:</strong> For financial time series, taking logarithmic returns can help stabilize variance:
                            <div class="formula-container">
                                \[ r_t = \log(Y_t) - \log(Y_{t-1}) \approx \frac{Y_t - Y_{t-1}}{Y_{t-1}} \]
                            </div>
                        </li>
                    </ul>
                    <p>Stationarity is important because most time series forecasting methods assume that the data is stationary.</p>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                Stationarity Test Demo
            </div>
            <div class="card-body">
                <p>Test your time series data for stationarity using the Augmented Dickey-Fuller (ADF) test.</p>
                <div class="btn-group mb-3" role="group">
                    <button id="adf-raw-btn" class="btn btn-primary active">Test Raw Data</button>
                    <button id="adf-diff1-btn" class="btn btn-outline-primary">Test 1st Difference</button>
                    <button id="adf-seasonal-btn" class="btn btn-outline-primary">Test Seasonal Difference</button>
                </div>
                <div class="info-box">
                    <h5>Test Results:</h5>
                    <p><strong>ADF Test Statistic:</strong> <span id="adf-test-stat">-</span></p>
                    <p><strong>p-value:</strong> <span id="adf-p-value">-</span></p>
                    <p><strong>Is Stationary?</strong> <span id="adf-is-stationary">-</span></p>
                </div>
                <div id="adf-plot" class="plot-container"></div>
                
                <div class="collapsible-header">Learn about stationarity tests</div>
                <div class="theory-section">
                    <h4>What is stationarity?</h4>
                    <p>A time series is <strong>stationary</strong> if its statistical properties (mean, variance, autocorrelation) do not change over time. Most time series models assume stationarity, so we often need to transform non-stationary data.</p>
                    
                    <h4>Augmented Dickey-Fuller (ADF) Test</h4>
                    <p>The ADF test checks for a unit root in the time series. The presence of a unit root indicates non-stationarity.</p>
                    
                    <p><strong>Null Hypothesis (H₀):</strong> The time series has a unit root (non-stationary)</p>
                    <p><strong>Alternative Hypothesis (H₁):</strong> The time series does not have a unit root (stationary)</p>
                    
                    <p>If the p-value is less than the significance level (typically 0.05), we reject the null hypothesis and conclude that the time series is stationary.</p>
                    
                    <p>ADF test regression model:</p>
                    <div class="formula-container">
                        \[ \Delta y_t = \alpha + \beta t + \gamma y_{t-1} + \delta_1 \Delta y_{t-1} + \cdots + \delta_p \Delta y_{t-p} + \epsilon_t \]
                    </div>
                    
                    <p>The test statistic is the t-statistic for the \(\gamma\) coefficient. If \(\gamma\) is significantly less than zero, the series is stationary.</p>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                ARIMA/SARIMA Builder
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <h4>ARIMA Parameters</h4>
                        <div class="slider-container">
                            <label for="p-slider">p (Autoregressive order): <span id="p-value" class="parameter-value">2</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The number of lag observations included in the model (AR component).</div>
                            </label>
                            <input type="range" class="form-range" id="p-slider" min="0" max="5" value="2">
                        </div>
                        <div class="slider-container">
                            <label for="d-slider">d (Differencing order): <span id="d-value" class="parameter-value">1</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The number of times the raw observations are differenced (I component).</div>
                            </label>
                            <input type="range" class="form-range" id="d-slider" min="0" max="2" value="1">
                        </div>
                        <div class="slider-container">
                            <label for="q-slider">q (Moving average order): <span id="q-value" class="parameter-value">2</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The size of the moving average window (MA component).</div>
                            </label>
                            <input type="range" class="form-range" id="q-slider" min="0" max="5" value="2">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h4>Seasonal Components</h4>
                        <div class="slider-container">
                            <label for="P-slider">P (Seasonal AR order): <span id="P-value" class="parameter-value">1</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The seasonal autoregressive order.</div>
                            </label>
                            <input type="range" class="form-range" id="P-slider" min="0" max="2" value="1">
                        </div>
                        <div class="slider-container">
                            <label for="D-slider">D (Seasonal differencing): <span id="D-value" class="parameter-value">1</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The seasonal differencing order.</div>
                            </label>
                            <input type="range" class="form-range" id="D-slider" min="0" max="1" value="1">
                        </div>
                        <div class="slider-container">
                            <label for="Q-slider">Q (Seasonal MA order): <span id="Q-value" class="parameter-value">1</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The seasonal moving average order.</div>
                            </label>
                            <input type="range" class="form-range" id="Q-slider" min="0" max="2" value="1">
                        </div>
                        <div class="slider-container">
                            <label for="s-slider">s (Seasonal period): <span id="s-value" class="parameter-value">4</span>
                                <span class="tooltip-icon">?</span>
                                <div class="tooltip-content">The number of observations per season.</div>
                            </label>
                            <input type="range" class="form-range" id="s-slider" min="0" max="12" step="1" value="4">
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-12">
                        <button id="fit-model-btn" class="btn btn-primary">Fit Model & Generate Forecast</button>
                        <button id="reset-model-btn" class="btn btn-outline-secondary ms-2">Reset Parameters</button>
                    </div>
                </div>
                
                <div class="row mt-4">
                    <div class="col-md-6">
                        <div id="acf-plot" class="plot-container"></div>
                    </div>
                    <div class="col-md-6">
                        <div id="pacf-plot" class="plot-container"></div>
                    </div>
                </div>
                
                <div id="forecast-plot" class="plot-container mt-3"></div>
                
                <div class="formula-container mt-3">
                    <h5>ARIMA/SARIMA Model Formula:</h5>
                    <div id="model-formula">
                        \[ \text{ARIMA}(2,1,2) \times (1,1,1)_4 \]
                    </div>
                    <div id="model-equation">
                        \[ (1 - \phi_1 B - \phi_2 B^2)(1 - \Phi_1 B^4)(1 - B)(1 - B^4)y_t = (1 + \theta_1 B + \theta_2 B^2)(1 + \Theta_1 B^4)\epsilon_t \]
                    </div>
                </div>
                
                <div class="collapsible-header">Learn about ARIMA and SARIMA models</div>
                <div class="theory-section">
                    <h4>ARIMA Models</h4>
                    <p>ARIMA (AutoRegressive Integrated Moving Average) models are used for forecasting time series data. They combine three components:</p>
                    <ul>
                        <li><strong>AR (AutoRegressive):</strong> Uses the relationship between an observation and a number of lagged observations.
                            <div class="formula-container">
                                \[ \text{AR}(p): y_t = c + \phi_1 y_{t-1} + \phi_2 y_{t-2} + \cdots + \phi_p y_{t-p} + \epsilon_t \]
                            </div>
                        </li>
                        <li><strong>I (Integrated):</strong> Represents differencing of observations to make the time series stationary.
                            <div class="formula-container">
                                \[ \text{I}(d): (1 - B)^d y_t \]
                            </div>
                            where B is the backshift operator: \(B y_t = y_{t-1}\)
                        </li>
                        <li><strong>MA (Moving Average):</strong> Uses the dependency between an observation and residual errors from previous observations.
                            <div class="formula-container">
                                \[ \text{MA}(q): y_t = c + \epsilon_t + \theta_1 \epsilon_{t-1} + \theta_2 \epsilon_{t-2} + \cdots + \theta_q \epsilon_{t-q} \]
                            </div>
                        </li>
                    </ul>
                    
                    <h4>SARIMA Models</h4>
                    <p>SARIMA (Seasonal ARIMA) models add seasonal components to ARIMA models.</p>
                    <p>A SARIMA model is denoted as SARIMA(p,d,q)(P,D,Q)s, where:</p>
                    <ul>
                        <li><strong>(p,d,q):</strong> Non-seasonal components</li>
                        <li><strong>(P,D,Q):</strong> Seasonal components</li>
                        <li><strong>s:</strong> The number of observations per season</li>
                    </ul>
                    
                    <p>The general form of a SARIMA model is:</p>
                    <div class="formula-container">
                        \[ \Phi_P(B^s)\phi_p(B)(1 - B)^d(1 - B^s)^D y_t = \Theta_Q(B^s)\theta_q(B)\epsilon_t \]
                    </div>
                    
                    <p>Where:</p>
                    <ul>
                        <li>\(\phi_p(B)\): Non-seasonal AR component</li>
                        <li>\((1-B)^d\): Non-seasonal differencing</li>
                        <li>\(\theta_q(B)\): Non-seasonal MA component</li>
                        <li>\(\Phi_P(B^s)\): Seasonal AR component</li>
                        <li>\((1-B^s)^D\): Seasonal differencing</li>
                        <li>\(\Theta_Q(B^s)\): Seasonal MA component</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                Model Comparison Dashboard
            </div>
            <div class="card-body">
                <p>Compare the forecasting performance of different time series models.</p>
                <button id="run-comparison-btn" class="btn btn-primary mb-3">Run Comparison</button>
                
                <div id="comparison-plot" class="plot-container"></div>
                
                <div class="table-responsive">
                    <table id="comparison-table" class="table table-striped">
                        <thead>
                            <tr>
                                <th>Model</th>
                                <th>RMSE</th>
                                <th>MAE</th>
                                <th>MAPE (%)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ARIMA</td>
                                <td id="arima-rmse">-</td>
                                <td id="arima-mae">-</td>
                                <td id="arima-mape">-</td>
                            </tr>
                            <tr>
                                <td>SARIMA</td>
                                <td id="sarima-rmse">-</td>
                                <td id="sarima-mae">-</td>
                                <td id="sarima-mape">-</td>
                            </tr>
                            <tr>
                                <td>Holt-Winters</td>
                                <td id="hw-rmse">-</td>
                                <td id="hw-mae">-</td>
                                <td id="hw-mape">-</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="collapsible-header">Learn about model evaluation</div>
                <div class="theory-section">
                    <h4>Model Evaluation Metrics</h4>
                    <p>To compare time series forecasting models, we use several metrics:</p>
                    
                    <p><strong>Root Mean Square Error (RMSE):</strong> Measures the square root of the average squared differences between predicted and actual values.
                        <div class="formula-container">
                            \[ \text{RMSE} = \sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y}_i)^2} \]
                        </div>
                    </p>
                    
                    <p><strong>Mean Absolute Error (MAE):</strong> Measures the average absolute differences between predicted and actual values.
                        <div class="formula-container">
                            \[ \text{MAE} = \frac{1}{n}\sum_{i=1}^{n}|y_i - \hat{y}_i| \]
                        </div>
                    </p>
                    
                    <p><strong>Mean Absolute Percentage Error (MAPE):</strong> Measures the average percentage difference between predicted and actual values.
                        <div class="formula-container">
                            \[ \text{MAPE} = \frac{100\%}{n}\sum_{i=1}^{n}\left|\frac{y_i - \hat{y}_i}{y_i}\right| \]
                        </div>
                    </p>
                    
                    <p>Lower values of these metrics indicate better model performance.</p>
                    
                    <h4>About the Models</h4>
                    <ul>
                        <li><strong>ARIMA:</strong> Good for non-seasonal data with trends.</li>
                        <li><strong>SARIMA:</strong> Adds seasonal components to ARIMA, making it suitable for seasonal data.</li>
                        <li><strong>Holt-Winters:</strong> Uses exponential smoothing to capture level, trend, and seasonality.</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="text-center mt-4">
            <button id="reset-all-btn" class="btn btn-outline-danger">Reset All</button>
        </div>
    </div>

    <script>
        // Sample time series data (Exchange Rate)
        const sampleData = [
            { date: '2014-09-17', value: 460.9 },
            { date: '2014-09-18', value: 437.8 },
            { date: '2014-09-19', value: 407.6 },
            { date: '2014-09-20', value: 420.1 },
            { date: '2014-09-21', value: 428.5 },
            { date: '2014-09-22', value: 410.3 },
            { date: '2014-09-23', value: 430.9 },
            { date: '2014-09-24', value: 442.7 },
            { date: '2014-09-25', value: 425.0 },
            { date: '2014-09-26', value: 415.2 },
            { date: '2014-09-27', value: 407.9 },
            { date: '2014-09-28', value: 402.8 },
            { date: '2014-09-29', value: 390.5 },
            { date: '2014-09-30', value: 385.9 },
            { date: '2014-10-01', value: 395.0 },
            { date: '2014-10-02', value: 375.3 },
            { date: '2014-10-03', value: 360.7 },
            { date: '2014-10-04', value: 343.5 },
            { date: '2014-10-05', value: 351.9 },
            { date: '2014-10-06', value: 330.1 },
            { date: '2014-10-07', value: 336.8 },
            { date: '2014-10-08', value: 352.9 },
            { date: '2014-10-09', value: 365.1 },
            { date: '2014-10-10', value: 384.2 },
            { date: '2014-10-11', value: 361.4 },
            { date: '2014-10-12', value: 379.8 },
            { date: '2014-10-13', value: 392.7 },
            { date: '2014-10-14', value: 405.3 },
            { date: '2014-10-15', value: 395.2 },
            { date: '2014-10-16', value: 380.1 },
            { date: '2014-10-17', value: 382.6 },
            { date: '2014-10-18', value: 391.8 },
            { date: '2014-10-19', value: 387.1 },
            { date: '2014-10-20', value: 379.8 },
            { date: '2014-10-21', value: 385.2 },
            { date: '2014-10-22', value: 379.3 },
            { date: '2014-10-23', value: 380.5 },
            { date: '2014-10-24', value: 358.4 },
            { date: '2014-10-25', value: 347.1 },
            { date: '2014-10-26', value: 351.9 },
            { date: '2014-10-27', value: 358.7 },
            { date: '2014-10-28', value: 351.5 },
            { date: '2014-10-29', value: 334.4 },
            { date: '2014-10-30', value: 344.8 },
            { date: '2014-10-31', value: 338.2 },
            { date: '2014-11-01', value: 326.3 },
            { date: '2014-11-02', value: 325.2 },
            { date: '2014-11-03', value: 334.7 },
            { date: '2014-11-04', value: 348.2 },
            { date: '2014-11-05', value: 337.1 },
            { date: '2014-11-06', value: 350.9 },
            { date: '2014-11-07', value: 341.4 },
            { date: '2014-11-08', value: 344.7 },
            { date: '2014-11-09', value: 365.3 },
            { date: '2014-11-10', value: 378.5 },
            { date: '2014-11-11', value: 366.1 },
            { date: '2014-11-12', value: 376.9 },
            { date: '2014-11-13', value: 395.1 },
            { date: '2014-11-14', value: 398.4 },
            { date: '2014-11-15', value: 405.8 },
            { date: '2014-11-16', value: 389.2 },
            { date: '2014-11-17', value: 373.4 },
            { date: '2014-11-18', value: 378.6 },
            { date: '2014-11-19', value: 380.4 },
            { date: '2014-11-20', value: 365.9 },
            { date: '2014-11-21', value: 351.5 },
            { date: '2014-11-22', value: 367.1 },
            { date: '2014-11-23', value: 389.6 },
            { date: '2014-11-24', value: 397.4 },
            { date: '2014-11-25', value: 378.9 },
            { date: '2014-11-26', value: 365.2 },
            { date: '2014-11-27', value: 370.5 },
            { date: '2014-11-28', value: 375.8 },
            { date: '2014-11-29', value: 363.7 },
            { date: '2014-11-30', value: 378.6 },
            { date: '2014-12-01', value: 392.4 },
            { date: '2014-12-02', value: 385.7 },
            { date: '2014-12-03', value: 375.3 },
            { date: '2014-12-04', value: 368.9 },
            { date: '2014-12-05', value: 355.1 },
            { date: '2014-12-06', value: 375.3 },
            { date: '2014-12-07', value: 390.5 },
            { date: '2014-12-08', value: 393.4 },
            { date: '2014-12-09', value: 351.9 },
            { date: '2014-12-10', value: 348.6 },
            { date: '2014-12-11', value: 355.7 },
            { date: '2014-12-12', value: 358.2 },
            { date: '2014-12-13', value: 354.2 },
            { date: '2014-12-14', value: 351.9 },
            { date: '2014-12-15', value: 348.2 },
            { date: '2014-12-16', value: 345.8 },
            { date: '2014-12-17', value: 321.7 },
            { date: '2014-12-18', value: 318.2 },
            { date: '2014-12-19', value: 315.6 },
            { date: '2014-12-20', value: 330.1 },
            { date: '2014-12-21', value: 318.4 },
            { date: '2014-12-22', value: 328.2 },
            { date: '2014-12-23', value: 334.1 }
        ];

        // Extract dates and values for easier access
        const dates = sampleData.map(d => d.date);
        const values = sampleData.map(d => d.value);

        // Calculate differenced series
        function calculateFirstDifference(values) {
            const diff = [];
            diff.push(null); // First value has no difference
            for (let i = 1; i < values.length; i++) {
                diff.push(values[i] - values[i-1]);
            }
            return diff;
        }

        function calculateSeasonalDifference(values, period = 4) {
            const diff = [];
            for (let i = 0; i < period; i++) {
                diff.push(null); // First season has no differences
            }
            for (let i = period; i < values.length; i++) {
                diff.push(values[i] - values[i-period]);
            }
            return diff;
        }

        function calculateLogReturns(values) {
            const logReturns = [];
            logReturns.push(null); // First value has no return
            for (let i = 1; i < values.length; i++) {
                // Using log approximation: log(x_t/x_{t-1}) ≈ (x_t - x_{t-1})/x_{t-1}
                logReturns.push(Math.log(values[i] / values[i-1]));
            }
            return logReturns;
        }

        // Calculate differenced series
        const firstDiff = calculateFirstDifference(values);
        const seasonalDiff = calculateSeasonalDifference(values, 7); // Weekly seasonality
        const logReturns = calculateLogReturns(values);

        // Function to plot time series data
        function plotTimeSeries(type = 'raw') {
            let plotData, title;
            
            switch(type) {
                case 'diff1':
                    plotData = firstDiff;
                    title = 'First Differenced Series (Removes Trend)';
                    break;
                case 'seasonal':
                    plotData = seasonalDiff;
                    title = 'Seasonal Differenced Series (Removes Seasonality)';
                    break;
                case 'logReturn':
                    plotData = logReturns;
                    title = 'Log Returns (Stabilizes Variance)';
                    break;
                default:
                    plotData = values;
                    title = 'Raw Time Series Data';
            }
            
            const trace = {
                x: dates,
                y: plotData,
                type: 'scatter',
                mode: 'lines+markers',
                marker: { size: 4 },
                line: { width: 2 },
                name: title
            };
            
            const layout = {
                title: title,
                xaxis: { title: 'Date' },
                yaxis: { title: 'Value' },
                hovermode: 'closest',
                showlegend: false,
                annotations: []
            };
            
            // Add annotations for explaining differencing if applicable
            if (type === 'diff1') {
                // Add arrow showing differencing
                const midpoint = Math.floor(dates.length / 2);
                layout.annotations.push({
                    x: dates[midpoint],
                    y: firstDiff[midpoint],
                    text: 'Δyt = yt - yt-1',
                    showarrow: true,
                    arrowhead: 2,
                    ax: 0,
                    ay: -40
                });
            } else if (type === 'seasonal') {
                // Add arrow showing seasonal differencing
                const midpoint = Math.floor(dates.length / 2);
                layout.annotations.push({
                    x: dates[midpoint],
                    y: seasonalDiff[midpoint],
                    text: 'Δ7yt = yt - yt-7',
                    showarrow: true,
                    arrowhead: 2,
                    ax: 0,
                    ay: -40
                });
            }
            
            Plotly.newPlot('time-series-plot', [trace], layout);
        }

        // Function to simulate Augmented Dickey-Fuller test
        function simulateADFTest(data, type = 'raw') {
            // This is a simplified simulation of ADF test for educational purposes
            // In a real implementation, you would calculate the test statistic and p-value properly
            
            let testStat, pValue, isStationary;
            
            switch(type) {
                case 'diff1':
                    // First difference is usually stationary for most financial time series
                    testStat = -3.82;
                    pValue = 0.003;
                    isStationary = true;
                    break;
                case 'seasonal':
                    // Seasonal difference is usually stationary
                    testStat = -4.12;
                    pValue = 0.001;
                    isStationary = true;
                    break;
                default:
                    // Raw data is often non-stationary
                    testStat = -1.95;
                    pValue = 0.31;
                    isStationary = false;
            }
            
            // Update UI with test results
            document.getElementById('adf-test-stat').textContent = testStat.toFixed(3);
            document.getElementById('adf-p-value').textContent = pValue.toFixed(3);
            document.getElementById('adf-is-stationary').textContent = isStationary ? 'Yes (Reject H₀)' : 'No (Fail to reject H₀)';
            
            if (isStationary) {
                document.getElementById('adf-is-stationary').style.color = 'green';
            } else {
                document.getElementById('adf-is-stationary').style.color = 'red';
            }
            
            // Plot the ADF test visualization
            plotADFTest(testStat, isStationary);
        }

        // Function to plot ADF test visualization
        function plotADFTest(testStat, isStationary) {
            // Generate a t-distribution for visualization
            const tValues = [];
            const tDensity = [];
            const criticalValue = -2.86; // Typical 5% critical value for ADF test
            
            for (let x = -5; x <= 2; x += 0.1) {
                tValues.push(x);
                // Using a simplified t-distribution approximation
                const density = Math.exp(-Math.pow(x - 0, 2) / 2) / Math.sqrt(2 * Math.PI);
                tDensity.push(density);
            }
            
            const nonRejectionTrace = {
                x: tValues.filter(x => x > criticalValue),
                y: tDensity.slice(0, tValues.filter(x => x > criticalValue).length),
                type: 'scatter',
                fill: 'tozeroy',
                mode: 'none',
                name: 'Fail to Reject H₀ (Non-Stationary)',
                fillcolor: 'rgba(255, 0, 0, 0.3)'
            };
            
            const rejectionTrace = {
                x: tValues.filter(x => x <= criticalValue),
                y: tDensity.slice(tValues.length - tValues.filter(x => x <= criticalValue).length),
                type: 'scatter',
                fill: 'tozeroy',
                mode: 'none',
                name: 'Reject H₀ (Stationary)',
                fillcolor: 'rgba(0, 128, 0, 0.3)'
            };
            
            const criticalValueLine = {
                x: [criticalValue, criticalValue],
                y: [0, Math.max(...tDensity) * 1.1],
                type: 'scatter',
                mode: 'lines',
                line: { color: 'black', width: 2, dash: 'dash' },
                name: 'Critical Value (5%)',
                hoverinfo: 'name'
            };
            
            const testStatLine = {
                x: [testStat, testStat],
                y: [0, Math.max(...tDensity) * 1.1],
                type: 'scatter',
                mode: 'lines',
                line: { color: isStationary ? 'green' : 'red', width: 2 },
                name: 'Test Statistic',
                hoverinfo: 'name'
            };
            
            const layout = {
                title: 'ADF Test Visualization',
                xaxis: { title: 'Test Statistic Value' },
                yaxis: { title: 'Density', showticklabels: false },
                hovermode: 'closest',
                shapes: [
                    {
                        type: 'line',
                        x0: criticalValue,
                        x1: criticalValue,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'black',
                            width: 2,
                            dash: 'dash'
                        }
                    }
                ],
                annotations: [
                    {
                        x: criticalValue,
                        y: 1,
                        yref: 'paper',
                        text: 'Critical Value = -2.86',
                        showarrow: true,
                        arrowhead: 2,
                        ax: -40,
                        ay: -20
                    },
                    {
                        x: testStat,
                        y: 0.9,
                        yref: 'paper',
                        text: `Test Statistic = ${testStat.toFixed(2)}`,
                        showarrow: true,
                        arrowhead: 2,
                        ax: isStationary ? -40 : 40,
                        ay: -20,
                        font: { color: isStationary ? 'green' : 'red' }
                    }
                ]
            };
            
            Plotly.newPlot('adf-plot', [nonRejectionTrace, rejectionTrace, criticalValueLine, testStatLine], layout);
        }

        // Function to calculate and plot ACF
        function calculateACF(data, lags = 20) {
            // Remove any null values for calculation
            const validData = data.filter(d => d !== null);
            
            const acf = [];
            const mean = validData.reduce((a, b) => a + b, 0) / validData.length;
            const variance = validData.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validData.length;
            
            for (let lag = 0; lag <= lags; lag++) {
                let sum = 0;
                for (let i = 0; i < validData.length - lag; i++) {
                    sum += (validData[i] - mean) * (validData[i + lag] - mean);
                }
                acf.push(sum / validData.length / variance);
            }
            
            return acf;
        }

        // Function to calculate and plot PACF
        function calculatePACF(data, lags = 20) {
            // This is a simplified implementation of PACF using the Durbin-Levinson algorithm
            const acf = calculateACF(data, lags);
            const pacf = [1]; // First value is always 1
            
            for (let k = 1; k <= lags; k++) {
                let phi = acf[k];
                for (let j = 1; j < k; j++) {
                    phi -= pacf[j] * acf[k - j];
                }
                phi /= 1 - pacf.slice(1, k).reduce((a, b, i) => a + b * acf[i + 1], 0);
                pacf.push(phi);
            }
            
            return pacf;
        }

        // Function to plot ACF
        function plotACF(data) {
            const acf = calculateACF(data);
            
            // Calculate confidence intervals (approximately ±2/√n)
            const n = data.filter(d => d !== null).length;
            const confInt = 2 / Math.sqrt(n);
            
            const trace = {
                x: Array.from({ length: acf.length }, (_, i) => i),
                y: acf,
                type: 'bar',
                name: 'ACF'
            };
            
            const upperCI = {
                x: Array.from({ length: acf.length }, (_, i) => i),
                y: Array(acf.length).fill(confInt),
                type: 'scatter',
                mode: 'lines',
                line: { color: 'red', dash: 'dash' },
                name: '95% Confidence Interval'
            };
            
            const lowerCI = {
                x: Array.from({ length: acf.length }, (_, i) => i),
                y: Array(acf.length).fill(-confInt),
                type: 'scatter',
                mode: 'lines',
                line: { color: 'red', dash: 'dash' },
                showlegend: false
            };
            
            const layout = {
                title: 'Autocorrelation Function (ACF)',
                xaxis: { title: 'Lag' },
                yaxis: { title: 'Correlation', range: [-1, 1] }
            };
            
            Plotly.newPlot('acf-plot', [trace, upperCI, lowerCI], layout);
        }

        // Function to plot PACF
        function plotPACF(data) {
            const pacf = calculatePACF(data);
            
            // Calculate confidence intervals (approximately ±2/√n)
            const n = data.filter(d => d !== null).length;
            const confInt = 2 / Math.sqrt(n);
            
            const trace = {
                x: Array.from({ length: pacf.length }, (_, i) => i),
                y: pacf,
                type: 'bar',
                name: 'PACF'
            };
            
            const upperCI = {
                x: Array.from({ length: pacf.length }, (_, i) => i),
                y: Array(pacf.length).fill(confInt),
                type: 'scatter',
                mode: 'lines',
                line: { color: 'red', dash: 'dash' },
                name: '95% Confidence Interval'
            };
            
            const lowerCI = {
                x: Array.from({ length: pacf.length }, (_, i) => i),
                y: Array(pacf.length).fill(-confInt),
                type: 'scatter',
                mode: 'lines',
                line: { color: 'red', dash: 'dash' },
                showlegend: false
            };
            
            const layout = {
                title: 'Partial Autocorrelation Function (PACF)',
                xaxis: { title: 'Lag' },
                yaxis: { title: 'Partial Correlation', range: [-1, 1] }
            };
            
            Plotly.newPlot('pacf-plot', [trace, upperCI, lowerCI], layout);
        }

        // Function to generate ARIMA forecast
        function generateARIMAForecast() {
            // Get parameter values
            const p = parseInt(document.getElementById('p-slider').value);
            const d = parseInt(document.getElementById('d-slider').value);
            const q = parseInt(document.getElementById('q-slider').value);
            const P = parseInt(document.getElementById('P-slider').value);
            const D = parseInt(document.getElementById('D-slider').value);
            const Q = parseInt(document.getElementById('Q-slider').value);
            const s = parseInt(document.getElementById('s-slider').value);
            
            // Update model formula
            document.getElementById('model-formula').innerHTML = `\\[ \\text{ARIMA}(${p},${d},${q}) \\times (${P},${D},${Q})_{${s}} \\]`;
            
            // Generate a simplified model equation based on parameters
            let equation = `\\[ `;
            
            // Non-seasonal AR component
            if (p > 0) {
                equation += `(1 `;
                for (let i = 1; i <= p; i++) {
                    equation += `- \\phi_{${i}} B^{${i}} `;
                }
                equation += `)`;
            }
            
            // Seasonal AR component
            if (P > 0 && s > 0) {
                equation += `(1 `;
                for (let i = 1; i <= P; i++) {
                    equation += `- \\Phi_{${i}} B^{${i * s}} `;
                }
                equation += `)`;
            }
            
            // Non-seasonal differencing
            if (d > 0) {
                equation += `(1 - B)^{${d}} `;
            }
            
            // Seasonal differencing
            if (D > 0 && s > 0) {
                equation += `(1 - B^{${s}})^{${D}} `;
            }
            
            equation += `y_t = `;
            
            // Non-seasonal MA component
            if (q > 0) {
                equation += `(1 `;
                for (let i = 1; i <= q; i++) {
                    equation += `+ \\theta_{${i}} B^{${i}} `;
                }
                equation += `)`;
            }
            
            // Seasonal MA component
            if (Q > 0 && s > 0) {
                equation += `(1 `;
                for (let i = 1; i <= Q; i++) {
                    equation += `+ \\Theta_{${i}} B^{${i * s}} `;
                }
                equation += `)`;
            }
            
            equation += `\\epsilon_t \\]`;
            
            document.getElementById('model-equation').innerHTML = equation;
            
            // Render LaTeX
            if (window.MathJax) {
                MathJax.typeset();
            }
            
            // Simulate ARIMA forecast
            simulateARIMAForecast(p, d, q, P, D, Q, s);
        }

        // Function to simulate ARIMA forecast
        function simulateARIMAForecast(p, d, q, P, D, Q, s) {
            // Get the appropriate data based on differencing
            let data = values;
            if (d === 1) {
                data = firstDiff.filter(d => d !== null);
            } else if (d === 2) {
                // Second differencing (apply first difference twice)
                const diff1 = firstDiff.filter(d => d !== null);
                const diff2 = calculateFirstDifference(diff1).filter(d => d !== null);
                data = diff2;
            }
            
            // Plot ACF and PACF
            plotACF(data);
            plotPACF(data);
            
            // Simulate a forecast (in a real implementation, you would fit an ARIMA model)
            const lastValue = values[values.length - 1];
            const forecastLength = 10;
            const forecastDates = [];
            const forecastValues = [];
            const upperBound = [];
            const lowerBound = [];
            
            // Generate forecast dates
            const lastDate = moment(dates[dates.length - 1]);
            for (let i = 1; i <= forecastLength; i++) {
                forecastDates.push(lastDate.clone().add(i, 'days').format('YYYY-MM-DD'));
            }
            
            // Generate forecast values based on parameters
            // This is a simplified simulation - in reality, the forecast would be generated by a fitted ARIMA model
            // We'll use a random walk with drift for simplicity
            const drift = 0;
            const volatility = 10; // Adjust based on parameters to simulate different models
            
            for (let i = 0; i < forecastLength; i++) {
                // More complex parameters = more volatile forecasts
                const complexity = (p + d + q + P + D + Q) / 10;
                const simulatedValue = lastValue + drift * (i + 1) + (Math.random() - 0.5) * volatility * complexity * Math.sqrt(i + 1);
                forecastValues.push(simulatedValue);
                
                // 68% prediction interval (approximately ±1 standard deviation)
                upperBound.push(simulatedValue + volatility * complexity * Math.sqrt(i + 1));
                lowerBound.push(simulatedValue - volatility * complexity * Math.sqrt(i + 1));
            }
            
            // Plot the forecast
            const historicalTrace = {
                x: dates,
                y: values,
                type: 'scatter',
                mode: 'lines',
                name: 'Historical Data',
                line: { color: 'blue' }
            };
            
            const forecastTrace = {
                x: forecastDates,
                y: forecastValues,
                type: 'scatter',
                mode: 'lines',
                name: 'Forecast',
                line: { color: 'red', dash: 'dash' }
            };
            
            const upperBoundTrace = {
                x: forecastDates,
                y: upperBound,
                type: 'scatter',
                mode: 'lines',
                name: '68% Prediction Interval',
                line: { width: 0 },
                showlegend: false
            };
            
            const lowerBoundTrace = {
                x: forecastDates,
                y: lowerBound,
                type: 'scatter',
                mode: 'lines',
                line: { width: 0 },
                fill: 'tonexty',
                fillcolor: 'rgba(255, 0, 0, 0.2)',
                name: '68% Prediction Interval'
            };
            
            const layout = {
                title: `ARIMA(${p},${d},${q})×(${P},${D},${Q})${s} Forecast`,
                xaxis: { title: 'Date' },
                yaxis: { title: 'Value' },
                shapes: [
                    {
                        type: 'line',
                        x0: dates[dates.length - 1],
                        x1: dates[dates.length - 1],
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: {
                            color: 'black',
                            width: 2,
                            dash: 'dash'
                        }
                    }
                ],
                annotations: [
                    {
                        x: dates[dates.length - 1],
                        y: 1,
                        yref: 'paper',
                        text: 'Forecast Start',
                        showarrow: true,
                        arrowhead: 2,
                        ax: 0,
                        ay: -40
                    }
                ]
            };
            
            Plotly.newPlot('forecast-plot', [historicalTrace, forecastTrace, upperBoundTrace, lowerBoundTrace], layout);
        }

        // Function to run model comparison
        function runModelComparison() {
            // This is a simplified simulation of model comparison
            
            // Generate dates for training and testing
            const trainEndIndex = Math.floor(dates.length * 0.8); // 80% for training
            const testDates = dates.slice(trainEndIndex);
            const testValues = values.slice(trainEndIndex);
            
            // Simulate predictions from different models
            const arimaPredictions = [];
            const sarimaPredictions = [];
            const hwPredictions = [];
            
            // Simplified simulation - in reality, you would fit models to the training data and predict on test data
            for (let i = 0; i < testValues.length; i++) {
                // ARIMA predictions (add some noise to the true values)
                arimaPredictions.push(testValues[i] + (Math.random() - 0.5) * 20);
                
                // SARIMA predictions (typically better than ARIMA for seasonal data)
                sarimaPredictions.push(testValues[i] + (Math.random() - 0.5) * 15);
                
                // Holt-Winters predictions (typically good for seasonal data with trend)
                hwPredictions.push(testValues[i] + (Math.random() - 0.5) * 18);
            }
            
            // Calculate metrics
            const arimaRMSE = calculateRMSE(testValues, arimaPredictions);
            const sarimaRMSE = calculateRMSE(testValues, sarimaPredictions);
            const hwRMSE = calculateRMSE(testValues, hwPredictions);
            
            const arimaMAE = calculateMAE(testValues, arimaPredictions);
            const sarimaMAE = calculateMAE(testValues, sarimaPredictions);
            const hwMAE = calculateMAE(testValues, hwPredictions);
            
            const arimaMAPE = calculateMAPE(testValues, arimaPredictions);
            const sarimaMAPE = calculateMAPE(testValues, sarimaPredictions);
            const hwMAPE = calculateMAPE(testValues, hwPredictions);
            
            // Update table
            document.getElementById('arima-rmse').textContent = arimaRMSE.toFixed(2);
            document.getElementById('sarima-rmse').textContent = sarimaRMSE.toFixed(2);
            document.getElementById('hw-rmse').textContent = hwRMSE.toFixed(2);
            
            document.getElementById('arima-mae').textContent = arimaMAE.toFixed(2);
            document.getElementById('sarima-mae').textContent = sarimaMAE.toFixed(2);
            document.getElementById('hw-mae').textContent = hwMAE.toFixed(2);
            
            document.getElementById('arima-mape').textContent = arimaMAPE.toFixed(2);
            document.getElementById('sarima-mape').textContent = sarimaMAPE.toFixed(2);
            document.getElementById('hw-mape').textContent = hwMAPE.toFixed(2);
            
            // Highlight best model (lowest RMSE)
            const rmseValues = [
                { model: 'arima', value: arimaRMSE },
                { model: 'sarima', value: sarimaRMSE },
                { model: 'hw', value: hwRMSE }
            ];
            
            const bestModel = rmseValues.reduce((a, b) => a.value < b.value ? a : b).model;
            
            document.querySelectorAll('#comparison-table tbody tr').forEach(row => {
                row.classList.remove('best-model');
            });
            
            const modelRows = document.querySelectorAll('#comparison-table tbody tr');
            if (bestModel === 'arima') {
                modelRows[0].classList.add('best-model');
            } else if (bestModel === 'sarima') {
                modelRows[1].classList.add('best-model');
            } else {
                modelRows[2].classList.add('best-model');
            }
            
            // Plot comparison
            const actualTrace = {
                x: testDates,
                y: testValues,
                type: 'scatter',
                mode: 'lines',
                name: 'Actual',
                line: { color: 'black', width: 2 }
            };
            
            const arimaTrace = {
                x: testDates,
                y: arimaPredictions,
                type: 'scatter',
                mode: 'lines',
                name: 'ARIMA',
                line: { color: 'blue' }
            };
            
            const sarimaTrace = {
                x: testDates,
                y: sarimaPredictions,
                type: 'scatter',
                mode: 'lines',
                name: 'SARIMA',
                line: { color: 'red' }
            };
            
            const hwTrace = {
                x: testDates,
                y: hwPredictions,
                type: 'scatter',
                mode: 'lines',
                name: 'Holt-Winters',
                line: { color: 'green' }
            };
            
            const layout = {
                title: 'Model Comparison',
                xaxis: { title: 'Date' },
                yaxis: { title: 'Value' }
            };
            
            Plotly.newPlot('comparison-plot', [actualTrace, arimaTrace, sarimaTrace, hwTrace], layout);
        }

        // Helper functions for calculating metrics
        function calculateRMSE(actual, predicted) {
            let sumSquaredError = 0;
            for (let i = 0; i < actual.length; i++) {
                sumSquaredError += Math.pow(actual[i] - predicted[i], 2);
            }
            return Math.sqrt(sumSquaredError / actual.length);
        }

        function calculateMAE(actual, predicted) {
            let sumAbsError = 0;
            for (let i = 0; i < actual.length; i++) {
                sumAbsError += Math.abs(actual[i] - predicted[i]);
            }
            return sumAbsError / actual.length;
        }

        function calculateMAPE(actual, predicted) {
            let sumAbsPercentError = 0;
            for (let i = 0; i < actual.length; i++) {
                if (actual[i] !== 0) {
                    sumAbsPercentError += Math.abs((actual[i] - predicted[i]) / actual[i]) * 100;
                }
            }
            return sumAbsPercentError / actual.length;
        }

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Plot initial time series
            plotTimeSeries('raw');
            
            // Set up event listeners for time series plot buttons
            document.getElementById('raw-data-btn').addEventListener('click', function() {
                document.getElementById('raw-data-btn').classList.add('active');
                document.getElementById('diff1-btn').classList.remove('active');
                document.getElementById('seasonal-diff-btn').classList.remove('active');
                document.getElementById('log-return-btn').classList.remove('active');
                plotTimeSeries('raw');
            });
            
            document.getElementById('diff1-btn').addEventListener('click', function() {
                document.getElementById('raw-data-btn').classList.remove('active');
                document.getElementById('diff1-btn').classList.add('active');
                document.getElementById('seasonal-diff-btn').classList.remove('active');
                document.getElementById('log-return-btn').classList.remove('active');
                plotTimeSeries('diff1');
            });
            
            document.getElementById('seasonal-diff-btn').addEventListener('click', function() {
                document.getElementById('raw-data-btn').classList.remove('active');
                document.getElementById('diff1-btn').classList.remove('active');
                document.getElementById('seasonal-diff-btn').classList.add('active');
                document.getElementById('log-return-btn').classList.remove('active');
                plotTimeSeries('seasonal');
            });
            
            document.getElementById('log-return-btn').addEventListener('click', function() {
                document.getElementById('raw-data-btn').classList.remove('active');
                document.getElementById('diff1-btn').classList.remove('active');
                document.getElementById('seasonal-diff-btn').classList.remove('active');
                document.getElementById('log-return-btn').classList.add('active');
                plotTimeSeries('logReturn');
            });
            
            // Set up event listeners for ADF test buttons
            document.getElementById('adf-raw-btn').addEventListener('click', function() {
                document.getElementById('adf-raw-btn').classList.add('active');
                document.getElementById('adf-diff1-btn').classList.remove('active');
                document.getElementById('adf-seasonal-btn').classList.remove('active');
                simulateADFTest(values, 'raw');
            });
            
            document.getElementById('adf-diff1-btn').addEventListener('click', function() {
                document.getElementById('adf-raw-btn').classList.remove('active');
                document.getElementById('adf-diff1-btn').classList.add('active');
                document.getElementById('adf-seasonal-btn').classList.remove('active');
                simulateADFTest(firstDiff, 'diff1');
            });
            
            document.getElementById('adf-seasonal-btn').addEventListener('click', function() {
                document.getElementById('adf-raw-btn').classList.remove('active');
                document.getElementById('adf-diff1-btn').classList.remove('active');
                document.getElementById('adf-seasonal-btn').classList.add('active');
                simulateADFTest(seasonalDiff, 'seasonal');
            });
            
            // Set up event listeners for ARIMA/SARIMA sliders
            document.getElementById('p-slider').addEventListener('input', function() {
                document.getElementById('p-value').textContent = this.value;
            });
            
            document.getElementById('d-slider').addEventListener('input', function() {
                document.getElementById('d-value').textContent = this.value;
            });
            
            document.getElementById('q-slider').addEventListener('input', function() {
                document.getElementById('q-value').textContent = this.value;
            });
            
            document.getElementById('P-slider').addEventListener('input', function() {
                document.getElementById('P-value').textContent = this.value;
            });
            
            document.getElementById('D-slider').addEventListener('input', function() {
                document.getElementById('D-value').textContent = this.value;
            });
            
            document.getElementById('Q-slider').addEventListener('input', function() {
                document.getElementById('Q-value').textContent = this.value;
            });
            
            document.getElementById('s-slider').addEventListener('input', function() {
                document.getElementById('s-value').textContent = this.value;
            });
            
            // Set up event listener for fit model button
            document.getElementById('fit-model-btn').addEventListener('click', function() {
                generateARIMAForecast();
            });
            
            // Set up event listener for reset model button
            document.getElementById('reset-model-btn').addEventListener('click', function() {
                document.getElementById('p-slider').value = 2;
                document.getElementById('p-value').textContent = 2;
                
                document.getElementById('d-slider').value = 1;
                document.getElementById('d-value').textContent = 1;
                
                document.getElementById('q-slider').value = 2;
                document.getElementById('q-value').textContent = 2;
                
                document.getElementById('P-slider').value = 1;
                document.getElementById('P-value').textContent = 1;
                
                document.getElementById('D-slider').value = 1;
                document.getElementById('D-value').textContent = 1;
                
                document.getElementById('Q-slider').value = 1;
                document.getElementById('Q-value').textContent = 1;
                
                document.getElementById('s-slider').value = 4;
                document.getElementById('s-value').textContent = 4;
                
                generateARIMAForecast();
            });
            
            // Set up event listener for run comparison button
            document.getElementById('run-comparison-btn').addEventListener('click', function() {
                runModelComparison();
            });
            
            // Set up event listener for reset all button
            document.getElementById('reset-all-btn').addEventListener('click', function() {
                location.reload();
            });
            
            // Set up event listeners for collapsible sections
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const content = this.nextElementSibling;
                    content.classList.toggle('expanded');
                });
            });
            
            // Initialize ADF test
            simulateADFTest(values, 'raw');
            
            // Initialize ACF, PACF, and forecast plots
            generateARIMAForecast();
            
            // Initialize model comparison
            runModelComparison();
        });
    </script>
</body>
</html>