<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data4400 Week 3: Time Series Forecasting by Stephen Vu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Helvetica, Arial, sans-serif;
            background-color: #ffffff;
            overflow: hidden;
        }
        
        .slide {
            width: 100vw;
            height: 100vh;
            display: none;
            padding: 60px;
            position: relative;
        }
        
        .slide.active {
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            font-size: 42px;
            margin-bottom: 40px;
            color: #333;
            text-align: center;
        }
        
        h2 {
            font-size: 36px;
            margin-bottom: 30px;
            color: #333;
        }
        
        h3 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #444;
        }
        
        p, li {
            font-size: 22px;
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }
        
        .navigation {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .slide-number {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-size: 16px;
            color: #666;
        }
        
        .split-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 30px;
            height: 70%;
        }
        
        .triple-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
            height: 70%;
        }
        
        .component-box {
            border: 2px solid #ddd;
            padding: 20px;
            border-radius: 10px;
            background-color: #f9f9f9;
        }
        
        .chart-container {
            width: 100%;
            height: 300px;
            margin-top: 20px;
        }
        
        .equation {
            font-size: 28px;
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background-color: #f0f0f0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }
        
        .quiz-option {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            text-align: left;
            background-color: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: #000000;
        }
        
        .quiz-option:hover {
            background-color: #e0e0e0;
        }
        
        .quiz-option.correct {
            background-color: #d4edda;
            border-color: #28a745;
        }
        
        .quiz-option.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }
        
        .data-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .data-table input {
            width: 80px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .agenda-item {
            padding: 15px;
            margin: 10px 0;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <!-- Slide 1: Title -->
    <div class="slide active">
        <h1>Data4400: Time Series Analysis</h1>
        <h2 style="text-align: center; margin-top: 50px;">Week 3: Advanced Forecasting Techniques</h2>
        <p style="text-align: center; font-size: 28px; margin-top: 40px;">Moving Average, Naive Forecast, Time Series Decomposition</p>
        <div class="slide-number">1 / 30</div>
    </div>

    <!-- Slide 2: Recap Part 1 -->
    <div class="slide">
        <h2>Recap: Time Series Components (Part 1)</h2>
        <div class="split-content">
            <div class="component-box">
                <h3>1. Stationary Component</h3>
                <p>A series with constant mean and variance over time</p>
                <canvas id="stationaryChart" class="chart-container"></canvas>
            </div>
            <div class="component-box">
                <h3>2. Long-term Trend</h3>
                <p>The general direction of the data over an extended period</p>
                <canvas id="trendChart" class="chart-container"></canvas>
            </div>
        </div>
        <div class="slide-number">2 / 30</div>
    </div>

    <!-- Slide 3: Recap Part 2 -->
    <div class="slide">
        <h2>Recap: Time Series Components (Part 2)</h2>
        <div class="triple-content">
            <div class="component-box">
                <h3>3. Seasonality</h3>
                <p>Regular patterns that repeat at fixed intervals</p>
                <canvas id="seasonalChart" class="chart-container"></canvas>
            </div>
            <div class="component-box">
                <h3>4. Cyclical Patterns</h3>
                <p>Long-term fluctuations without fixed period</p>
                <canvas id="cyclicalChart" class="chart-container"></canvas>
            </div>
            <div class="component-box">
                <h3>5. Irregularity</h3>
                <p>Random, unpredictable fluctuations</p>
                <canvas id="irregularChart" class="chart-container"></canvas>
            </div>
        </div>
        <div class="slide-number">3 / 31</div>
    </div>

    <!-- Slide 4: Quiz 1 -->
    <div class="slide">
        <h2>Quiz: Identify the Time Series Component</h2>
        <canvas id="quizChart1" style="width: 100%; height: 300px; margin: 20px 0;"></canvas>
        <p style="font-size: 24px; margin-bottom: 20px;">Which component is primarily shown in this time series?</p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">A. Stationary Component</button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">B. Seasonal Pattern</button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">C. Long-term Trend</button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">D. Irregular Component</button>
        <div class="slide-number">4 / 31</div>
    </div>

    <!-- Slide 5: Today's Agenda -->
    <div class="slide">
        <h2>Today's Learning Objectives</h2>
        <p style="font-size: 24px; margin-bottom: 30px;">Building on last week's foundation of time series components and regression models...</p>
        <div class="agenda-item">1. Naive Forecast Method</div>
        <div class="agenda-item">2. Understanding Smoothing Techniques</div>
        <div class="agenda-item">3. Moving Average Implementation</div>
        <div class="agenda-item">4. Time Series Decomposition</div>
        <div class="agenda-item">5. Multiplicative vs. Additive Models</div>
        <p style="margin-top: 30px; font-style: italic;">These techniques help us extract meaningful patterns from noisy data for better forecasting</p>
        <div class="slide-number">5 / 31</div>
    </div>

    <!-- Slide 6: Naive Forecast -->
    <div class="slide">
        <h2>Naive Forecast Method</h2>
        <p>The simplest forecasting method: tomorrow's value equals today's value</p>
        <div class="equation">
            Å·<sub>t+1</sub> = y<sub>t</sub>
        </div>
        <p>Where Å·<sub>t+1</sub> is the forecast for the next period and y<sub>t</sub> is the current observation</p>
        <canvas id="naiveChart" style="width: 100%; height: 350px; margin-top: 30px;"></canvas>
        <div class="slide-number">6 / 31</div>
    </div>

    <!-- Slide 7: Forecasting Aim -->
    <div class="slide">
        <h2>The Fundamental Aim of Forecasting</h2>
        <p style="font-size: 26px; text-align: center; margin: 40px 0;">To predict future values based on identified patterns from historical data</p>
        <div class="split-content">
            <div>
                <h3>Noisy Time Series</h3>
                <canvas id="noisyChart" class="chart-container"></canvas>
                <p style="text-align: center; color: #dc3545;">Difficult to predict</p>
            </div>
            <div>
                <h3>Smooth Time Series</h3>
                <canvas id="smoothChart" class="chart-container"></canvas>
                <p style="text-align: center; color: #28a745;">Easier to predict</p>
            </div>
        </div>
        <div class="slide-number">7 / 31</div>
    </div>

    <!-- Slide 8: Smoothing Introduction -->
    <div class="slide">
        <h2>Introduction to Smoothing Techniques</h2>
        <h3>Purpose of Smoothing:</h3>
        <ul style="font-size: 24px; margin-left: 40px;">
            <li>Reduce the impact of random variation in time series data</li>
            <li>Make underlying patterns more readily identifiable</li>
            <li>Create a modified series that is more uniform and less irregular</li>
        </ul>
        <canvas id="smoothingDemo" style="width: 100%; height: 350px; margin-top: 30px;"></canvas>
        <div class="slide-number">8 / 31</div>
    </div>

    <!-- Slide 9: Smoothing Benefits -->
    <div class="slide">
        <h2>Benefits of Smoothing Techniques</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-top: 40px;">
            <div>
                <h3>Before Smoothing</h3>
                <ul>
                    <li>High noise levels obscure patterns</li>
                    <li>Difficult to identify trends</li>
                    <li>Random variations dominate</li>
                </ul>
            </div>
            <div>
                <h3>After Smoothing</h3>
                <ul>
                    <li>Clear pattern emergence</li>
                    <li>Trend identification simplified</li>
                    <li>Reduced random fluctuations</li>
                </ul>
            </div>
        </div>
        <canvas id="beforeAfterSmoothing" style="width: 100%; height: 300px; margin-top: 30px;"></canvas>
        <div class="slide-number">9 / 31</div>
    </div>

    <!-- Slide 10: Quiz 2 -->
    <div class="slide">
        <h2>Quiz: Smoothing Techniques</h2>
        <canvas id="quizChart2" style="width: 100%; height: 300px; margin: 20px 0;"></canvas>
        <p style="font-size: 24px; margin-bottom: 20px;">Which series would benefit most from smoothing techniques?</p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">A. Series A (Blue) - Already smooth with clear trend</button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">B. Series B (Red) - High variability obscuring patterns</button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">C. Both equally</button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">D. Neither needs smoothing</button>
        <div class="slide-number">10 / 31</div>
    </div>

    <!-- Slide 11: Moving Average Introduction -->
    <div class="slide">
        <h2>Moving Average: A Fundamental Smoothing Technique</h2>
        <p>Moving Average calculates the average of the most recent k observations</p>
        <div class="equation">
            MA(k)<sub>t</sub> = (y<sub>t</sub> + y<sub>t-1</sub> + ... + y<sub>t-k+1</sub>) / k
        </div>
        <p>Where k is the number of periods in the moving average window</p>
        <canvas id="movingAverageChart" style="width: 100%; height: 350px; margin-top: 30px;"></canvas>
        <div class="slide-number">11 / 31</div>
    </div>

    <!-- Slide 12: MA Comparison Animation -->
    <div class="slide">
        <h2>Comparing Moving Averages: MA(2) vs MA(3)</h2>
        <p>Click the button to see how different window sizes affect smoothing</p>
        <button onclick="animateMA()" style="margin: 20px auto; display: block;">Animate Comparison</button>
        <canvas id="maComparisonChart" style="width: 100%; height: 400px;"></canvas>
        <div id="maDataDisplay" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            <div style="background-color: #f0f0f0; padding: 15px; border-radius: 8px;">
                <h4>MA(2) Calculation</h4>
                <p id="ma2Calc" style="font-family: monospace;"></p>
            </div>
            <div style="background-color: #f0f0f0; padding: 15px; border-radius: 8px;">
                <h4>MA(3) Calculation</h4>
                <p id="ma3Calc" style="font-family: monospace;"></p>
            </div>
        </div>
        <div class="slide-number">12 / 31</div>
    </div>

    <!-- Slide 13: Exercise -->
    <div class="slide">
        <h2>Exercise: Forecasting Comparison</h2>
        <p>Complete the table below using Naive Forecast, MA(2), and MA(3). Calculate the absolute errors.</p>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Period</th>
                    <th>Actual Value</th>
                    <th>Naive Forecast</th>
                    <th>MA(2) Forecast</th>
                    <th>MA(3) Forecast</th>
                    <th>|Error| Naive</th>
                    <th>|Error| MA(2)</th>
                    <th>|Error| MA(3)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>42</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>48</td>
                    <td><input type="text" placeholder="?"></td>
                    <td>-</td>
                    <td>-</td>
                    <td><input type="text" placeholder="?"></td>
                    <td>-</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>51</td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td>-</td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>46</td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>50</td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                </tr>
                <tr>
                    <td colspan="5" style="text-align: right; font-weight: bold;">Sum of Absolute Errors:</td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                    <td><input type="text" placeholder="?"></td>
                </tr>
            </tbody>
        </table>
        <p style="margin-top: 20px; font-style: italic;">Which method has the lowest sum of absolute errors?</p>
        <div class="slide-number">13 / 31</div>
    </div>

    <!-- Slide 14: Time Series Decomposition Introduction -->
    <div class="slide">
        <h2>Time Series Decomposition</h2>
        <h3>Why Decompose Time Series?</h3>
        <ul style="font-size: 24px; margin-left: 40px;">
            <li>Isolate individual components for better understanding</li>
            <li>Remove seasonality to identify underlying trends</li>
            <li>Improve forecasting accuracy by modeling components separately</li>
            <li>Identify irregular patterns and outliers</li>
        </ul>
        <canvas id="decompositionChart" style="width: 100%; height: 350px; margin-top: 30px;"></canvas>
        <div class="slide-number">14 / 31</div>
    </div>

    <!-- Slide 15: Decomposition Types Overview -->
    <div class="slide">
        <h2>Two Types of Time Series Decomposition</h2>
        <div class="split-content">
            <div class="component-box">
                <h3>Additive Model</h3>
                <div class="equation">Y<sub>t</sub> = Trend + Seasonal + Irregular</div>
                <p>Used when seasonal fluctuations are relatively constant over time</p>
            </div>
            <div class="component-box">
                <h3>Multiplicative Model</h3>
                <div class="equation">Y<sub>t</sub> = Trend Ã— Seasonal Ã— Irregular</div>
                <p>Used when seasonal fluctuations change proportionally to the level of the time series</p>
            </div>
        </div>
        <div class="slide-number">15 / 31</div>
    </div>

    <!-- Slide 16: Additive Decomposition Visual -->
    <div class="slide">
        <h2>Additive Decomposition: Visual Example</h2>
        <canvas id="additiveDecompChart" style="width: 100%; height: 500px; margin-top: 20px;"></canvas>
        <p style="text-align: center; margin-top: 20px;">Notice how the seasonal component has constant amplitude</p>
        <div class="slide-number">16 / 31</div>
    </div>

    <!-- Slide 17: Multiplicative Decomposition Visual -->
    <div class="slide">
        <h2>Multiplicative Decomposition: Visual Example</h2>
        <canvas id="multiplicativeDecompChart" style="width: 100%; height: 500px; margin-top: 20px;"></canvas>
        <p style="text-align: center; margin-top: 20px;">Notice how the seasonal component amplitude increases with the trend</p>
        <div class="slide-number">17 / 31</div>
    </div>

    <!-- Slide 18: Choosing Decomposition Type -->
    <div class="slide">
        <h2>Choosing Between Additive and Multiplicative</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-top: 40px;">
            <div class="component-box">
                <h3>Use Additive When:</h3>
                <ul>
                    <li>Seasonal fluctuations are constant</li>
                    <li>Variance doesn't change with level</li>
                    <li>Linear relationships exist</li>
                </ul>
                <canvas id="additiveExampleChart" style="width: 100%; height: 200px; margin-top: 20px;"></canvas>
            </div>
            <div class="component-box">
                <h3>Use Multiplicative When:</h3>
                <ul>
                    <li>Seasonal fluctuations vary with level</li>
                    <li>Percentage changes are constant</li>
                    <li>Data shows exponential growth</li>
                </ul>
                <canvas id="multiplicativeExampleChart" style="width: 100%; height: 200px; margin-top: 20px;"></canvas>
            </div>
        </div>
        <div class="slide-number">18 / 31</div>
    </div>

    <!-- Slide 19: Quiz 3 -->
    <div class="slide">
        <h2>Quiz: Decomposition Model Selection</h2>
        <canvas id="quizChart3" style="width: 100%; height: 350px; margin: 20px 0;"></canvas>
        <p style="font-size: 24px; margin-bottom: 20px;">Which decomposition model would be most appropriate for this time series?</p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">A. Additive Model - constant seasonal variation</button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">B. Multiplicative Model - increasing seasonal variation</button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">C. Either model would work equally well</button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">D. No decomposition needed</button>
        <div class="slide-number">19 / 34</div>
    </div>

    <!-- Slide 20: Introduction to Prophet -->
    <div class="slide">
        <h2>Facebook Prophet: Modern Time Series Forecasting</h2>
        <div style="background-color: #f0f8ff; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
            <p style="font-size: 24px; text-align: center; margin: 0;">
                Prophet = Trend + Seasonality + Holidays + Error
            </p>
        </div>
        
        <div class="split-content">
            <div>
                <h3>Why Prophet?</h3>
                <ul style="font-size: 20px;">
                    <li>Handles missing data and outliers</li>
                    <li>Automatic seasonality detection</li>
                    <li>Built-in holiday effects</li>
                    <li>Human-interpretable parameters</li>
                    <li>Works well "out of the box"</li>
                </ul>
            </div>
            <div>
                <h3>Prophet vs Traditional Methods</h3>
                <canvas id="prophetComparisonChart" style="width: 100%; height: 250px;"></canvas>
            </div>
        </div>
        
        <p style="font-size: 18px; margin-top: 20px; text-align: center; color: #666;">
            Developed by Facebook for business forecasting at scale
        </p>
        <div class="slide-number">20 / 34</div>
    </div>

    <!-- Slide 21: Prophet Components -->
    <div class="slide">
        <h2>Prophet Model Components</h2>
        <div class="equation" style="font-size: 24px;">
            y(t) = g(t) + s(t) + h(t) + Îµ<sub>t</sub>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px;">
            <div class="component-box">
                <h3>ðŸ“ˆ g(t): Trend</h3>
                <p>Non-periodic changes (growth or decline)</p>
                <ul style="font-size: 18px;">
                    <li>Linear growth (default)</li>
                    <li>Logistic growth (with cap)</li>
                    <li>Automatic changepoint detection</li>
                </ul>
                <canvas id="trendComponentChart" style="width: 100%; height: 150px; margin-top: 10px;"></canvas>
            </div>
            
            <div class="component-box">
                <h3>ðŸ”„ s(t): Seasonality</h3>
                <p>Periodic changes (weekly, yearly)</p>
                <ul style="font-size: 18px;">
                    <li>Fourier series modeling</li>
                    <li>Weekly: 7-day cycle</li>
                    <li>Yearly: 365.25-day cycle</li>
                </ul>
                <canvas id="seasonalComponentChart" style="width: 100%; height: 150px; margin-top: 10px;"></canvas>
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            <div class="component-box">
                <h3>ðŸŽ‰ h(t): Holidays/Events</h3>
                <p>Irregular events with predictable effects</p>
                <ul style="font-size: 18px;">
                    <li>User-specified dates</li>
                    <li>Can include windows (e.g., Â±1 day)</li>
                    <li>Country-specific holidays</li>
                </ul>
            </div>
            
            <div class="component-box">
                <h3>ðŸŽ² Îµ<sub>t</sub>: Error Term</h3>
                <p>Random fluctuations not explained by model</p>
                <ul style="font-size: 18px;">
                    <li>Assumed normally distributed</li>
                    <li>Represents uncertainty</li>
                    <li>Used for prediction intervals</li>
                </ul>
            </div>
        </div>
        <div class="slide-number">21 / 34</div>
    </div>

    <!-- Slide 22: Prophet in Action -->
    <div class="slide">
        <h2>Prophet in Action: Retail Sales Example</h2>
        <canvas id="prophetFullExample" style="width: 100%; height: 400px; margin-top: 20px;"></canvas>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 30px;">
            <div style="text-align: center;">
                <h4 style="color: #dc3545;">Historical Data</h4>
                <p style="font-size: 16px;">3 years of daily sales</p>
            </div>
            <div style="text-align: center;">
                <h4 style="color: #28a745;">Prophet Forecast</h4>
                <p style="font-size: 16px;">90-day prediction</p>
            </div>
            <div style="text-align: center;">
                <h4 style="color: #ffc107;">Uncertainty Bands</h4>
                <p style="font-size: 16px;">80% confidence interval</p>
            </div>
        </div>
        
        <p style="font-size: 20px; text-align: center; margin-top: 20px; padding: 15px; background-color: #e8f4f8; border-radius: 8px;">
            Notice: Prophet automatically detects weekly patterns (weekend peaks) and yearly seasonality (holiday shopping)
        </p>
        <div class="slide-number">22 / 34</div>
    </div>

    <!-- Slide 23: Prophet Exercise -->
    <div class="slide">
        <h2>Exercise: Prophet vs Naive Forecasting</h2>
        <p style="font-size: 20px;">Given 5 days of historical sales data, forecast the next 3 days using both methods.</p>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            <div>
                <h4>Historical Data (January 2025)</h4>
                <table class="data-table" style="font-size: 18px;">
                    <tr>
                        <th>Date</th>
                        <th>Day</th>
                        <th>Sales</th>
                    </tr>
                    <tr><td>Jan 20 (Mon)</td><td>Monday</td><td>120</td></tr>
                    <tr><td>Jan 21 (Tue)</td><td>Tuesday</td><td>118</td></tr>
                    <tr><td>Jan 22 (Wed)</td><td>Wednesday</td><td>119</td></tr>
                    <tr><td>Jan 23 (Thu)</td><td>Thursday</td><td>121</td></tr>
                    <tr><td>Jan 24 (Fri)</td><td>Friday</td><td>125</td></tr>
                </table>
            </div>
            
            <div style="background-color: #f8f9fa; padding: 15px; border-radius: 8px;">
                <h4>Prophet Model Components</h4>
                <p style="font-size: 16px; margin: 5px 0;"><strong>Trend:</strong> g(t) = 119 + 1.2Ã—t</p>
                <p style="font-size: 14px; margin: 5px 0;">(t = 0 for Jan 20, t = 1 for Jan 21, etc.)</p>
                
                <h5 style="margin-top: 10px;">Weekly Seasonality s(t):</h5>
                <table style="font-size: 14px; margin: 5px 0;">
                    <tr>
                        <td>Mon: 0</td>
                        <td>Tue: -2</td>
                        <td>Wed: -1</td>
                    </tr>
                    <tr>
                        <td>Thu: +1</td>
                        <td>Fri: +4</td>
                        <td>Sat: +8</td>
                    </tr>
                    <tr>
                        <td colspan="3">Sun: +5</td>
                    </tr>
                </table>
                
                <p style="font-size: 14px; margin: 10px 0;"><strong>Special Event:</strong> Jan 25 (Sat) Marketing Campaign: h(t) = +10</p>
                <p style="font-size: 16px; margin: 5px 0;"><strong>Formula:</strong> y(t) = g(t) + s(t) + h(t)</p>
            </div>
        </div>
        
        <h4 style="margin-top: 20px;">Complete the Forecast Table:</h4>
        <table class="data-table" style="font-size: 16px;">
            <thead>
                <tr>
                    <th rowspan="2">Date</th>
                    <th rowspan="2">Day</th>
                    <th rowspan="2">t</th>
                    <th colspan="4">Prophet Components</th>
                    <th rowspan="2">Naive<br>Forecast</th>
                </tr>
                <tr>
                    <th>g(t)</th>
                    <th>s(t)</th>
                    <th>h(t)</th>
                    <th>y(t) = g+s+h</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Jan 25</td>
                    <td>Sat</td>
                    <td>5</td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                </tr>
                <tr>
                    <td>Jan 26</td>
                    <td>Sun</td>
                    <td>6</td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                </tr>
                <tr>
                    <td>Jan 27</td>
                    <td>Mon</td>
                    <td>7</td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                    <td><input type="text" placeholder="?" style="width: 50px;"></td>
                </tr>
            </tbody>
        </table>
        <p style="margin-top: 15px; font-size: 18px; text-align: center;">Which method better captures the weekend effect and marketing event?</p>
        <div class="slide-number">23 / 34</div>
    </div>

    <!-- Slide 24: Hands-on Exercise Instructions -->
    <div class="slide">
        <h2>Hands-on Exercise: RetailIndustry.xlsx Analysis</h2>
        <h3 style="color: #007bff; margin-bottom: 25px;">Using Exploratory.io for Time Series Forecasting</h3>
        
        <div style="background-color: #f8f9fa; padding: 25px; border-radius: 10px; margin-bottom: 25px;">
            <h4 style="margin-bottom: 15px;">Dataset Description:</h4>
            <p style="font-size: 20px;">Daily retail data containing: Date, Marketing Spend ($), Number of Promotions, 
            Website Traffic (thousands), Customer Footfall (thousands), Daily Sales ($)</p>
        </div>
        
        <h4>Your Tasks:</h4>
        <ol style="font-size: 22px; margin-left: 40px; line-height: 2;">
            <li><strong>Import Data:</strong> Load RetailIndustry.xlsx into Exploratory.io</li>
            <li><strong>Moving Average:</strong> Apply MA(7) and MA(14) to Daily Sales</li>
            <li><strong>Regression Model:</strong> Build a regression model using Marketing Spend, Promotions, and Website Traffic as predictors</li>
            <li><strong>Prophet Forecast:</strong> Use Prophet to forecast Daily Sales for 70 days ahead</li>
            <li><strong>Analysis:</strong> Investigate seasonal patterns and evaluate model performance</li>
        </ol>
        
        <p style="margin-top: 30px; font-size: 20px; color: #dc3545; font-weight: bold;">
            Complete the analysis before answering the following quiz questions
        </p>
        <div class="slide-number">20 / 31</div>
    </div>

    <!-- Slide 21: Quiz Question 1 -->
    <div class="slide">
        <h2>Quiz Question 1: Moving Average Analysis</h2>
        <p style="font-size: 24px; margin-bottom: 30px;">
            After applying MA(7) and MA(14) to the Daily Sales data, which statement best describes the relationship between these two moving averages?
        </p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            A. MA(7) produces a smoother line than MA(14) with less lag
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">
            B. MA(14) produces a smoother line than MA(7) but with more lag
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            C. Both moving averages produce identical smoothing effects
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            D. MA(7) has more lag than MA(14) in following the trend
        </button>
        <div style="margin-top: 40px; padding: 20px; background-color: #e8f4f8; border-radius: 8px;">
            <p style="font-size: 18px; color: #666;">
                <strong>Hint:</strong> Consider how window size affects smoothness and responsiveness to changes
            </p>
        </div>
        <div class="slide-number">21 / 31</div>
    </div>

    <!-- Slide 22: Quiz Question 2 -->
    <div class="slide">
        <h2>Quiz Question 2: Regression Model Insights</h2>
        <p style="font-size: 24px; margin-bottom: 30px;">
            In your regression model predicting Daily Sales, which variable would you expect to have the strongest positive correlation based on typical retail patterns?
        </p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            A. Number of Promotions only
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            B. Marketing Spend only
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">
            C. Customer Footfall (foot traffic in store)
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            D. Website Traffic only
        </button>
        <div style="margin-top: 40px; padding: 20px; background-color: #e8f4f8; border-radius: 8px;">
            <p style="font-size: 18px; color: #666;">
                <strong>Hint:</strong> Think about which metric most directly indicates purchase intent in a physical retail setting
            </p>
        </div>
        <div class="slide-number">22 / 31</div>
    </div>

    <!-- Slide 23: Quiz Question 3 -->
    <div class="slide">
        <h2>Quiz Question 3: Prophet Seasonality Detection</h2>
        <p style="font-size: 24px; margin-bottom: 30px;">
            When using Prophet to analyze the RetailIndustry daily sales data, which seasonal patterns would you most likely observe?
        </p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            A. Only yearly seasonality with peaks in summer
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">
            B. Weekly seasonality with weekend peaks and potential monthly patterns
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            C. No seasonal patterns, only random fluctuations
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            D. Hourly seasonality patterns
        </button>
        <div style="margin-top: 40px; padding: 20px; background-color: #e8f4f8; border-radius: 8px;">
            <p style="font-size: 18px; color: #666;">
                <strong>Hint:</strong> Consider typical retail shopping behaviors and the daily frequency of the data
            </p>
        </div>
        <div class="slide-number">23 / 31</div>
    </div>

    <!-- Slide 24: Quiz Question 4 -->
    <div class="slide">
        <h2>Quiz Question 4: Model Comparison</h2>
        <p style="font-size: 24px; margin-bottom: 30px;">
            For forecasting daily sales 70 days ahead with significant promotional events planned, which approach would likely provide the most accurate predictions?
        </p>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            A. Simple Moving Average (MA) alone
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            B. Linear regression without external variables
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, true)">
            C. Prophet with external regressors (marketing spend, promotions)
        </button>
        <button class="quiz-option" onclick="checkAnswer(this, false)">
            D. Naive forecast method
        </button>
        <div style="margin-top: 40px; padding: 20px; background-color: #e8f4f8; border-radius: 8px;">
            <p style="font-size: 18px; color: #666;">
                <strong>Hint:</strong> Consider which method can incorporate known future events and external factors
            </p>
        </div>
        <div class="slide-number">24 / 34</div>
    </div>

    <!-- Slide 25: Exercise Summary and Next Steps -->
    <div class="slide">
        <h2>Exercise Summary: Key Takeaways</h2>
        <div style="background-color: #f0f8ff; padding: 30px; border-radius: 10px; margin-bottom: 25px;">
            <h3 style="margin-bottom: 20px;">What You've Learned from the Analysis:</h3>
            <ul style="font-size: 22px; margin-left: 30px;">
                <li>Moving averages trade off responsiveness for smoothness</li>
                <li>External factors significantly impact retail sales</li>
                <li>Prophet can capture complex seasonal patterns automatically</li>
                <li>Combining methods often yields better forecasts</li>
            </ul>
        </div>
        
        <h3 style="margin-top: 30px;">Next Steps in Exploratory.io:</h3>
        <ol style="font-size: 22px; margin-left: 40px; line-height: 1.8;">
            <li>Export your Prophet forecast results</li>
            <li>Create visualization comparing all three methods</li>
            <li>Calculate forecast accuracy metrics (MAE, RMSE)</li>
            <li>Document your findings and insights</li>
        </ol>
        
        <p style="margin-top: 30px; font-size: 20px; text-align: center; color: #007bff;">
            <strong>Remember to save your Exploratory.io project for future reference!</strong>
        </p>
        <div class="slide-number">25 / 34</div>
    </div>

    <!-- Additional slides to reach 31 total -->
    <div class="slide">
        <h2>Summary: Forecasting Techniques</h2>
        <ul style="font-size: 24px; margin-left: 40px;">
            <li>Naive Forecast: Simple baseline method</li>
            <li>Moving Average: Smooths out short-term fluctuations</li>
            <li>Time Series Decomposition: Separates components for analysis</li>
            <li>Choose appropriate methods based on data characteristics</li>
        </ul>
        <h1>Reminder: Next Week is the assessment 1 week. Form a group of 3-4 people for this assessment.</h1>
        <div class="slide-number">26 / 34</div>
    </div>

  
    </div>



    <div class="navigation">
        <button id="prevBtn" onclick="changeSlide(-1)">Previous</button>
        <button id="nextBtn" onclick="changeSlide(1)">Next</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        function showSlide(n) {
            slides.forEach(slide => slide.classList.remove('active'));
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            
            document.getElementById('prevBtn').disabled = currentSlide === 0;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides - 1;
            
            // Update slide numbers
            slides.forEach((slide, index) => {
                const slideNumber = slide.querySelector('.slide-number');
                if (slideNumber) {
                    slideNumber.textContent = `${index + 1} / ${totalSlides}`;
                }
            });
            
            // Draw charts when slides become visible
            drawChartsForSlide(currentSlide);
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') changeSlide(-1);
            if (e.key === 'ArrowRight') changeSlide(1);
        });

        // Chart drawing functions
        function drawChartsForSlide(slideIndex) {
            switch(slideIndex) {
                case 1: // Slide 2
                    drawStationaryChart();
                    drawTrendChart();
                    break;
                case 2: // Slide 3
                    drawSeasonalChart();
                    drawCyclicalChart();
                    drawIrregularChart();
                    break;
                case 3: // Slide 4
                    drawQuizChart1();
                    break;
                case 5: // Slide 6
                    drawNaiveChart();
                    break;
                case 6: // Slide 7
                    drawNoisyVsSmoothCharts();
                    break;
                case 7: // Slide 8
                    drawSmoothingDemo();
                    break;
                case 8: // Slide 9
                    drawBeforeAfterSmoothing();
                    break;
                case 9: // Slide 10
                    drawQuizChart2();
                    break;
                case 10: // Slide 11
                    drawMovingAverageChart();
                    break;
                case 11: // Slide 12
                    setupMAComparison();
                    break;
                case 13: // Slide 14
                    drawDecompositionChart();
                    break;
                case 15: // Slide 16
                    drawAdditiveDecompChart();
                    break;
                case 16: // Slide 17
                    drawMultiplicativeDecompChart();
                    break;
                case 17: // Slide 18
                    drawDecompositionExamples();
                    break;
                case 18: // Slide 19
                    drawQuizChart3();
                    break;
                case 19: // Slide 20 - Prophet Introduction
                    drawProphetComparisonChart();
                    break;
                case 20: // Slide 21 - Prophet Components
                    drawProphetComponentCharts();
                    break;
                case 21: // Slide 22 - Prophet in Action
                    drawProphetFullExample();
                    break;
            }
        }

        // Chart drawing implementations
        function drawLineChart(canvasId, data, label, color = '#007bff') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw data
            const xStep = graphWidth / (data.length - 1);
            const yMin = Math.min(...data);
            const yMax = Math.max(...data);
            const yScale = graphHeight / (yMax - yMin);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            data.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - yMin) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = color;
            data.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - yMin) * yScale;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function drawStationaryChart() {
            const data = Array(50).fill(0).map(() => 50 + Math.random() * 10 - 5);
            drawLineChart('stationaryChart', data, 'Stationary', '#28a745');
        }

        function drawTrendChart() {
            const data = Array(50).fill(0).map((_, i) => 30 + i * 0.8 + Math.random() * 5);
            drawLineChart('trendChart', data, 'Trend', '#dc3545');
        }

        function drawSeasonalChart() {
            const data = Array(50).fill(0).map((_, i) => 50 + 20 * Math.sin(i * 2 * Math.PI / 12) + Math.random() * 3);
            drawLineChart('seasonalChart', data, 'Seasonal', '#ffc107');
        }

        function drawCyclicalChart() {
            const data = [];
            let trend = 30;
            for (let i = 0; i < 30; i++) {
                // Simulate long-term ups and downs using low-frequency sine with random phase shifts
                const cycle = 10 * Math.sin(i * 2 * Math.PI / (40 + Math.random() * 20));
                trend += (Math.random() - 0.5) * 0.5;  // slow drift
                const noise = Math.random() * 2;
                data.push(trend + cycle + noise);
            }
            drawLineChart('cyclicalChart', data, 'Cyclical', '#17a2b8');
        }

        function drawIrregularChart() {
            const data = Array(50).fill(0).map(() => 50 + Math.random() * 20 - 10);
            drawLineChart('irregularChart', data, 'Irregular', '#6c757d');
        }

        function drawQuizChart1() {
            const data = Array(48).fill(0).map((_, i) => 50 + 25 * Math.sin(i * 2 * Math.PI / 12) + Math.random() * 5);
            drawLineChart('quizChart1', data, 'Time Series', '#007bff');
        }

        function drawNaiveChart() {
            const canvas = document.getElementById('naiveChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, width, height);

            const actualData = [45, 48, 52, 49, 51, 55, 53];
            const lastValue = actualData[actualData.length - 1];

            // Forecasts: only AFTER actual data
            const forecastHorizon = 5;
            const naiveForecast = Array(forecastHorizon).fill(lastValue);
            const regressionForecast = Array(forecastHorizon).fill(0).map((_, i) =>
                lastValue + (Math.sin(i) * 2) // simple zig-zag
            );

            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const totalPoints = actualData.length + forecastHorizon;
            const xStep = graphWidth / (totalPoints - 1);

            // Axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw actual data
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            actualData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 40) * (graphHeight / 20);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw naive forecast (flat line)
            ctx.strokeStyle = '#28a745'; // green
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            const startNaiveX = padding + (actualData.length - 1) * xStep;
            const startNaiveY = height - padding - (lastValue - 40) * (graphHeight / 20);
            ctx.moveTo(startNaiveX, startNaiveY);
            naiveForecast.forEach((value, i) => {
                const x = padding + (actualData.length + i) * xStep;
                const y = startNaiveY;
                ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw regression forecast (zig-zag)
            ctx.strokeStyle = '#dc3545'; // red
            ctx.beginPath();
            ctx.moveTo(startNaiveX, startNaiveY); // start from last actual point
            regressionForecast.forEach((value, i) => {
                const x = padding + (actualData.length + i) * xStep;
                const y = height - padding - (value - 40) * (graphHeight / 20);
                ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);

            // Legend
            ctx.font = '14px Helvetica';
            ctx.fillStyle = '#007bff';
            ctx.fillText('Actual', width - 130, 30);
            ctx.fillStyle = '#28a745';
            ctx.fillText('Naive Forecast', width - 130, 50);
            ctx.fillStyle = '#dc3545';
            ctx.fillText('Regression Forecast', width - 130, 70);
        }


        function drawNoisyVsSmoothCharts() {
            // Noisy chart
            const noisyData = Array(50).fill(0).map((_, i) => 50 + i * 0.5 + Math.random() * 30 - 15);
            drawLineChart('noisyChart', noisyData, 'Noisy', '#dc3545');
            
            // Smooth chart
            const smoothData = Array(50).fill(0).map((_, i) => 50 + i * 0.5 + Math.sin(i * 0.2) * 5);
            drawLineChart('smoothChart', smoothData, 'Smooth', '#28a745');
        }

        function drawSmoothingDemo() {
            const canvas = document.getElementById('smoothingDemo');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const originalData = Array(50).fill(0).map((_, i) => 50 + i * 0.3 + Math.random() * 20 - 10);
            const smoothedData = originalData.map((val, i, arr) => {
                if (i < 2) return val;
                return (arr[i-2] + arr[i-1] + val) / 3;
            });
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw original data
            const xStep = graphWidth / (originalData.length - 1);
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 2;
            ctx.beginPath();
            originalData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 30) * (graphHeight / 40);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw smoothed data
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            smoothedData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 30) * (graphHeight / 40);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.font = '16px Helvetica';
            ctx.fillStyle = '#dc3545';
            ctx.fillText('Original Data', width - 150, 30);
            ctx.fillStyle = '#007bff';
            ctx.fillText('Smoothed Data', width - 150, 55);
        }

        function drawBeforeAfterSmoothing() {
            const canvas = document.getElementById('beforeAfterSmoothing');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Generate data with trend and noise
            const trendData = Array(60).fill(0).map((_, i) => 40 + i * 0.5 + 10 * Math.sin(i * 2 * Math.PI / 20));
            const noisyData = trendData.map(val => val + Math.random() * 15 - 7.5);
            const smoothedData = noisyData.map((val, i, arr) => {
                if (i < 4 || i >= arr.length - 4) return val;
                return arr.slice(i-4, i+5).reduce((a, b) => a + b) / 9;
            });
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw all three lines
            const xStep = graphWidth / (trendData.length - 1);
            
            // Original noisy data
            ctx.strokeStyle = 'rgba(220, 53, 69, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            noisyData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 20) * (graphHeight / 60);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // True trend
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            trendData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 20) * (graphHeight / 60);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Smoothed data
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            smoothedData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 20) * (graphHeight / 60);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.font = '14px Helvetica';
            ctx.fillStyle = '#dc3545';
            ctx.fillText('Original (Noisy)', width - 160, 30);
            ctx.fillStyle = '#28a745';
            ctx.fillText('True Pattern', width - 160, 50);
            ctx.fillStyle = '#007bff';
            ctx.fillText('After Smoothing', width - 160, 70);
        }

        function drawQuizChart2() {
            const canvas = document.getElementById('quizChart2');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Series A - Already smooth
            const seriesA = Array(50).fill(0).map((_, i) => 50 + i * 0.4 + 5 * Math.sin(i * 0.3));
            
            // Series B - Very noisy
            const seriesB = Array(50).fill(0).map((_, i) => 50 + i * 0.4 + Math.random() * 30 - 15);
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            const xStep = graphWidth / (seriesA.length - 1);
            
            // Draw Series A
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            seriesA.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 30) * (graphHeight / 50);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw Series B
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 2;
            ctx.beginPath();
            seriesB.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 30) * (graphHeight / 50);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.font = '16px Helvetica';
            ctx.fillStyle = '#007bff';
            ctx.fillText('Series A', width - 100, 30);
            ctx.fillStyle = '#dc3545';
            ctx.fillText('Series B', width - 100, 55);
        }

        function drawMovingAverageChart() {
            const canvas = document.getElementById('movingAverageChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const originalData = [42, 45, 48, 46, 52, 51, 49, 53, 55, 52, 54, 58];
            const ma3Data = originalData.map((val, i, arr) => {
                if (i < 2) return null;
                return (arr[i-2] + arr[i-1] + val) / 3;
            });
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            const xStep = graphWidth / (originalData.length - 1);
            
            // Draw original data
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            originalData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 40) * (graphHeight / 20);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#6c757d';
            originalData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 40) * (graphHeight / 20);
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw MA(3)
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let firstPoint = true;
            ma3Data.forEach((value, i) => {
                if (value !== null) {
                    const x = padding + i * xStep;
                    const y = height - padding - (value - 40) * (graphHeight / 20);
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            ctx.stroke();
            
            // Draw MA points
            ctx.fillStyle = '#007bff';
            ma3Data.forEach((value, i) => {
                if (value !== null) {
                    const x = padding + i * xStep;
                    const y = height - padding - (value - 40) * (graphHeight / 20);
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Legend
            ctx.font = '16px Helvetica';
            ctx.fillStyle = '#6c757d';
            ctx.fillText('Original Data', width - 150, 30);
            ctx.fillStyle = '#007bff';
            ctx.fillText('MA(3)', width - 150, 55);
            
            // Labels for x-axis
            ctx.font = '12px Helvetica';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            originalData.forEach((_, i) => {
                const x = padding + i * xStep;
                ctx.fillText(`t${i+1}`, x, height - padding + 20);
            });
        }

        function setupMAComparison() {
            const canvas = document.getElementById('maComparisonChart');
            if (!canvas) return;
            
            const originalData = [42, 45, 48, 46, 52, 51, 49, 53, 55, 52];
            drawMAComparisonChart(originalData);
        }

        function drawMAComparisonChart(data) {
            const canvas = document.getElementById('maComparisonChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const ma2Data = data.map((val, i, arr) => {
                if (i < 1) return null;
                return (arr[i-1] + val) / 2;
            });
            
            const ma3Data = data.map((val, i, arr) => {
                if (i < 2) return null;
                return (arr[i-2] + arr[i-1] + val) / 3;
            });
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            const xStep = graphWidth / (data.length - 1);
            
            // Draw original data
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            data.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - 40) * (graphHeight / 20);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw MA(2)
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let firstPoint2 = true;
            ma2Data.forEach((value, i) => {
                if (value !== null) {
                    const x = padding + i * xStep;
                    const y = height - padding - (value - 40) * (graphHeight / 20);
                    if (firstPoint2) {
                        ctx.moveTo(x, y);
                        firstPoint2 = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            ctx.stroke();
            
            // Draw MA(3)
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let firstPoint3 = true;
            ma3Data.forEach((value, i) => {
                if (value !== null) {
                    const x = padding + i * xStep;
                    const y = height - padding - (value - 40) * (graphHeight / 20);
                    if (firstPoint3) {
                        ctx.moveTo(x, y);
                        firstPoint3 = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            ctx.stroke();
            
            // Legend
            ctx.font = '16px Helvetica';
            ctx.fillStyle = '#6c757d';
            ctx.fillText('Original', width - 150, 30);
            ctx.fillStyle = '#28a745';
            ctx.fillText('MA(2)', width - 150, 55);
            ctx.fillStyle = '#007bff';
            ctx.fillText('MA(3)', width - 150, 80);
        }

        let animationStep = 0;
        function animateMA() {
            const data = [42, 45, 48, 46, 52, 51, 49, 53, 55, 52];
            const ma2Calc = document.getElementById('ma2Calc');
            const ma3Calc = document.getElementById('ma3Calc');
            
            if (animationStep < data.length) {
                drawMAComparisonChart(data.slice(0, Math.min(animationStep + 3, data.length)));
                
                // Show calculations
                if (animationStep >= 1) {
                    ma2Calc.innerHTML = `Period ${animationStep + 1}: (${data[animationStep-1]} + ${data[animationStep]}) / 2 = ${((data[animationStep-1] + data[animationStep]) / 2).toFixed(1)}`;
                }
                if (animationStep >= 2) {
                    ma3Calc.innerHTML = `Period ${animationStep + 1}: (${data[animationStep-2]} + ${data[animationStep-1]} + ${data[animationStep]}) / 3 = ${((data[animationStep-2] + data[animationStep-1] + data[animationStep]) / 3).toFixed(1)}`;
                }
                
                animationStep++;
                if (animationStep < data.length) {
                    setTimeout(() => animateMA(), 800);
                }
            } else {
                animationStep = 0;
            }
        }

        function drawDecompositionChart() {
            const canvas = document.getElementById('decompositionChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Generate components
            const n = 60;
            const trend = Array(n).fill(0).map((_, i) => 50 + i * 0.3);
            const seasonal = Array(n).fill(0).map((_, i) => 10 * Math.sin(i * 2 * Math.PI / 12));
            const irregular = Array(n).fill(0).map(() => Math.random() * 4 - 2);
            const combined = trend.map((t, i) => t + seasonal[i] + irregular[i]);
            
            const padding = 40;
            const sectionHeight = (height - 2 * padding) / 4;
            
            // Draw each component
            const components = [
                { data: combined, label: 'Original Series', color: '#333' },
                { data: trend, label: 'Trend', color: '#dc3545' },
                { data: seasonal, label: 'Seasonal', color: '#28a745' },
                { data: irregular, label: 'Irregular', color: '#6c757d' }
            ];
            
            components.forEach((comp, idx) => {
                const yOffset = padding + idx * sectionHeight;
                
                // Label
                ctx.font = '14px Helvetica';
                ctx.fillStyle = comp.color;
                ctx.fillText(comp.label, 10, yOffset + sectionHeight / 2);
                
                // Draw line
                ctx.strokeStyle = comp.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const xStep = (width - 2 * padding - 100) / (comp.data.length - 1);
                const yMin = Math.min(...comp.data);
                const yMax = Math.max(...comp.data);
                const yScale = (sectionHeight - 20) / (yMax - yMin);
                
                comp.data.forEach((value, i) => {
                    const x = padding + 80 + i * xStep;
                    const y = yOffset + sectionHeight / 2 - (value - (yMax + yMin) / 2) * yScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        function drawAdditiveDecompChart() {
            const canvas = document.getElementById('additiveDecompChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Generate additive components
            const n = 72;
            const trend = Array(n).fill(0).map((_, i) => 100 + i * 0.5);
            const seasonal = Array(n).fill(0).map((_, i) => 20 * Math.sin(i * 2 * Math.PI / 12));
            const irregular = Array(n).fill(0).map(() => Math.random() * 10 - 5);
            const combined = trend.map((t, i) => t + seasonal[i] + irregular[i]);
            
            const padding = 50;
            const sectionHeight = (height - 2 * padding) / 4;
            
            // Draw components
            const components = [
                { data: combined, label: 'Y = T + S + I', color: '#333' },
                { data: trend, label: 'Trend (T)', color: '#dc3545' },
                { data: seasonal, label: 'Seasonal (S)', color: '#28a745' },
                { data: irregular, label: 'Irregular (I)', color: '#6c757d' }
            ];
            
            components.forEach((comp, idx) => {
                const yOffset = padding + idx * sectionHeight;
                
                // Draw dividing line
                if (idx > 0) {
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, yOffset);
                    ctx.lineTo(width - padding, yOffset);
                    ctx.stroke();
                }
                
                // Label
                ctx.font = '16px Helvetica';
                ctx.fillStyle = comp.color;
                ctx.fillText(comp.label, padding, yOffset + 20);
                
                // Draw line
                ctx.strokeStyle = comp.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const xStep = (width - 2 * padding) / (comp.data.length - 1);
                const yMin = Math.min(...comp.data);
                const yMax = Math.max(...comp.data);
                const yScale = (sectionHeight - 40) / (yMax - yMin);
                
                comp.data.forEach((value, i) => {
                    const x = padding + i * xStep;
                    const y = yOffset + 30 + (sectionHeight - 40) - (value - yMin) * yScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        function drawMultiplicativeDecompChart() {
            const canvas = document.getElementById('multiplicativeDecompChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Generate multiplicative components
            const n = 72;
            const trend = Array(n).fill(0).map((_, i) => 50 + i * 0.8);
            const seasonal = Array(n).fill(0).map((_, i) => 1 + 0.3 * Math.sin(i * 2 * Math.PI / 12));
            const irregular = Array(n).fill(0).map(() => 1 + (Math.random() * 0.1 - 0.05));
            const combined = trend.map((t, i) => t * seasonal[i] * irregular[i]);
            
            const padding = 50;
            const sectionHeight = (height - 2 * padding) / 4;
            
            // Draw components
            const components = [
                { data: combined, label: 'Y = T Ã— S Ã— I', color: '#333' },
                { data: trend, label: 'Trend (T)', color: '#dc3545' },
                { data: seasonal, label: 'Seasonal (S)', color: '#28a745' },
                { data: irregular, label: 'Irregular (I)', color: '#6c757d' }
            ];
            
            components.forEach((comp, idx) => {
                const yOffset = padding + idx * sectionHeight;
                
                // Draw dividing line
                if (idx > 0) {
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(padding, yOffset);
                    ctx.lineTo(width - padding, yOffset);
                    ctx.stroke();
                }
                
                // Label
                ctx.font = '16px Helvetica';
                ctx.fillStyle = comp.color;
                ctx.fillText(comp.label, padding, yOffset + 20);
                
                // Draw line
                ctx.strokeStyle = comp.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const xStep = (width - 2 * padding) / (comp.data.length - 1);
                const yMin = Math.min(...comp.data);
                const yMax = Math.max(...comp.data);
                const yScale = (sectionHeight - 40) / (yMax - yMin);
                
                comp.data.forEach((value, i) => {
                    const x = padding + i * xStep;
                    const y = yOffset + 30 + (sectionHeight - 40) - (value - yMin) * yScale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        function drawDecompositionExamples() {
            drawAdditiveExampleChart();
            drawMultiplicativeExampleChart();
        }

        function drawAdditiveExampleChart() {
            const data = Array(48).fill(0).map((_, i) => 
                100 + i * 0.2 + 15 * Math.sin(i * 2 * Math.PI / 12) + Math.random() * 5
            );
            drawLineChart('additiveExampleChart', data, 'Additive', '#007bff');
        }

        function drawMultiplicativeExampleChart() {
            const data = Array(48).fill(0).map((_, i) => 
                (50 + i * 0.5) * (1 + 0.4 * Math.sin(i * 2 * Math.PI / 12)) * (1 + Math.random() * 0.1 - 0.05)
            );
            drawLineChart('multiplicativeExampleChart', data, 'Multiplicative', '#dc3545');
        }

        function drawQuizChart3() {
            const canvas = document.getElementById('quizChart3');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Generate data with increasing seasonal amplitude
            const n = 60;
            const data = Array(n).fill(0).map((_, i) => {
                const trend = 50 + i * 0.8;
                const seasonalAmplitude = 5 + i * 0.2; // Increasing amplitude
                const seasonal = seasonalAmplitude * Math.sin(i * 2 * Math.PI / 12);
                return trend + seasonal + Math.random() * 3;
            });
            
            drawLineChart('quizChart3', data, 'Time Series', '#17a2b8');
        }

        // Prophet chart drawing functions
        function drawProphetComparisonChart() {
            const canvas = document.getElementById('prophetComparisonChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Sample data with outliers and missing values
            const data = Array(50).fill(0).map((_, i) => {
                if (i === 15 || i === 35) return null; // Missing data
                const base = 100 + i * 2 + 20 * Math.sin(i * 2 * Math.PI / 7);
                if (i === 25) return base + 50; // Outlier
                return base + Math.random() * 10;
            });
            
            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw data with gaps
            const xStep = graphWidth / (data.length - 1);
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let inPath = false;
            
            data.forEach((value, i) => {
                if (value !== null) {
                    const x = padding + i * xStep;
                    const y = height - padding - (value - 50) * (graphHeight / 150);
                    
                    if (!inPath) {
                        ctx.moveTo(x, y);
                        inPath = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                } else {
                    inPath = false;
                }
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#007bff';
            data.forEach((value, i) => {
                if (value !== null) {
                    const x = padding + i * xStep;
                    const y = height - padding - (value - 50) * (graphHeight / 150);
                    ctx.beginPath();
                    ctx.arc(x, y, i === 25 ? 6 : 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Labels
            ctx.font = '12px Helvetica';
            ctx.fillStyle = '#666';
            ctx.fillText('Missing data handled', padding + 15 * xStep - 30, height - padding - 20);
            ctx.fillText('Outlier detected', padding + 25 * xStep - 30, height - padding - 100);
        }

        function drawProphetComponentCharts() {
            // Draw trend component
            const trendCanvas = document.getElementById('trendComponentChart');
            if (trendCanvas) {
                const ctx = trendCanvas.getContext('2d');
                const width = trendCanvas.width = trendCanvas.offsetWidth;
                const height = trendCanvas.height = trendCanvas.offsetHeight;
                
                ctx.clearRect(0, 0, width, height);
                
                // Linear trend with changepoint
                const data = Array(50).fill(0).map((_, i) => {
                    if (i < 25) return 50 + i * 0.8;
                    return 70 + (i - 25) * 1.5;
                });
                
                drawLineChart('trendComponentChart', data, 'Trend', '#dc3545');
                
                // Mark changepoint
                ctx.strokeStyle = '#666';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(width / 2, 20);
                ctx.lineTo(width / 2, height - 20);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.font = '12px Helvetica';
                ctx.fillStyle = '#666';
                ctx.fillText('Changepoint', width / 2 + 5, 30);
            }
            
            // Draw seasonal component
            const seasonalCanvas = document.getElementById('seasonalComponentChart');
            if (seasonalCanvas) {
                const data = Array(50).fill(0).map((_, i) => 
                    10 * Math.sin(i * 2 * Math.PI / 7) + 5 * Math.sin(i * 2 * Math.PI / 365.25)
                );
                drawLineChart('seasonalComponentChart', data, 'Seasonal', '#28a745');
            }
        }

        function drawProphetFullExample() {
            const canvas = document.getElementById('prophetFullExample');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const padding = 60;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Generate realistic retail data (3 years + 90 days forecast)
            const historicalDays = 365 * 3;
            const forecastDays = 90;
            const totalDays = historicalDays + forecastDays;
            
            // Historical data
            const historicalData = Array(historicalDays).fill(0).map((_, i) => {
                const trend = 1000 + i * 0.5;
                const weekly = 200 * Math.sin((i % 7) * 2 * Math.PI / 7 - Math.PI/2);
                const yearly = 300 * Math.sin(i * 2 * Math.PI / 365.25);
                const noise = Math.random() * 100 - 50;
                return trend + weekly + yearly + noise;
            });
            
            // Forecast data
            const forecastData = Array(forecastDays).fill(0).map((_, i) => {
                const day = historicalDays + i;
                const trend = 1000 + day * 0.5;
                const weekly = 200 * Math.sin((day % 7) * 2 * Math.PI / 7 - Math.PI/2);
                const yearly = 300 * Math.sin(day * 2 * Math.PI / 365.25);
                return trend + weekly + yearly;
            });
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            const xStep = graphWidth / totalDays;
            const allData = [...historicalData, ...forecastData];
            const yMin = Math.min(...allData) - 200;
            const yMax = Math.max(...allData) + 200;
            const yScale = graphHeight / (yMax - yMin);
            
            // Draw historical data
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            historicalData.forEach((value, i) => {
                const x = padding + i * xStep;
                const y = height - padding - (value - yMin) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Draw forecast line
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding + historicalDays * xStep, height - padding - (historicalData[historicalData.length - 1] - yMin) * yScale);
            forecastData.forEach((value, i) => {
                const x = padding + (historicalDays + i) * xStep;
                const y = height - padding - (value - yMin) * yScale;
                ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw uncertainty bands
            ctx.fillStyle = 'rgba(255, 193, 7, 0.3)';
            ctx.beginPath();
            ctx.moveTo(padding + historicalDays * xStep, height - padding - (historicalData[historicalData.length - 1] - yMin) * yScale);
            
            // Upper band
            forecastData.forEach((value, i) => {
                const x = padding + (historicalDays + i) * xStep;
                const y = height - padding - (value + 200 - yMin) * yScale;
                ctx.lineTo(x, y);
            });
            
            // Lower band (reverse)
            for (let i = forecastDays - 1; i >= 0; i--) {
                const x = padding + (historicalDays + i) * xStep;
                const y = height - padding - (forecastData[i] - 200 - yMin) * yScale;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            // Dividing line
            ctx.strokeStyle = '#666';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding + historicalDays * xStep, padding);
            ctx.lineTo(padding + historicalDays * xStep, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.font = '14px Helvetica';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('Historical Data', padding + historicalDays * xStep / 2, height - 20);
            ctx.fillText('Forecast', padding + historicalDays * xStep + forecastDays * xStep / 2, height - 20);
            
            // Y-axis label
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Daily Sales ($)', 0, 0);
            ctx.restore();
        }

        function checkAnswer(button, isCorrect) {
            const options = button.parentElement.querySelectorAll('.quiz-option');
            options.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
                opt.disabled = true;
            });
            
            if (isCorrect) {
                button.classList.add('correct');
            } else {
                button.classList.add('incorrect');
            }
        }

        // Initialize
        showSlide(0);
    </script>
</body>
</html>