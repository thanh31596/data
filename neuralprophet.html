<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralProphet Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        :root {
            --primary: #6200EA;
            --secondary: #3700B3;
            --tertiary: #03DAC6;
            --accent: #BB86FC;
            --error: #CF6679;
            --success: #00C853;
            --dark: #121212;
            --light: #F5F5F5;
            --shadow: rgba(0, 0, 0, 0.2);
            --chart-grid: #E0E0E0;
            --trend-color: #FF9800;
            --seasonality-color: #00BCD4;
            --holidays-color: #F44336;
            --ar-color: #4CAF50;
            --events-color: #9C27B0;
            --forecast-color: #7C4DFF;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #666;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .animation-container {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px var(--shadow);
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            height: 600px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .button:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(98, 0, 234, 0.3);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        .button.secondary {
            background-color: white;
            color: var(--primary);
            border: 2px solid var(--primary);
        }
        
        .button.secondary:hover {
            background-color: #f1f5fe;
        }
        
        .button.reset {
            background-color: #f1f1f1;
            color: #666;
            border: none;
        }
        
        .button.reset:hover {
            background-color: #e6e6e6;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .button svg {
            width: 16px;
            height: 16px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 0 10px;
        }
        
        .slider-label {
            font-weight: bold;
            min-width: 120px;
        }
        
        .slider {
            flex-grow: 1;
            max-width: 200px;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(98, 0, 234, 0.5);
        }
        
        .slider-value {
            font-weight: bold;
            color: var(--primary);
            min-width: 50px;
            text-align: center;
        }
        
        .phases {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            margin-bottom: 30px;
        }
        
        .phase {
            text-align: center;
            position: relative;
            flex: 1;
        }
        
        .phase-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #d3d3d3;
            margin: 0 auto 10px;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
        }
        
        .phase-line {
            position: absolute;
            height: 3px;
            background-color: #d3d3d3;
            top: 10px;
            left: 0;
            right: 0;
            z-index: 1;
        }
        
        .phase:first-child .phase-line {
            left: 50%;
            right: 0;
        }
        
        .phase:last-child .phase-line {
            left: 0;
            right: 50%;
        }
        
        .phase-label {
            font-weight: 500;
            font-size: 0.9rem;
            opacity: 0.7;
            transition: all 0.3s ease;
        }
        
        .phase.active .phase-dot {
            background-color: var(--primary);
            transform: scale(1.2);
            box-shadow: 0 0 0 5px rgba(98, 0, 234, 0.2);
        }
        
        .phase.active .phase-label {
            color: var(--primary);
            font-weight: bold;
            opacity: 1;
        }
        
        .phase.completed .phase-dot {
            background-color: var(--success);
        }
        
        .phase.completed .phase-line {
            background-color: var(--success);
        }
        
        .explanation {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            border-left: 5px solid var(--primary);
            box-shadow: 0 5px 15px var(--shadow);
            transition: all 0.3s ease;
            transform: translateY(0);
            z-index: 10;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .explanation.hidden {
            transform: translateY(200px);
        }
        
        .explanation-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .svg-container {
            width: 100%;
            height: 500px;
            position: relative;
        }
        
        #current-step-display {
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
            font-size: 1.1rem;
            height: 27px;
            text-align: center;
        }
        
        .section {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .section.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .step-indicators {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
        }
        
        .step-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ddd;
            transition: all 0.3s ease;
        }
        
        .step-dot.active {
            background-color: var(--primary);
            transform: scale(1.2);
        }
        
        /* Tooltip style */
        .tooltip {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            max-width: 200px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        /* Time series specific styles */
        .time-series-chart {
            background-color: white;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        
        .axis path, .axis line {
            stroke: var(--chart-grid);
        }
        
        .axis text {
            font-size: 10px;
            fill: #666;
        }
        
        .grid line {
            stroke: var(--chart-grid);
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }
        
        .grid path {
            stroke-width: 0;
        }
        
        .line {
            fill: none;
            stroke-width: 2;
        }
        
        .line.data {
            stroke: var(--primary);
        }
        
        .line.trend {
            stroke: var(--trend-color);
        }
        
        .line.seasonality {
            stroke: var(--seasonality-color);
        }
        
        .line.holidays {
            stroke: var(--holidays-color);
        }
        
        .line.ar {
            stroke: var(--ar-color);
        }
        
        .line.events {
            stroke: var(--events-color);
        }
        
        .line.forecast {
            stroke: var(--forecast-color);
            stroke-dasharray: 5, 5;
        }
        
        .area {
            opacity: 0.2;
        }
        
        .area.trend {
            fill: var(--trend-color);
        }
        
        .area.seasonality {
            fill: var(--seasonality-color);
        }
        
        .area.holidays {
            fill: var(--holidays-color);
        }
        
        .area.ar {
            fill: var(--ar-color);
        }
        
        .area.events {
            fill: var(--events-color);
        }
        
        .area.forecast {
            fill: var(--forecast-color);
        }
        
        .data-flow-path {
            fill: none;
            stroke: #bbb;
            stroke-width: 1;
            stroke-dasharray: 4, 2;
        }
        
        .neural-network {
            position: relative;
        }
        
        .neuron {
            fill: white;
            stroke: var(--primary);
            stroke-width: 2;
        }
        
        .neuron.active {
            fill: var(--accent);
        }
        
        .neuron-connection {
            stroke: #ccc;
            stroke-width: 1.5;
        }
        
        .neuron-connection.active {
            stroke: var(--primary);
            stroke-width: 2;
        }
        
        .component-box {
            fill: white;
            stroke: var(--secondary);
            stroke-width: 2;
            rx: 5;
            ry: 5;
        }
        
        .component-label {
            font-size: 12px;
            text-anchor: middle;
            font-weight: bold;
        }
        
        .moving-data {
            fill: var(--primary);
            stroke: white;
            stroke-width: 2;
        }
        
        .highlight {
            animation: pulse 1.5s infinite;
        }
        
        .data-table {
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9rem;
        }
        
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }
        
        .data-table th {
            background-color: #f8f9fd;
            color: var(--primary);
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        
        .loss-chart {
            margin-top: 20px;
        }
        
        .epoch-indicator {
            fill: var(--primary);
            stroke: white;
            stroke-width: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NeuralProphet: Interactive Animation</h1>
            <p class="subtitle">Visualizing the complete workflow of NeuralProphet: from data ingestion through model training to forecasting</p>
        </header>
        
        <div class="controls">
            <button id="play-pause-btn" class="button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                Play Animation
            </button>
            
            <button id="next-step-btn" class="button secondary">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
                Next Step
            </button>
            
            <button id="prev-step-btn" class="button secondary">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="15 18 9 12 15 6"></polyline>
                </svg>
                Previous Step
            </button>
            
            <button id="reset-btn" class="button reset">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 2v6h6"></path>
                    <path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path>
                    <path d="M21 22v-6h-6"></path>
                    <path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path>
                </svg>
                Reset
            </button>
            
            <div class="slider-container">
                <div class="slider-label">Animation Speed</div>
                <input type="range" min="1" max="3" step="0.5" value="1.5" class="slider" id="speed-slider">
                <div class="slider-value" id="speed-value">1.5x</div>
            </div>
        </div>
        
        <div id="current-step-display"></div>
        
        <div class="phases">
            <div class="phase" id="phase-data">
                <div class="phase-dot"></div>
                <div class="phase-line"></div>
                <div class="phase-label">Data Ingestion</div>
            </div>
            <div class="phase" id="phase-processing">
                <div class="phase-dot"></div>
                <div class="phase-line"></div>
                <div class="phase-label">Data Processing</div>
            </div>
            <div class="phase" id="phase-training">
                <div class="phase-dot"></div>
                <div class="phase-line"></div>
                <div class="phase-label">Model Training</div>
            </div>
            <div class="phase" id="phase-forecasting">
                <div class="phase-dot"></div>
                <div class="phase-line"></div>
                <div class="phase-label">Forecasting</div>
            </div>
        </div>
        
        <div class="animation-container">
            <div id="section-data-ingestion" class="section active">
                <h2 style="margin-bottom: 20px; color: 'var(--primary)';">Time Series Data Ingestion</h2>
                <div id="data-vis"></div>
            </div>
            
            <div id="section-data-processing" class="section">
                <h2 style="margin-bottom: 20px; color: 'var(--primary)';">Time Series Decomposition</h2>
                <div id="processing-vis"></div>
            </div>
            
            <div id="section-training" class="section">
                <h2 style="margin-bottom: 20px; color: 'var(--primary)';">Training NeuralProphet Model</h2>
                <div id="training-vis"></div>
            </div>
            
            <div id="section-forecasting" class="section">
                <h2 style="margin-bottom: 20px; color: 'var(--primary)';">Generating Forecasts</h2>
                <div id="forecasting-vis"></div>
            </div>
            
            <!-- <div id="explanation" class="explanation">
                <div class="explanation-title">Welcome to NeuralProphet Animation</div>
                <p>This interactive animation walks you through how NeuralProphet works - from data ingestion to forecasting. Use the controls above to navigate through the steps or play the full animation.</p>
            </div> -->
        </div>
        
        <div class="step-indicators" id="step-indicators">
            <!-- Step indicators will be dynamically added here -->
        </div>
    </div>
    
    <div id="tooltip" class="tooltip"></div>
    
    <script>
        // Animation configuration and state
        const config = {
            animationSpeed: 1.5,
            currentPhase: 'data',
            isPlaying: false,
            currentStep: 0,
            phaseSteps: {
                data: 4,
                processing: 6,
                training: 7,
                forecasting: 5
            },
            totalSteps: 22,
            stepDelay: 2000, // milliseconds between steps
            animationTimeline: null,
            width: 1100,
            height: 450,
            margin: {top: 40, right: 40, bottom: 40, left: 60}
        };
        
        // Sample time series data for visualization
        // Generate realistic time series data with trend, seasonality and some noise
        const generateTimeSeriesData = () => {
            const data = [];
            const startDate = new Date(2022, 0, 1);
            const numDays = 180;
            
            for (let i = 0; i < numDays; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                // Base trend
                let value = 100 + i * 0.5;
                
                // Weekly seasonality (weekends are higher)
                const dayOfWeek = date.getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    value += 20;
                }
                
                // Monthly seasonality (higher at start of month)
                const dayOfMonth = date.getDate();
                if (dayOfMonth <= 5) {
                    value += 15;
                }
                
                // Add special events/holidays
                if ((date.getMonth() === 0 && date.getDate() === 1) || // New Year
                    (date.getMonth() === 6 && date.getDate() === 4) || // Independence Day
                    (date.getMonth() === 11 && (date.getDate() === 25 || date.getDate() === 24))) { // Christmas
                    value += 40;
                }
                
                // Add some noise
                value += (Math.random() - 0.5) * 15;
                
                data.push({
                    date: date,
                    value: Math.round(value * 10) / 10,
                    isHoliday: ((date.getMonth() === 0 && date.getDate() === 1) || 
                              (date.getMonth() === 6 && date.getDate() === 4) || 
                              (date.getMonth() === 11 && (date.getDate() === 25 || date.getDate() === 24)))
                });
            }
            
            return data;
        };
        
        // Generate forecast data
        const generateForecastData = (historicalData, forecastDays = 30) => {
            const data = [];
            const lastDate = historicalData[historicalData.length - 1].date;
            
            for (let i = 1; i <= forecastDays; i++) {
                const date = new Date(lastDate);
                date.setDate(lastDate.getDate() + i);
                
                // Base trend continuation
                let value = historicalData[historicalData.length - 1].value + i * 0.5;
                
                // Weekly seasonality (weekends are higher)
                const dayOfWeek = date.getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    value += 20;
                }
                
                // Monthly seasonality (higher at start of month)
                const dayOfMonth = date.getDate();
                if (dayOfMonth <= 5) {
                    value += 15;
                }
                
                // Add special events/holidays
                if ((date.getMonth() === 0 && date.getDate() === 1) || // New Year
                    (date.getMonth() === 6 && date.getDate() === 4) || // Independence Day
                    (date.getMonth() === 11 && (date.getDate() === 25 || date.getDate() === 24))) { // Christmas
                    value += 40;
                }
                
                // Add uncertainty (increasing with forecast horizon)
                const uncertainty = i * 0.5;
                
                data.push({
                    date: date,
                    value: Math.round(value * 10) / 10,
                    upper: Math.round((value + uncertainty * 10) * 10) / 10,
                    lower: Math.round((value - uncertainty * 10) * 10) / 10,
                    isHoliday: ((date.getMonth() === 0 && date.getDate() === 1) || 
                              (date.getMonth() === 6 && date.getDate() === 4) || 
                              (date.getMonth() === 11 && (date.getDate() === 25 || date.getDate() === 24)))
                });
            }
            
            return data;
        };
        
        // Generate loss history data
        const generateLossData = () => {
            const data = [];
            const numEpochs = 50;
            let loss = 2.5;
            
            for (let i = 0; i < numEpochs; i++) {
                // Exponentially decreasing loss with some noise
                loss = loss * 0.93 + (Math.random() - 0.5) * 0.1;
                if (loss < 0.1) loss = 0.1 + Math.random() * 0.05;
                
                data.push({
                    epoch: i + 1,
                    loss: loss
                });
            }
            
            return data;
        };
        
        // Sample data
        const timeSeriesData = generateTimeSeriesData();
        const forecastData = generateForecastData(timeSeriesData);
        const lossData = generateLossData();
        
        // Decomposition data (will be calculated from time series data)
        let trendData = [];
        let seasonalityData = [];
        let holidaysData = [];
        let arData = []; // Autoregressive component
        
        // Calculate decomposition data
        const calculateDecomposition = () => {
            trendData = timeSeriesData.map((d, i) => {
                // Simple moving average for trend
                const windowSize = 14;
                let sum = 0;
                let count = 0;
                
                for (let j = Math.max(0, i - windowSize); j <= Math.min(timeSeriesData.length - 1, i + windowSize); j++) {
                    sum += timeSeriesData[j].value;
                    count++;
                }
                
                return {
                    date: d.date,
                    value: Math.round((sum / count) * 10) / 10
                };
            });
            
            seasonalityData = timeSeriesData.map((d, i) => {
                // Weekly seasonality pattern based on day of week
                const dayOfWeek = d.date.getDay();
                let seasonalValue = 0;
                
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    seasonalValue = 15 + Math.random() * 5;
                } else if (dayOfWeek === 1 || dayOfWeek === 5) {
                    seasonalValue = 5 + Math.random() * 5;
                } else {
                    seasonalValue = -5 + Math.random() * 10;
                }
                
                // Add monthly pattern
                const dayOfMonth = d.date.getDate();
                if (dayOfMonth <= 5) {
                    seasonalValue += 10;
                } else if (dayOfMonth >= 25) {
                    seasonalValue -= 5;
                }
                
                return {
                    date: d.date,
                    value: Math.round(seasonalValue * 10) / 10
                };
            });
            
            holidaysData = timeSeriesData.map((d) => {
                let holidayEffect = 0;
                
                if (d.isHoliday) {
                    holidayEffect = 30 + Math.random() * 10;
                }
                
                return {
                    date: d.date,
                    value: holidayEffect,
                    isHoliday: d.isHoliday
                };
            });
            
            arData = timeSeriesData.map((d, i) => {
                // AR component as residual after removing trend, seasonality, and holidays
                const trendVal = trendData[i].value;
                const seasonalVal = seasonalityData[i].value;
                const holidayVal = holidaysData[i].value;
                const residual = d.value - trendVal - seasonalVal - holidayVal;
                
                return {
                    date: d.date,
                    value: Math.round(residual * 10) / 10
                };
            });
        };
        
        calculateDecomposition();
        
        // DOM Elements
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const explanation = document.getElementById('explanation');
        const currentStepDisplay = document.getElementById('current-step-display');
        const stepIndicators = document.getElementById('step-indicators');
        
        // Phase elements
        const phaseData = document.getElementById('phase-data');
        const phaseProcessing = document.getElementById('phase-processing');
        const phaseTraining = document.getElementById('phase-training');
        const phaseForecasting = document.getElementById('phase-forecasting');
        
        // Section elements
        const sectionDataIngestion = document.getElementById('section-data-ingestion');
        const sectionDataProcessing = document.getElementById('section-data-processing');
        const sectionTraining = document.getElementById('section-training');
        const sectionForecasting = document.getElementById('section-forecasting');
        
        // Create svg containers for each section
        const dataVisSvg = d3.select('#data-vis')
            .append('svg')
            .attr('width', config.width)
            .attr('height', config.height);
            
        const processingVisSvg = d3.select('#processing-vis')
            .append('svg')
            .attr('width', config.width)
            .attr('height', config.height);
            
        const trainingVisSvg = d3.select('#training-vis')
            .append('svg')
            .attr('width', config.width)
            .attr('height', config.height);
            
        const forecastingVisSvg = d3.select('#forecasting-vis')
            .append('svg')
            .attr('width', config.width)
            .attr('height', config.height);
        
        // Step descriptions
        const stepDescriptions = [
            // Data Ingestion Phase
            "Welcome to the NeuralProphet visualization. We'll start with the data ingestion phase.",
            "Here's our time series data over time. This could be sales, website traffic, or any numerical value tracked over time.",
            "NeuralProphet works with historical time series data and additional regressors (like holidays, events, or other external factors).",
            "The data is normalized and prepared for the neural network, handling missing values and scaling features.",
            
            // Data Processing Phase
            "NeuralProphet decomposes time series into interpretable components.",
            "The trend component represents the overall direction of the time series over time.",
            "Seasonality captures recurring patterns at regular intervals (daily, weekly, yearly).",
            "Holiday effects model significant calendar events that impact the time series.",
            "Autoregressive (AR) components capture dependencies of current values on past observations.",
            "These components are processed separately before being combined in the neural network.",
            
            // Training Phase
            "Now we'll train the NeuralProphet model using a neural network architecture.",
            "NeuralProphet extends Facebook's Prophet using PyTorch neural networks for greater flexibility.",
            "The model processes different components through specialized layers in the network.",
            "During training, the model computes the loss (error) between predictions and actual values.",
            "The backpropagation algorithm updates network weights to minimize the loss function.",
            "Training continues for multiple epochs until the model converges or reaches a maximum epoch limit.",
            "After training, the model has learned optimal weights for each component to make accurate forecasts.",
            
            // Forecasting Phase
            "Now let's see how NeuralProphet generates forecasts for future time points.",
            "The model extrapolates the trend component into the future based on learned patterns.",
            "Seasonal patterns are repeated for future dates based on their respective cycles.",
            "Holiday effects are applied to future dates that match known holiday patterns.",
            "All components are combined to produce the final forecast with uncertainty intervals."
        ];
        
        // Create step indicators
        for (let i = 0; i < config.totalSteps; i++) {
            const dot = document.createElement('div');
            dot.className = 'step-dot';
            if (i === 0) dot.classList.add('active');
            dot.addEventListener('click', () => goToStep(i));
            stepIndicators.appendChild(dot);
        }
        
        // Initialize explanation text
        currentStepDisplay.textContent = stepDescriptions[0];
        
        // Initialize phase indicators
        updatePhaseIndicators();
        
        // Tooltip setup
        const tooltip = d3.select('#tooltip');
        
        // Event listeners
        playPauseBtn.addEventListener('click', togglePlayPause);
        nextStepBtn.addEventListener('click', nextStep);
        prevStepBtn.addEventListener('click', prevStep);
        resetBtn.addEventListener('click', resetAnimation);
        speedSlider.addEventListener('input', updateSpeed);
        
        // Initialize visualizations
        initializeDataVisualization();
        initializeProcessingVisualization();
        initializeTrainingVisualization();
        initializeForecastingVisualization();
        
        // Update speed function
        function updateSpeed() {
            config.animationSpeed = parseFloat(speedSlider.value);
            speedValue.textContent = `${config.animationSpeed}x`;
        }
        
        // Toggle play/pause
        function togglePlayPause() {
            config.isPlaying = !config.isPlaying;
            
            if (config.isPlaying) {
                playPauseBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                    Pause
                `;
                playAnimation();
            } else {
                playPauseBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    Play
                `;
                clearTimeout(config.animationTimeline);
            }
        }
        
        // Play animation
        function playAnimation() {
            if (!config.isPlaying) return;
            
            if (config.currentStep < config.totalSteps - 1) {
                config.animationTimeline = setTimeout(() => {
                    nextStep();
                    playAnimation();
                }, config.stepDelay / config.animationSpeed);
            } else {
                config.isPlaying = false;
                playPauseBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    Play
                `;
            }
        }
        
        // Next step
        function nextStep() {
            if (config.currentStep < config.totalSteps - 1) {
                config.currentStep++;
                updateStep();
            }
        }
        
        // Previous step
        function prevStep() {
            if (config.currentStep > 0) {
                config.currentStep--;
                updateStep();
            }
        }
        
        // Go to specific step
        function goToStep(stepIndex) {
            config.currentStep = stepIndex;
            updateStep();
        }
        
        // Update current step
        function updateStep() {
            // Update step indicators
            document.querySelectorAll('.step-dot').forEach((dot, index) => {
                if (index === config.currentStep) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
            
            // Update explanation
            currentStepDisplay.textContent = stepDescriptions[config.currentStep];
            
            // Determine current phase
            determineCurrentPhase();
            
            // Update phase indicators
            updatePhaseIndicators();
            
            // Update active section
            updateActiveSection();
            
            // Trigger step-specific animations
            animateCurrentStep();
        }
        
        // Reset animation
        function resetAnimation() {
            clearTimeout(config.animationTimeline);
            config.isPlaying = false;
            config.currentStep = 0;
            
            playPauseBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                Play
            `;
            
            updateStep();
            
            // Reset all visualizations
            resetDataVisualization();
            resetProcessingVisualization();
            resetTrainingVisualization();
            resetForecastingVisualization();
        }
        
        // Determine current phase based on step
        function determineCurrentPhase() {
            if (config.currentStep < 4) {
                config.currentPhase = 'data';
            } else if (config.currentStep < 10) {
                config.currentPhase = 'processing';
            } else if (config.currentStep < 17) {
                config.currentPhase = 'training';
            } else {
                config.currentPhase = 'forecasting';
            }
        }
        
        // Update phase indicators
        function updatePhaseIndicators() {
            // Reset all phases
            phaseData.classList.remove('active', 'completed');
            phaseProcessing.classList.remove('active', 'completed');
            phaseTraining.classList.remove('active', 'completed');
            phaseForecasting.classList.remove('active', 'completed');
            
            // Update based on current phase
            switch (config.currentPhase) {
                case 'data':
                    phaseData.classList.add('active');
                    break;
                case 'processing':
                    phaseData.classList.add('completed');
                    phaseProcessing.classList.add('active');
                    break;
                case 'training':
                    phaseData.classList.add('completed');
                    phaseProcessing.classList.add('completed');
                    phaseTraining.classList.add('active');
                    break;
                case 'forecasting':
                    phaseData.classList.add('completed');
                    phaseProcessing.classList.add('completed');
                    phaseTraining.classList.add('completed');
                    phaseForecasting.classList.add('active');
                    break;
            }
        }
        
        // Update active section
        function updateActiveSection() {
            // Hide all sections
            sectionDataIngestion.classList.remove('active');
            sectionDataProcessing.classList.remove('active');
            sectionTraining.classList.remove('active');
            sectionForecasting.classList.remove('active');
            
            // Show current section
            switch (config.currentPhase) {
                case 'data':
                    sectionDataIngestion.classList.add('active');
                    break;
                case 'processing':
                    sectionDataProcessing.classList.add('active');
                    break;
                case 'training':
                    sectionTraining.classList.add('active');
                    break;
                case 'forecasting':
                    sectionForecasting.classList.add('active');
                    break;
            }
        }
        
        // Format date for display
        const formatDate = d3.timeFormat("%b %d, %Y");
        
        // Trigger step-specific animations
        function animateCurrentStep() {
            // Define step-specific animations based on current step
            switch (config.currentStep) {
                // Data Ingestion Phase animations
                case 0:
                    animateDataStep0();
                    break;
                case 1:
                    animateDataStep1();
                    break;
                case 2:
                    animateDataStep2();
                    break;
                case 3:
                    animateDataStep3();
                    break;
                    
                // Data Processing Phase animations
                case 4:
                    animateProcessingStep0();
                    break;
                case 5:
                    animateProcessingStep1();
                    break;
                case 6:
                    animateProcessingStep2();
                    break;
                case 7:
                    animateProcessingStep3();
                    break;
                case 8:
                    animateProcessingStep4();
                    break;
                case 9:
                    animateProcessingStep5();
                    break;
                    
                // Training Phase animations
                case 10:
                    animateTrainingStep0();
                    break;
                case 11:
                    animateTrainingStep1();
                    break;
                case 12:
                    animateTrainingStep2();
                    break;
                case 13:
                    animateTrainingStep3();
                    break;
                case 14:
                    animateTrainingStep4();
                    break;
                case 15:
                    animateTrainingStep5();
                    break;
                case 16:
                    animateTrainingStep6();
                    break;
                    
                // Forecasting Phase animations
                case 17:
                    animateForecastingStep0();
                    break;
                case 18:
                    animateForecastingStep1();
                    break;
                case 19:
                    animateForecastingStep2();
                    break;
                case 20:
                    animateForecastingStep3();
                    break;
                case 21:
                    animateForecastingStep4();
                    break;
            }
        }
        
        // Initialize data visualization
        function initializeDataVisualization() {
            const margin = {top: 50, right: 50, bottom: 50, left: 60};
            const width = config.width - margin.left - margin.right;
            const height = config.height - margin.top - margin.bottom;
            
            // Create group for the visualization
            const g = dataVisSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`)
                .attr('id', 'data-vis-group');
            
            // Create scales
            const xScale = d3.scaleTime()
                .domain(d3.extent(timeSeriesData, d => d.date))
                .range([0, width]);
                
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(timeSeriesData, d => d.value) * 1.2])
                .range([height, 0]);
            
            // Add x and y axes
            g.append('g')
                .attr('class', 'x-axis axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale));
                
            g.append('g')
                .attr('class', 'y-axis axis')
                .call(d3.axisLeft(yScale));
            
            // Add grid lines
            g.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''));
                    
            g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''));
            
            // Add axis labels
            g.append('text')
                .attr('class', 'x-label')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + 35)
                .text('Date');
                
            g.append('text')
                .attr('class', 'y-label')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -40)
                .text('Value');
                
            // Create line generator
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);
            
            // Add time series line (initially hidden)
            g.append('path')
                .datum(timeSeriesData)
                .attr('class', 'line data')
                .attr('d', line)
                .attr('opacity', 0);
                
            // Add holiday markers
            g.selectAll('.holiday-marker')
                .data(timeSeriesData.filter(d => d.isHoliday))
                .enter()
                .append('circle')
                .attr('class', 'holiday-marker')
                .attr('cx', d => xScale(d.date))
                .attr('cy', d => yScale(d.value))
                .attr('r', 5)
                .attr('fill', 'var(--holidays-color)')
                .attr('opacity', 0)
                .attr('stroke', 'white')
                .attr('stroke-width', 1)
                .on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .html(`Date: ${formatDate(d.date)}<br>Value: ${d.value}<br>Holiday`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 20) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
                
            // Add data table container
            g.append('foreignObject')
                .attr('id', 'data-table-container')
                .attr('x', width / 2 - 200)
                .attr('y', height / 2 - 150)
                .attr('width', 400)
                .attr('height', 300)
                .attr('opacity', 0);
        }
        
        // Data visualization step animations
        function animateDataStep0() {
            // Introduction - no data yet
            dataVisSvg.select('.line.data')
                .transition()
                .duration(500)
                .attr('opacity', 0);
                
            dataVisSvg.selectAll('.holiday-marker')
                .transition()
                .duration(500)
                .attr('opacity', 0);
                
            dataVisSvg.select('#data-table-container')
                .transition()
                .duration(500)
                .attr('opacity', 0);
        }
        
        function animateDataStep1() {
            // Show time series line
            dataVisSvg.select('.line.data')
                .transition()
                .duration(1000)
                .attr('opacity', 1);
                
            dataVisSvg.selectAll('.holiday-marker')
                .transition()
                .duration(1000)
                .delay((d, i) => i * 100)
                .attr('opacity', 0.8);
                
            dataVisSvg.select('#data-table-container')
                .transition()
                .duration(500)
                .attr('opacity', 0);
        }
        
        function animateDataStep2() {
            // Show data table
            dataVisSvg.select('#data-table-container')
                .html(`
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Value</th>
                                <th>Holiday</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${timeSeriesData.slice(0, 7).map(d => `
                                <tr>
                                    <td>${formatDate(d.date)}</td>
                                    <td>${d.value}</td>
                                    <td>${d.isHoliday ? 'Yes' : 'No'}</td>
                                </tr>
                            `).join('')}
                            <tr>
                                <td colspan="3">... (${timeSeriesData.length - 7} more rows)</td>
                            </tr>
                        </tbody>
                    </table>
                `)
                .transition()
                .duration(1000)
                .attr('opacity', 1);
        }
        
        function animateDataStep3() {
            // Show data preprocessing
            dataVisSvg.select('#data-table-container')
                .transition()
                .duration(500)
                .attr('opacity', 0);
                
            // Add data processing annotation
            const g = dataVisSvg.select('#data-vis-group');
            
            const processing = g.append('g')
                .attr('id', 'data-processing-annotation')
                .attr('transform', 'translate(250, 100)')
                .attr('opacity', 0);
                
            processing.append('rect')
                .attr('width', 300)
                .attr('height', 150)
                .attr('rx', 5)
                .attr('ry', 5)
                .attr('fill', 'white')
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2);
                
            processing.append('text')
                .attr('x', 150)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text('Data Preprocessing');
                
            processing.append('text')
                .attr('x', 20)
                .attr('y', 60)
                .text(' Normalization');
                
            processing.append('text')
                .attr('x', 20)
                .attr('y', 85)
                .text(' Handling missing values');
                
            processing.append('text')
                .attr('x', 20)
                .attr('y', 110)
                .text(' Feature engineering');
                
            processing.append('text')
                .attr('x', 20)
                .attr('y', 135)
                .text(' Data scaling for neural network');
                
            // Animate data processing
            processing.transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Add arrow to next phase
            const arrow = g.append('g')
                .attr('id', 'next-phase-arrow')
                .attr('opacity', 0);
                
            arrow.append('path')
                .attr('d', `M450,175 C500,175 500,175 550,175`)
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2)
                .attr('fill', 'none')
                .attr('marker-end', 'url(#arrow-marker)');
                
            dataVisSvg.append('defs')
                .append('marker')
                .attr('id', 'arrow-marker')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', 'var(--primary)');
                
            arrow.transition()
                .delay(800)
                .duration(800)
                .attr('opacity', 1);
        }
        
        // Reset data visualization
        function resetDataVisualization() {
            dataVisSvg.select('.line.data')
                .attr('opacity', 0);
                
            dataVisSvg.selectAll('.holiday-marker')
                .attr('opacity', 0);
                
            dataVisSvg.select('#data-table-container')
                .attr('opacity', 0);
                
            dataVisSvg.selectAll('#data-processing-annotation, #next-phase-arrow')
                .remove();
        }
        
        // Initialize processing visualization
        function initializeProcessingVisualization() {
            const margin = {top: 30, right: 30, bottom: 30, left: 60};
            const width = config.width - margin.left - margin.right;
            const height = (config.height - margin.top - margin.bottom) / 2 - 20;
            
            // Create group for the visualization
            const g = processingVisSvg.append('g')
                .attr('id', 'processing-vis-group');
                
            // Create scales
            const xScale = d3.scaleTime()
                .domain(d3.extent(timeSeriesData, d => d.date))
                .range([0, width]);
                
            const yScaleMain = d3.scaleLinear()
                .domain([0, d3.max(timeSeriesData, d => d.value) * 1.2])
                .range([height, 0]);
                
            const yScaleComp = d3.scaleLinear()
                .domain([-50, 50])
                .range([height, 0]);
            
            // Original data chart
            const chartOriginal = g.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`)
                .attr('class', 'chart-original')
                .attr('opacity', 0);
                
            // Add x and y axes for original data
            chartOriginal.append('g')
                .attr('class', 'x-axis axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(5));
                
            chartOriginal.append('g')
                .attr('class', 'y-axis axis')
                .call(d3.axisLeft(yScaleMain));
                
            // Add title
            chartOriginal.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text('Original Time Series');
                
            // Add line for original data
            const lineOriginal = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScaleMain(d.value))
                .curve(d3.curveMonotoneX);
                
            chartOriginal.append('path')
                .datum(timeSeriesData)
                .attr('class', 'line data')
                .attr('d', lineOriginal);
                
            // Components charts container
            const componentsGroup = g.append('g')
                .attr('transform', `translate(0,${height + margin.top + margin.bottom})`)
                .attr('class', 'components-group');
                
            // Create individual components charts
            createComponentChart('trend', componentsGroup, margin, width, height, xScale, yScaleComp, trendData);
            createComponentChart('seasonality', componentsGroup, margin, width, height, xScale, yScaleComp, seasonalityData);
            createComponentChart('holidays', componentsGroup, margin, width, height, xScale, yScaleComp, holidaysData);
            createComponentChart('ar', componentsGroup, margin, width, height, xScale, yScaleComp, arData);
            
            // Hide all component charts initially
            processingVisSvg.selectAll('.component-chart')
                .attr('opacity', 0);
                
            // Add legend
            const legend = g.append('g')
                .attr('class', 'decomposition-legend')
                .attr('transform', `translate(${margin.left},${margin.top + height + 60})`)
                .attr('opacity', 0);
                
            const components = [
                {name: 'Original Data', color: 'var(--primary)'},
                {name: 'Trend', color: 'var(--trend-color)'},
                {name: 'Seasonality', color: 'var(--seasonality-color)'},
                {name: 'Holidays', color: 'var(--holidays-color)'},
                {name: 'AR Component', color: 'var(--ar-color)'}
            ];
            
            components.forEach((comp, i) => {
                const legendItem = legend.append('g')
                    .attr('transform', `translate(${i * 150}, 0)`);
                    
                legendItem.append('line')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', 20)
                    .attr('y2', 0)
                    .attr('stroke', comp.color)
                    .attr('stroke-width', 2);
                    
                legendItem.append('text')
                    .attr('x', 25)
                    .attr('y', 4)
                    .text(comp.name)
                    .attr('font-size', '0.8em');
            });
            
            // Create combined chart
            const combinedChart = g.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`)
                .attr('class', 'chart-combined')
                .attr('opacity', 0);
                
            // Add x and y axes for combined chart
            combinedChart.append('g')
                .attr('class', 'x-axis axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(5));
                
            combinedChart.append('g')
                .attr('class', 'y-axis axis')
                .call(d3.axisLeft(yScaleMain));
                
            // Add title
            combinedChart.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text('Combined Components');
                
            // Add lines for each component on combined chart
            const lineTrend = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScaleMain(d.value))
                .curve(d3.curveMonotoneX);
                
            combinedChart.append('path')
                .datum(trendData)
                .attr('class', 'line trend')
                .attr('d', lineTrend)
                .attr('opacity', 0);
                
            combinedChart.append('path')
                .datum(timeSeriesData)
                .attr('class', 'line data')
                .attr('d', lineOriginal)
                .attr('opacity', 0.4);
        }
        
        // Helper function to create a component chart
        function createComponentChart(type, parent, margin, width, height, xScale, yScale, data) {
            const chart = parent.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`)
                .attr('class', `component-chart ${type}-chart`);
                
            // Add x and y axes
            chart.append('g')
                .attr('class', 'x-axis axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(5));
                
            chart.append('g')
                .attr('class', 'y-axis axis')
                .call(d3.axisLeft(yScale));
                
            // Add title
            chart.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text(() => {
                    switch(type) {
                        case 'trend': return 'Trend Component';
                        case 'seasonality': return 'Seasonality Component';
                        case 'holidays': return 'Holiday Effects';
                        case 'ar': return 'Autoregressive Component';
                        default: return '';
                    }
                });
                
            // Add line
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);
                
            chart.append('path')
                .datum(data)
                .attr('class', `line ${type}`)
                .attr('d', line);
                
            // For holidays, add markers
            if (type === 'holidays') {
                chart.selectAll('.holiday-marker')
                    .data(data.filter(d => d.isHoliday))
                    .enter()
                    .append('circle')
                    .attr('class', 'holiday-marker')
                    .attr('cx', d => xScale(d.date))
                    .attr('cy', d => yScale(d.value))
                    .attr('r', 4)
                    .attr('fill', 'var(--holidays-color)')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
            }
            
            return chart;
        }
        
        // Processing visualization step animations
        function animateProcessingStep0() {
            // Introduction to decomposition
            processingVisSvg.select('.chart-original')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            processingVisSvg.selectAll('.component-chart')
                .attr('opacity', 0);
                
            processingVisSvg.select('.decomposition-legend')
                .attr('opacity', 0);
                
            processingVisSvg.select('.chart-combined')
                .attr('opacity', 0);
        }
        
        function animateProcessingStep1() {
            // Show trend component
            processingVisSvg.select('.trend-chart')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            processingVisSvg.select('.decomposition-legend')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            processingVisSvg.selectAll('.seasonality-chart, .holidays-chart, .ar-chart')
                .attr('opacity', 0);
        }
        
        function animateProcessingStep2() {
            // Show seasonality component
            processingVisSvg.select('.seasonality-chart')
                .transition()
                .duration(800)
                .attr('opacity', 1);
        }
        
        function animateProcessingStep3() {
            // Show holidays component
            processingVisSvg.select('.holidays-chart')
                .transition()
                .duration(800)
                .attr('opacity', 1);
        }
        
        function animateProcessingStep4() {
            // Show AR component
            processingVisSvg.select('.ar-chart')
                .transition()
                .duration(800)
                .attr('opacity', 1);
        }
        
        function animateProcessingStep5() {
            // Show combined view
            processingVisSvg.select('.chart-original')
                .transition()
                .duration(500)
                .attr('opacity', 0);
                
            processingVisSvg.selectAll('.component-chart')
                .transition()
                .duration(500)
                .attr('opacity', 0);
                
            processingVisSvg.select('.chart-combined')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Animate showing each component on combined chart
            const combinedChart = processingVisSvg.select('.chart-combined');
            
            combinedChart.select('.line.trend')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Add other components to combined chart
            const margin = {top: 30, right: 30, bottom: 30, left: 60};
            const width = config.width - margin.left - margin.right;
            const height = (config.height - margin.top - margin.bottom) / 2 - 20;
            
            const xScale = d3.scaleTime()
                .domain(d3.extent(timeSeriesData, d => d.date))
                .range([0, width]);
                
            const yScaleMain = d3.scaleLinear()
                .domain([0, d3.max(timeSeriesData, d => d.value) * 1.2])
                .range([height, 0]);
                
            // Add arrow to next phase
            const g = processingVisSvg.select('#processing-vis-group');
            
            const arrow = g.append('g')
                .attr('id', 'next-phase-arrow-processing')
                .attr('transform', `translate(${margin.left},${margin.top + height + 180})`)
                .attr('opacity', 0);
                
            arrow.append('text')
                .attr('x', width / 2)
                .attr('y', 0)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text('Components are passed to Neural Network');
                
            arrow.append('path')
                .attr('d', `M${width/2},10 L${width/2},50`)
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2)
                .attr('fill', 'none')
                .attr('marker-end', 'url(#arrow-marker-processing)');
                
            processingVisSvg.append('defs')
                .append('marker')
                .attr('id', 'arrow-marker-processing')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', 'var(--primary)');
                
            arrow.transition()
                .delay(800)
                .duration(800)
                .attr('opacity', 1);
        }
        
        // Reset processing visualization
        function resetProcessingVisualization() {
            processingVisSvg.select('.chart-original')
                .attr('opacity', 0);
                
            processingVisSvg.selectAll('.component-chart')
                .attr('opacity', 0);
                
            processingVisSvg.select('.decomposition-legend')
                .attr('opacity', 0);
                
            processingVisSvg.select('.chart-combined')
                .attr('opacity', 0);
                
            processingVisSvg.select('#next-phase-arrow-processing')
                .remove();
        }
        
        // Initialize training visualization
        function initializeTrainingVisualization() {
            const g = trainingVisSvg.append('g')
                .attr('id', 'training-vis-group');
                
            // Create neural network visualization
            const networkWidth = 600;
            const networkHeight = 300;
            const networkX = (config.width - networkWidth) / 2;
            const networkY = 50;
            
            const network = g.append('g')
                .attr('class', 'neural-network')
                .attr('transform', `translate(${networkX},${networkY})`)
                .attr('opacity', 0);
                
            // Define layer structure
            const layers = [
                {name: 'Inputs', neurons: 4, x: 0},
                {name: 'Hidden 1', neurons: 8, x: networkWidth / 4},
                {name: 'Hidden 2', neurons: 6, x: networkWidth / 2},
                {name: 'Output', neurons: 1, x: networkWidth * 3 / 4}
            ];
            
            // Draw component boxes on left
            const componentBoxHeight = networkHeight / 5;
            const components = [
                {name: 'Trend', color: 'var(--trend-color)'},
                {name: 'Seasonality', color: 'var(--seasonality-color)'},
                {name: 'Holidays', color: 'var(--holidays-color)'},
                {name: 'AR', color: 'var(--ar-color)'}
            ];
            
            components.forEach((comp, i) => {
                network.append('rect')
                    .attr('x', -120)
                    .attr('y', i * componentBoxHeight + 10)
                    .attr('width', 100)
                    .attr('height', componentBoxHeight - 10)
                    .attr('class', 'component-box')
                    .attr('stroke', comp.color);
                    
                network.append('text')
                    .attr('x', -70)
                    .attr('y', i * componentBoxHeight + componentBoxHeight / 2 + 5)
                    .attr('class', 'component-label')
                    .text(comp.name);
            });
            
            // Draw forecast box on right
            network.append('rect')
                .attr('x', networkWidth + 20)
                .attr('y', networkHeight / 2 - componentBoxHeight / 2)
                .attr('width', 100)
                .attr('height', componentBoxHeight)
                .attr('class', 'component-box')
                .attr('stroke', 'var(--forecast-color)');
                
            network.append('text')
                .attr('x', networkWidth + 70)
                .attr('y', networkHeight / 2 + 5)
                .attr('class', 'component-label')
                .text('Forecast');
            
            // Draw connections from components to input layer
            components.forEach((comp, i) => {
                network.append('line')
                    .attr('x1', -20)
                    .attr('y1', i * componentBoxHeight + componentBoxHeight / 2 + 5)
                    .attr('x2', 0)
                    .attr('y2', i * (networkHeight / (layers[0].neurons - 1)) + 10)
                    .attr('class', 'neuron-connection')
                    .attr('id', `comp-input-${i}`);
            });
            
            // Draw connections from output to forecast
            network.append('line')
                .attr('x1', networkWidth * 3 / 4 + 20)
                .attr('y1', networkHeight / 2 + 5)
                .attr('x2', networkWidth + 20)
                .attr('y2', networkHeight / 2 + 5)
                .attr('class', 'neuron-connection')
                .attr('id', 'output-forecast');
            
            // Draw layers
            layers.forEach(layer => {
                // Add layer label
                network.append('text')
                    .attr('x', layer.x + 10)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-weight', 'bold')
                    .attr('font-size', '12px')
                    .text(layer.name);
                    
                // Add neurons
                for (let i = 0; i < layer.neurons; i++) {
                    network.append('circle')
                        .attr('cx', layer.x + 10)
                        .attr('cy', i * (networkHeight / (layer.neurons - 1)) + 10)
                        .attr('r', 10)
                        .attr('class', 'neuron')
                        .attr('id', `${layer.name.toLowerCase()}-${i}`);
                }
                
                // Add connections to next layer
                if (layer.name !== 'Output') {
                    const nextLayer = layers[layers.indexOf(layer) + 1];
                    for (let i = 0; i < layer.neurons; i++) {
                        for (let j = 0; j < nextLayer.neurons; j++) {
                            network.append('line')
                                .attr('x1', layer.x + 20)
                                .attr('y1', i * (networkHeight / (layer.neurons - 1)) + 10)
                                .attr('x2', nextLayer.x)
                                .attr('y2', j * (networkHeight / (nextLayer.neurons - 1)) + 10)
                                .attr('class', 'neuron-connection')
                                .attr('id', `${layer.name.toLowerCase()}-${i}-to-${nextLayer.name.toLowerCase()}-${j}`);
                        }
                    }
                }
            });
            
            // Add loss visualization
            const lossChartWidth = 400;
            const lossChartHeight = 150;
            const lossChartX = (config.width - lossChartWidth) / 2;
            const lossChartY = networkY + networkHeight + 50;
            
            const lossChart = g.append('g')
                .attr('class', 'loss-chart')
                .attr('transform', `translate(${lossChartX},${lossChartY})`)
                .attr('opacity', 0);
                
            // Create scales for loss chart
            const xScaleLoss = d3.scaleLinear()
                .domain([0, d3.max(lossData, d => d.epoch)])
                .range([0, lossChartWidth - 60]);
                
            const yScaleLoss = d3.scaleLinear()
                .domain([0, d3.max(lossData, d => d.loss) * 1.2])
                .range([lossChartHeight - 40, 0]);
                
            // Add axes
            lossChart.append('g')
                .attr('transform', `translate(40,${lossChartHeight - 40})`)
                .call(d3.axisBottom(xScaleLoss));
                
            lossChart.append('g')
                .attr('transform', 'translate(40,0)')
                .call(d3.axisLeft(yScaleLoss));
                
            // Add axis labels
            lossChart.append('text')
                .attr('x', lossChartWidth / 2)
                .attr('y', lossChartHeight - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .text('Epoch');
                
            lossChart.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -lossChartHeight / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .text('Loss');
                
            // Add title
            lossChart.append('text')
                .attr('x', lossChartWidth / 2)
                .attr('y', -5)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text('Training Loss');
                
            // Add loss line
            const lossLine = d3.line()
                .x(d => xScaleLoss(d.epoch) + 40)
                .y(d => yScaleLoss(d.loss))
                .curve(d3.curveMonotoneX);
                
            lossChart.append('path')
                .datum([])
                .attr('class', 'line data')
                .attr('d', lossLine);
                
            // Add epoch indicator
            lossChart.append('circle')
                .attr('class', 'epoch-indicator')
                .attr('cx', xScaleLoss(1) + 40)
                .attr('cy', yScaleLoss(lossData[0].loss))
                .attr('r', 5)
                .attr('opacity', 0);
                
            // Add current epoch/loss display
            lossChart.append('text')
                .attr('class', 'epoch-display')
                .attr('x', lossChartWidth - 20)
                .attr('y', 20)
                .attr('text-anchor', 'end')
                .text('');
                
            // Add forward/backward pass annotation
            const forwardBackwardG = g.append('g')
                .attr('id', 'forward-backward')
                .attr('transform', `translate(${networkX},${networkY - 30})`)
                .attr('opacity', 0);
                
            forwardBackwardG.append('text')
                .attr('x', 10)
                .attr('y', 0)
                .attr('font-weight', 'bold')
                .attr('fill', 'var(--primary)')
                .text('Forward Pass ');
                
            forwardBackwardG.append('text')
                .attr('x', networkWidth - 10)
                .attr('y', 0)
                .attr('text-anchor', 'end')
                .attr('font-weight', 'bold')
                .attr('fill', 'var(--error)')
                .text(' Backward Pass');
                
            // Add data flow annotation
            const dataFlowG = g.append('g')
                .attr('id', 'data-flow-annotation')
                .attr('transform', `translate(${lossChartX},${lossChartY + lossChartHeight + 20})`)
                .attr('opacity', 0);
                
            dataFlowG.append('text')
                .attr('x', lossChartWidth / 2)
                .attr('y', 0)
                .attr('text-anchor', 'middle')
                .text('Optimize model parameters to minimize loss');
        }
        
        // Training visualization step animations
        function animateTrainingStep0() {
            // Introduce neural network
            trainingVisSvg.select('.neural-network')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            trainingVisSvg.select('.loss-chart')
                .attr('opacity', 0);
                
            trainingVisSvg.select('#forward-backward')
                .attr('opacity', 0);
                
            trainingVisSvg.select('#data-flow-annotation')
                .attr('opacity', 0);
        }
        
        function animateTrainingStep1() {
            // Explain NeuralProphet architecture
            trainingVisSvg.select('.neural-network')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Highlight component connections
            trainingVisSvg.selectAll('#comp-input-0, #comp-input-1, #comp-input-2, #comp-input-3')
                .transition()
                .duration(800)
                .attr('stroke', d => {
                    const id = d3.select(this).attr('id');
                    if (id === 'comp-input-0') return 'var(--trend-color)';
                    if (id === 'comp-input-1') return 'var(--seasonality-color)';
                    if (id === 'comp-input-2') return 'var(--holidays-color)';
                    if (id === 'comp-input-3') return 'var(--ar-color)';
                    return '#ccc';
                })
                .attr('stroke-width', 2.5);
        }
        
        function animateTrainingStep2() {
            // Show forward pass
            trainingVisSvg.select('#forward-backward')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Animate activation flowing through network
            animateForwardPass();
        }
        
        function animateTrainingStep3() {
            // Show loss computation
            trainingVisSvg.select('.loss-chart')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Show first few epochs of loss
            updateLossChart(10);
        }
        
        function animateTrainingStep4() {
            // Show backpropagation
            trainingVisSvg.select('#data-flow-annotation')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Animate backwards
            animateBackwardPass();
        }
        
        function animateTrainingStep5() {
            // Show continued training
            updateLossChart(30);
        }
        
        function animateTrainingStep6() {
            // Show final trained model
            updateLossChart(lossData.length);
            
            // Mark completion
            trainingVisSvg.select('.neural-network')
                .selectAll('.neuron')
                .transition()
                .duration(500)
                .attr('fill', 'white')
                .transition()
                .duration(500)
                .attr('fill', 'var(--accent)')
                .transition()
                .duration(500)
                .attr('fill', 'white');
        }
        
        // Helper functions for training animations
        function animateForwardPass() {
            // Animate activation flowing through neurons
            const network = trainingVisSvg.select('.neural-network');
            
            // Input layer activation
            network.selectAll('[id^="inputs-"]')
                .transition()
                .duration(500)
                .attr('fill', 'var(--accent)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // First hidden layer connections
            network.selectAll('[id^="inputs-"][id$="-to-hidden-"]')
                .transition()
                .delay(500)
                .duration(500)
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2);
                
            // First hidden layer activation
            network.selectAll('[id^="hidden-1-"]')
                .transition()
                .delay(1000)
                .duration(500)
                .attr('fill', 'var(--accent)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Second hidden layer connections
            network.selectAll('[id^="hidden-1-"][id$="-to-hidden-"]')
                .transition()
                .delay(1500)
                .duration(500)
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2);
                
            // Second hidden layer activation
            network.selectAll('[id^="hidden-2-"]')
                .transition()
                .delay(2000)
                .duration(500)
                .attr('fill', 'var(--accent)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Output layer connections
            network.selectAll('[id^="hidden-2-"][id$="-to-output-"]')
                .transition()
                .delay(2500)
                .duration(500)
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2);
                
            // Output layer activation
            network.selectAll('[id^="output-"]')
                .transition()
                .delay(3000)
                .duration(500)
                .attr('fill', 'var(--accent)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Output to forecast connection
            network.select('#output-forecast')
                .transition()
                .delay(3500)
                .duration(500)
                .attr('stroke', 'var(--forecast-color)')
                .attr('stroke-width', 2);
                
            // Reset connections
            setTimeout(() => {
                network.selectAll('.neuron-connection')
                    .transition()
                    .duration(1000)
                    .attr('stroke', '#ccc')
                    .attr('stroke-width', 1.5);
            }, 5000);
        }
        
        function animateBackwardPass() {
            // Animate gradient flowing backwards through neurons
            const network = trainingVisSvg.select('.neural-network');
            
            // Output layer error
            network.selectAll('[id^="output-"]')
                .transition()
                .duration(500)
                .attr('fill', 'var(--error)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Output to hidden layer connections
            network.selectAll('[id^="hidden-2-"][id$="-to-output-"]')
                .transition()
                .delay(500)
                .duration(500)
                .attr('stroke', 'var(--error)')
                .attr('stroke-width', 2);
                
            // Hidden layer 2 error
            network.selectAll('[id^="hidden-2-"]')
                .transition()
                .delay(1000)
                .duration(500)
                .attr('fill', 'var(--error)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Hidden layer 2 to hidden layer 1 connections
            network.selectAll('[id^="hidden-1-"][id$="-to-hidden-"]')
                .transition()
                .delay(1500)
                .duration(500)
                .attr('stroke', 'var(--error)')
                .attr('stroke-width', 2);
                
            // Hidden layer 1 error
            network.selectAll('[id^="hidden-1-"]')
                .transition()
                .delay(2000)
                .duration(500)
                .attr('fill', 'var(--error)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Hidden layer 1 to input layer connections
            network.selectAll('[id^="inputs-"][id$="-to-hidden-"]')
                .transition()
                .delay(2500)
                .duration(500)
                .attr('stroke', 'var(--error)')
                .attr('stroke-width', 2);
                
            // Input layer error
            network.selectAll('[id^="inputs-"]')
                .transition()
                .delay(3000)
                .duration(500)
                .attr('fill', 'var(--error)')
                .transition()
                .delay(400)
                .duration(500)
                .attr('fill', 'white');
                
            // Reset connections
            setTimeout(() => {
                network.selectAll('.neuron-connection')
                    .transition()
                    .duration(1000)
                    .attr('stroke', '#ccc')
                    .attr('stroke-width', 1.5);
            }, 4000);
        }
        
        function updateLossChart(epochsToShow) {
            const lossChart = trainingVisSvg.select('.loss-chart');
            
            // Update line with data up to the specified epoch
            const lossLine = d3.line()
                .x(d => {
                    const xScaleLoss = d3.scaleLinear()
                        .domain([0, d3.max(lossData, d => d.epoch)])
                        .range([0, 400 - 60]);
                    return xScaleLoss(d.epoch) + 40;
                })
                .y(d => {
                    const yScaleLoss = d3.scaleLinear()
                        .domain([0, d3.max(lossData, d => d.loss) * 1.2])
                        .range([150 - 40, 0]);
                    return yScaleLoss(d.loss);
                })
                .curve(d3.curveMonotoneX);
                
            lossChart.select('path')
                .datum(lossData.slice(0, epochsToShow))
                .transition()
                .duration(1000)
                .attr('d', lossLine);
                
            // Update epoch indicator
            const xScaleLoss = d3.scaleLinear()
                .domain([0, d3.max(lossData, d => d.epoch)])
                .range([0, 400 - 60]);
                
            const yScaleLoss = d3.scaleLinear()
                .domain([0, d3.max(lossData, d => d.loss) * 1.2])
                .range([150 - 40, 0]);
                
            lossChart.select('.epoch-indicator')
                .transition()
                .duration(1000)
                .attr('cx', xScaleLoss(epochsToShow) + 40)
                .attr('cy', yScaleLoss(lossData[epochsToShow - 1].loss))
                .attr('opacity', 1);
                
            // Update epoch display
            lossChart.select('.epoch-display')
                .text(`Epoch: ${epochsToShow} | Loss: ${lossData[epochsToShow - 1].loss.toFixed(3)}`);
        }
        
        // Reset training visualization
        function resetTrainingVisualization() {
            trainingVisSvg.select('.neural-network')
                .attr('opacity', 0);
                
            trainingVisSvg.select('.loss-chart')
                .attr('opacity', 0);
                
            trainingVisSvg.select('#forward-backward')
                .attr('opacity', 0);
                
            trainingVisSvg.select('#data-flow-annotation')
                .attr('opacity', 0);
                
            // Reset loss chart
            trainingVisSvg.select('.loss-chart path')
                .datum([])
                .attr('d', '');
                
            trainingVisSvg.select('.epoch-indicator')
                .attr('opacity', 0);
                
            trainingVisSvg.select('.epoch-display')
                .text('');
                
            // Reset network state
            trainingVisSvg.selectAll('.neuron')
                .attr('fill', 'white');
                
            trainingVisSvg.selectAll('.neuron-connection')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1.5);
        }
        
        // Initialize forecasting visualization
        function initializeForecastingVisualization() {
            const margin = {top: 50, right: 90, bottom: 50, left: 60};
            const width = config.width - margin.left - margin.right;
            const height = config.height - margin.top - margin.bottom;
            
            // Create group for the visualization
            const g = forecastingVisSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`)
                .attr('id', 'forecasting-vis-group');
            
            // Create scales
            const xScale = d3.scaleTime()
                .domain([
                    d3.min(timeSeriesData, d => d.date),
                    d3.max(forecastData, d => d.date)
                ])
                .range([0, width]);
                
            const yScale = d3.scaleLinear()
                .domain([
                    0,
                    d3.max([
                        ...timeSeriesData.map(d => d.value),
                        ...forecastData.map(d => d.upper)
                    ]) * 1.1
                ])
                .range([height, 0]);
            
            // Add x and y axes
            g.append('g')
                .attr('class', 'x-axis axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale));
                
            g.append('g')
                .attr('class', 'y-axis axis')
                .call(d3.axisLeft(yScale));
            
            // Add grid lines
            g.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''));
                    
            g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''));
            
            // Add axis labels
            g.append('text')
                .attr('class', 'x-label')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + 35)
                .text('Date');
                
            g.append('text')
                .attr('class', 'y-label')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -40)
                .text('Value');
                
            // Add title
            g.append('text')
                .attr('class', 'chart-title')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', -20)
                .attr('font-weight', 'bold')
                .text('NeuralProphet Forecast');
            
            // Create line generators
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);
                
            // Add historical data line (initially visible)
            g.append('path')
                .datum(timeSeriesData)
                .attr('class', 'line data')
                .attr('d', line);
                
            // Add trend line (initially hidden)
            g.append('path')
                .datum(trendData)
                .attr('class', 'line trend')
                .attr('d', line)
                .attr('opacity', 0);
                
            // Add seasonality line (initially hidden)
            g.append('path')
                .datum(seasonalityData.map(d => ({
                    date: d.date,
                    value: d.value + trendData.find(td => td.date.getTime() === d.date.getTime()).value
                })))
                .attr('class', 'line seasonality')
                .attr('d', line)
                .attr('opacity', 0);
            
            // Add forecast line (initially hidden)
            g.append('path')
                .datum(forecastData)
                .attr('class', 'line forecast')
                .attr('d', line)
                .attr('opacity', 0);
                
            // Add forecast area (uncertainty interval)
            const area = d3.area()
                .x(d => xScale(d.date))
                .y0(d => yScale(d.lower))
                .y1(d => yScale(d.upper))
                .curve(d3.curveMonotoneX);
                
            g.append('path')
                .datum(forecastData)
                .attr('class', 'area forecast')
                .attr('d', area)
                .attr('opacity', 0);
                
            // Add cutoff line between historical and forecast data
            const cutoffDate = timeSeriesData[timeSeriesData.length - 1].date;
            
            g.append('line')
                .attr('class', 'cutoff-line')
                .attr('x1', xScale(cutoffDate))
                .attr('y1', 0)
                .attr('x2', xScale(cutoffDate))
                .attr('y2', height)
                .attr('stroke', '#999')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0);
                
            g.append('text')
                .attr('class', 'cutoff-label')
                .attr('x', xScale(cutoffDate) + 5)
                .attr('y', 15)
                .attr('fill', '#999')
                .text('Forecast Start')
                .attr('opacity', 0);
                
            // Add legend
            const legend = g.append('g')
                .attr('class', 'forecast-legend')
                .attr('transform', `translate(${width - 120}, 10)`)
                .attr('opacity', 0);
                
            const legendItems = [
                {name: 'Historical', color: 'var(--primary)', type: 'line'},
                {name: 'Forecast', color: 'var(--forecast-color)', type: 'line-dashed'},
                {name: 'Uncertainty', color: 'var(--forecast-color)', type: 'area'}
            ];
            
            legendItems.forEach((item, i) => {
                const legendG = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);
                    
                if (item.type === 'line') {
                    legendG.append('line')
                        .attr('x1', 0)
                        .attr('y1', 5)
                        .attr('x2', 20)
                        .attr('y2', 5)
                        .attr('stroke', item.color)
                        .attr('stroke-width', 2);
                } else if (item.type === 'line-dashed') {
                    legendG.append('line')
                        .attr('x1', 0)
                        .attr('y1', 5)
                        .attr('x2', 20)
                        .attr('y2', 5)
                        .attr('stroke', item.color)
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '3,3');
                } else if (item.type === 'area') {
                    legendG.append('rect')
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('width', 20)
                        .attr('height', 10)
                        .attr('fill', item.color)
                        .attr('opacity', 0.2);
                }
                
                legendG.append('text')
                    .attr('x', 25)
                    .attr('y', 9)
                    .attr('font-size', '12px')
                    .text(item.name);
            });
            
            // Add component controls
            const componentsControl = g.append('g')
                .attr('class', 'components-control')
                .attr('transform', `translate(10, 10)`)
                .attr('opacity', 0);
                
            componentsControl.append('text')
                .attr('font-weight', 'bold')
                .text('Forecast Components:');
                
            const componentItems = [
                {name: 'Trend', color: 'var(--trend-color)', id: 'trend'},
                {name: 'Seasonality', color: 'var(--seasonality-color)', id: 'seasonality'},
                {name: 'Holidays', color: 'var(--holidays-color)', id: 'holidays'},
                {name: 'Autoregressive', color: 'var(--ar-color)', id: 'ar'}
            ];
            
            componentItems.forEach((item, i) => {
                const itemG = componentsControl.append('g')
                    .attr('transform', `translate(0, ${20 + i * 20})`);
                    
                itemG.append('rect')
                    .attr('width', 15)
                    .attr('height', 15)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', '#fff')
                    .attr('stroke', item.color)
                    .attr('stroke-width', 2)
                    .attr('class', `component-toggle ${item.id}-toggle`);
                    
                itemG.append('text')
                    .attr('x', 25)
                    .attr('y', 12)
                    .attr('font-size', '12px')
                    .text(item.name);
            });
            
            // Add forecast explainer
            const explainer = g.append('g')
                .attr('class', 'forecast-explainer')
                .attr('transform', `translate(${width / 2 - 150}, ${height / 2 - 100})`)
                .attr('opacity', 0);
                
            explainer.append('rect')
                .attr('width', 300)
                .attr('height', 200)
                .attr('rx', 10)
                .attr('ry', 10)
                .attr('fill', 'white')
                .attr('stroke', 'var(--primary)')
                .attr('stroke-width', 2)
                .attr('opacity', 0.9);
                
            explainer.append('text')
                .attr('x', 150)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-weight', 'bold')
                .text('NeuralProphet Forecast');
                
            explainer.append('text')
                .attr('x', 20)
                .attr('y', 60)
                .text(' Combines neural networks with time series decomposition');
                
            explainer.append('text')
                .attr('x', 20)
                .attr('y', 85)
                .text(' Models trend, seasonality, and special events');
                
            explainer.append('text')
                .attr('x', 20)
                .attr('y', 110)
                .text(' Captures patterns at multiple timescales');
                
            explainer.append('text')
                .attr('x', 20)
                .attr('y', 135)
                .text(' Provides uncertainty intervals for predictions');
                
            explainer.append('text')
                .attr('x', 20)
                .attr('y', 160)
                .text(' Handles holidays and special events automatically');
        }
        
        // Forecasting visualization step animations
        function animateForecastingStep0() {
            // Introduction to forecasting
            forecastingVisSvg.select('.forecast-explainer')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            forecastingVisSvg.select('.forecast-legend')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.components-control')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.line.forecast')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.area.forecast')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.cutoff-line')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.cutoff-label')
                .attr('opacity', 0);
        }
        
        function animateForecastingStep1() {
            // Show trend extrapolation
            forecastingVisSvg.select('.forecast-explainer')
                .transition()
                .duration(500)
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.forecast-legend')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            forecastingVisSvg.select('.components-control')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            forecastingVisSvg.select('.cutoff-line')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            forecastingVisSvg.select('.cutoff-label')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Show trend component
            forecastingVisSvg.select('.line.trend')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Toggle trend component in controls
            forecastingVisSvg.select('.trend-toggle')
                .transition()
                .duration(500)
                .attr('fill', 'var(--trend-color)')
                .attr('opacity', 0.7);
        }
        
        function animateForecastingStep2() {
            // Add seasonality
            forecastingVisSvg.select('.line.seasonality')
                .transition()
                .duration(800)
                .attr('opacity', 1);
                
            // Toggle seasonality component in controls
            forecastingVisSvg.select('.seasonality-toggle')
                .transition()
                .duration(500)
                .attr('fill', 'var(--seasonality-color)')
                .attr('opacity', 0.7);
                
            // Fade trend a bit
            forecastingVisSvg.select('.line.trend')
                .transition()
                .duration(500)
                .attr('opacity', 0.5);
        }
        
        function animateForecastingStep3() {
            // Add holidays
            forecastingVisSvg.select('.holidays-toggle')
                .transition()
                .duration(500)
                .attr('fill', 'var(--holidays-color)')
                .attr('opacity', 0.7);
                
            // Add AR terms
            forecastingVisSvg.select('.ar-toggle')
                .transition()
                .duration(500)
                .attr('fill', 'var(--ar-color)')
                .attr('opacity', 0.7);
        }
        
        function animateForecastingStep4() {
            // Show forecast with all components
            forecastingVisSvg.select('.line.forecast')
                .transition()
                .duration(1200)
                .attr('opacity', 1);
                
            forecastingVisSvg.select('.area.forecast')
                .transition()
                .duration(1200)
                .attr('opacity', 0.2);
                
            // Fade other components
            forecastingVisSvg.select('.line.trend')
                .transition()
                .duration(500)
                .attr('opacity', 0.3);
                
            forecastingVisSvg.select('.line.seasonality')
                .transition()
                .duration(500)
                .attr('opacity', 0.3);
        }
        
        // Reset forecasting visualization
        function resetForecastingVisualization() {
            forecastingVisSvg.select('.forecast-explainer')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.forecast-legend')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.components-control')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.line.trend')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.line.seasonality')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.line.forecast')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.area.forecast')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.cutoff-line')
                .attr('opacity', 0);
                
            forecastingVisSvg.select('.cutoff-label')
                .attr('opacity', 0);
                
            // Reset component toggles
            forecastingVisSvg.selectAll('.component-toggle')
                .attr('fill', '#fff')
                .attr('opacity', 1);
        }
    </script>
</body>
</html>