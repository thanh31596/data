<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DATA4800 Week 4: Clustering and Principal Component Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            background: white;
            color: #333;
            overflow: hidden;
        }

        .slide-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .slide {
            display: none;
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            padding: 60px;
            background: white;
            position: relative;
        }

        .slide.active {
            display: block;
        }

        h1 {
            color: #CC0000;
            font-size: 48px;
            margin-bottom: 30px;
            font-weight: bold;
            border-bottom: 3px solid #CC0000;
            padding-bottom: 15px;
        }

        h2 {
            color: #CC0000;
            font-size: 36px;
            margin-bottom: 25px;
            font-weight: bold;
        }

        h3 {
            color: #CC0000;
            font-size: 28px;
            margin-bottom: 20px;
            margin-top: 30px;
        }

        p, li {
            font-size: 22px;
            line-height: 1.6;
            margin-bottom: 15px;
            color: #333;
        }

        ul {
            margin-left: 40px;
        }

        .subtitle {
            font-size: 28px;
            color: #666;
            margin-top: -20px;
            margin-bottom: 40px;
        }

        .formula {
            font-size: 26px;
            background: #f5f5f5;
            padding: 20px;
            border-left: 4px solid #CC0000;
            margin: 25px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
        }

        .highlight-box {
            background: #fff3cd;
            border-left: 5px solid #CC0000;
            padding: 20px;
            margin: 25px 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 30px;
        }

        .visualization {
            margin: 30px auto;
            text-align: center;
        }

        .quiz-container {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 8px;
            margin-top: 30px;
            border: 2px solid #CC0000;
        }

        .quiz-option {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 20px;
        }

        .quiz-option:hover {
            border-color: #CC0000;
            background: #fff3cd;
        }

        .quiz-option.correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .quiz-option.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .quiz-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            font-size: 20px;
            display: none;
        }

        .quiz-feedback.show {
            display: block;
        }

        .navigation {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .nav-btn {
            background: #CC0000;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            font-family: Helvetica, Arial, sans-serif;
            transition: background 0.3s;
        }

        .nav-btn:hover {
            background: #990000;
        }

        .nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .slide-number {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 18px;
            color: #666;
            z-index: 1000;
        }

        .logo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 20px;
        }

        th {
            background: #CC0000;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        .example-box {
            background: #e7f3ff;
            border-left: 5px solid #0066cc;
            padding: 20px;
            margin: 25px 0;
        }

        .step-indicator {
            display: inline-block;
            background: #CC0000;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            text-align: center;
            line-height: 35px;
            margin-right: 10px;
            font-weight: bold;
        }

        svg {
            border: 1px solid #ddd;
        }

        .axis-label {
            font-size: 14px;
            fill: #333;
        }

        .button-demo {
            background: #CC0000;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            margin: 10px 5px;
        }

        .button-demo:hover {
            background: #990000;
        }
    </style>
</head>
<body>
    <div class="slide-container">
        
        <!-- Slide 1: Title -->
        <div class="slide active">
            <h1 style="font-size: 64px; margin-top: 150px; text-align: center; border: none;">DATA4800</h1>
            <h2 style="text-align: center; color: #666; font-size: 42px;">Artificial Intelligence and Machine Learning</h2>
            <h2 style="text-align: center; margin-top: 80px;">Workshop 4</h2>
            <h2 style="text-align: center; color: #666; font-weight: normal; font-size: 36px;">Clustering and Principal Component Analysis</h2>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 2: Learning Outcomes -->
        <div class="slide">
            <h1>Learning Outcomes</h1>
            <div style="margin-top: 80px;">
                <p><span class="step-indicator">1</span> <strong>Investigate</strong> unsupervised learning and understand when to apply it</p>
                <p style="margin-top: 40px;"><span class="step-indicator">2</span> <strong>Explore</strong> K-means clustering algorithm and its business applications</p>
                <p style="margin-top: 40px;"><span class="step-indicator">3</span> <strong>Apply</strong> principal components analysis for dimension reduction</p>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 3: Types of Machine Learning -->
        <div class="slide">
            <h1>Types of Machine Learning</h1>
            <div class="two-column" style="margin-top: 50px;">
                <div>
                    <h3>Supervised Learning</h3>
                    <ul>
                        <li>Has labeled training data</li>
                        <li>Learns from examples</li>
                        <li>Predicts outcomes</li>
                        <li>Examples: Classification, Regression</li>
                    </ul>
                </div>
                <div>
                    <h3>Unsupervised Learning</h3>
                    <ul>
                        <li>No labeled training data</li>
                        <li>Finds hidden patterns</li>
                        <li>Discovers structure</li>
                        <li>Examples: Clustering, PCA</li>
                    </ul>
                </div>
            </div>
            <div class="highlight-box" style="margin-top: 50px;">
                <strong>Today's Focus:</strong> Unsupervised learning - finding patterns in data without predefined labels
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 4: Unsupervised Learning Introduction -->
        <div class="slide">
            <h1>What is Unsupervised Learning?</h1>
            <p style="font-size: 24px; margin-top: 40px;">Unsupervised learning applies algorithms to unlabeled data to discover patterns and natural groupings.</p>
            
            <h3>Two Main Applications</h3>
            <div class="two-column">
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Clustering</h3>
                    <p>Separating data into meaningful groups</p>
                    <p><strong>Example:</strong> Customer segmentation - grouping similar customers for targeted marketing</p>
                </div>
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Dimension Reduction</h3>
                    <p>Reducing the number of features while preserving information</p>
                    <p><strong>Example:</strong> PCA - simplifying complex datasets for visualization</p>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 5: Business Motivation -->
        <div class="slide">
            <h1>Business Motivation: Retail Campaign</h1>
            <div class="example-box" style="margin-top: 40px;">
                <h3 style="margin-top: 0; color: #0066cc;">The Challenge</h3>
                <p>You are a retail analyst with a dataset of 200 customers containing:</p>
                <ul>
                    <li>Age, Income, Average Transaction Value</li>
                    <li>Previous Purchases, Days Since Last Purchase</li>
                    <li>Email Open Rate, Loyalty Status, Preferred Channel</li>
                </ul>
            </div>
            <div class="highlight-box">
                <h3 style="margin-top: 0;">The Question</h3>
                <p><strong>How can we identify natural customer segments without manually labeling each customer?</strong></p>
                <p>Traditional approach: Manual categorization (time-consuming, subjective)</p>
                <p>Machine learning approach: <strong>Clustering algorithm</strong> discovers groups automatically</p>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 6: Feature Scaling Introduction -->
        <div class="slide">
            <h1>Feature Scaling: Why It Matters</h1>
            <p style="margin-top: 40px;">Before clustering, we must ensure all features are on comparable scales.</p>
            
            <div class="example-box" style="margin-top: 30px;">
                <h3 style="margin-top: 0; color: #0066cc;">The Problem</h3>
                <p>Consider measuring customer similarity with:</p>
                <ul>
                    <li><strong>Age:</strong> ranges from 18 to 93 years</li>
                    <li><strong>Account Balance:</strong> ranges from $0 to $80,000</li>
                </ul>
                <p style="margin-top: 20px;">A difference of 17 years in age appears equal to a difference of $17 in balance, but they have very different business meanings!</p>
            </div>

            <div class="highlight-box">
                <strong>Solution:</strong> Transform all features to a common scale (typically 0 to 1) before calculating distances
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 7: Feature Scaling Methods -->
        <div class="slide">
            <h1>Feature Scaling Methods</h1>
            
            <h3>Min-Max Scaling</h3>
            <div class="formula">
                scaled_value = (value - minimum) / (maximum - minimum)
            </div>
            <p>Transforms values to range [0, 1]</p>

            <h3 style="margin-top: 40px;">Z-Score Normalization</h3>
            <div class="formula">
                z_score = (value - mean) / standard_deviation
            </div>
            <p>Centers data around mean = 0, standard deviation = 1</p>

            <div class="visualization" id="scalingViz" style="margin-top: 30px;"></div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 8: Quiz 1 - Feature Scaling -->
        <div class="slide">
            <h1>Quick Check: Feature Scaling</h1>
            <div class="quiz-container">
                <h3 style="margin-top: 0;">Question 1</h3>
                <p>You have customer ages ranging from 20 to 80. Using Min-Max scaling, what would an age of 50 become?</p>
                
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz1')">
                    A) 0.25
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz1')">
                    B) 0.40
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, true, 'quiz1')">
                    C) 0.50
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz1')">
                    D) 0.75
                </div>
                
                <div id="quiz1" class="quiz-feedback">
                    <strong>Correct!</strong> Using the formula: (50 - 20) / (80 - 20) = 30 / 60 = 0.50
                    <br><br>
                    Age 50 is exactly halfway between 20 and 80, so it scales to 0.50.
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 9: Distance Measures -->
        <div class="slide">
            <h1>Measuring Similarity: Distance</h1>
            <p style="margin-top: 30px;">Clustering requires a way to measure how similar or different data points are. We use <strong>distance measures</strong>.</p>
            
            <h3>Euclidean Distance (Most Common)</h3>
            <p>The straight-line distance between two points in space.</p>
            
            <div class="formula">
                Distance = √[(x₂ - x₁)² + (y₂ - y₁)²]
            </div>

            <div class="visualization" id="distanceViz"></div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 10: Distance Calculation Demo -->
        <div class="slide">
            <h1>Distance Calculation: Worked Example</h1>
            
            <div class="example-box">
                <h3 style="margin-top: 0; color: #0066cc;">Scenario: Comparing Two Customers</h3>
                <p><strong>Customer A:</strong> Age = 0.35 (scaled), Income = 0.45 (scaled)</p>
                <p><strong>Customer B:</strong> Age = 0.52 (scaled), Income = 0.48 (scaled)</p>
            </div>

            <div style="margin-top: 30px;">
                <p><span class="step-indicator">1</span> Calculate differences:</p>
                <p style="margin-left: 60px;">Age difference: 0.52 - 0.35 = 0.17</p>
                <p style="margin-left: 60px;">Income difference: 0.48 - 0.45 = 0.03</p>

                <p style="margin-top: 25px;"><span class="step-indicator">2</span> Square the differences:</p>
                <p style="margin-left: 60px;">Age: (0.17)² = 0.0289</p>
                <p style="margin-left: 60px;">Income: (0.03)² = 0.0009</p>

                <p style="margin-top: 25px;"><span class="step-indicator">3</span> Sum and take square root:</p>
                <div class="formula">
                    Distance = √(0.0289 + 0.0009) = √0.0298 = 0.173
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 11: Cluster Center (Centroid) -->
        <div class="slide">
            <h1>Cluster Center (Centroid)</h1>
            <p style="margin-top: 30px;">The <strong>centroid</strong> is the center point of a cluster, calculated by averaging all feature values of points in that cluster.</p>

            <div class="example-box" style="margin-top: 30px;">
                <h3 style="margin-top: 0; color: #0066cc;">Example: Finding Centroid</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Customer</th>
                            <th>Feature 1</th>
                            <th>Feature 2</th>
                            <th>Feature 3</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>1</td><td>1.00</td><td>0.40</td><td>0.25</td></tr>
                        <tr><td>2</td><td>0.80</td><td>0.35</td><td>0.40</td></tr>
                        <tr><td>3</td><td>1.10</td><td>0.37</td><td>0.27</td></tr>
                        <tr style="background: #fff3cd; font-weight: bold;">
                            <td>Centroid</td><td>0.97</td><td>0.37</td><td>0.31</td>
                        </tr>
                    </tbody>
                </table>
                <p style="margin-top: 15px;"><strong>Calculation:</strong> Feature 1 centroid = (1.00 + 0.80 + 1.10) / 3 = 0.97</p>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 12: K-means Algorithm -->
        <div class="slide">
            <h1>The K-means Algorithm</h1>
            <p style="margin-top: 30px;">K-means is an iterative algorithm that partitions data into K distinct clusters.</p>

            <div style="margin-top: 50px;">
                <div class="highlight-box">
                    <p><span class="step-indicator">1</span> <strong>Initialize:</strong> Choose K random points as initial cluster centers</p>
                </div>
                <div class="highlight-box">
                    <p><span class="step-indicator">2</span> <strong>Assign:</strong> Assign each data point to its nearest cluster center</p>
                </div>
                <div class="highlight-box">
                    <p><span class="step-indicator">3</span> <strong>Update:</strong> Recalculate cluster centers based on assigned points</p>
                </div>
                <div class="highlight-box">
                    <p><span class="step-indicator">4</span> <strong>Repeat:</strong> Continue steps 2-3 until cluster centers stop changing</p>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 13: K-means Animation -->
        <div class="slide">
            <h1>K-means in Action</h1>
            <p style="text-align: center;">Watch how clusters form through iterations</p>
            <div class="visualization" id="kmeansAnimation"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="button-demo" onclick="animateKMeans()">Start Animation</button>
                <button class="button-demo" onclick="resetKMeans()">Reset</button>
            </div>
            <p style="text-align: center; margin-top: 15px; font-size: 18px;" id="iterationText">Click "Start Animation" to begin</p>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 14: Quiz 2 - K-means Understanding -->
        <div class="slide">
            <h1>Quick Check: K-means Algorithm</h1>
            <div class="quiz-container">
                <h3 style="margin-top: 0;">Question 2</h3>
                <p>In the K-means algorithm, what does the "K" represent?</p>
                
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz2')">
                    A) The number of iterations the algorithm runs
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, true, 'quiz2')">
                    B) The number of clusters we want to create
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz2')">
                    C) The number of features in the dataset
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz2')">
                    D) The number of data points in the dataset
                </div>
                
                <div id="quiz2" class="quiz-feedback">
                    <strong>Correct!</strong> K is the number of clusters we specify before running the algorithm.
                    <br><br>
                    This is why choosing the right K value is crucial - we'll explore methods for this next.
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 15: Choosing K - Introduction -->
        <div class="slide">
            <h1>Choosing the Right K</h1>
            <p style="margin-top: 40px; font-size: 24px;">One of the biggest challenges in K-means: <strong>How many clusters should we create?</strong></p>

            <h3 style="margin-top: 50px;">Three Main Methods</h3>
            <div class="two-column">
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">1. Elbow Method</h3>
                    <p>Plot inertia vs. K and look for the "elbow" where improvement slows</p>
                </div>
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">2. Silhouette Method</h3>
                    <p>Measures how well-separated clusters are</p>
                </div>
            </div>
            <div class="highlight-box" style="margin-top: 20px;">
                <h3 style="margin-top: 0; color: #0066cc;">3. Domain Knowledge</h3>
                <p>Use business understanding (e.g., we want 3 customer tiers: Bronze, Silver, Gold)</p>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 16: Elbow Method -->
        <div class="slide">
            <h1>The Elbow Method</h1>
            <p style="margin-top: 30px;">Run K-means with different K values and plot the <strong>inertia</strong> (within-cluster sum of squares).</p>
            
            <div class="formula" style="font-size: 22px;">
                Inertia = Σ (distance from each point to its cluster center)²
            </div>

            <div class="visualization" id="elbowPlot"></div>

            <div class="highlight-box">
                <strong>Interpretation:</strong> Choose K where the curve starts to level off (the "elbow"). Here, K=4 is optimal.
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 17: Silhouette Method -->
        <div class="slide">
            <h1>The Silhouette Method</h1>
            <p style="margin-top: 30px;">Measures how similar a point is to its own cluster compared to other clusters.</p>

            <div class="formula" style="font-size: 20px;">
                Silhouette Score = (b - a) / max(a, b)
            </div>

            <p style="margin-top: 20px;"><strong>Where:</strong></p>
            <ul>
                <li><strong>a</strong> = average distance to points in same cluster</li>
                <li><strong>b</strong> = average distance to points in nearest other cluster</li>
            </ul>

            <div class="highlight-box" style="margin-top: 30px;">
                <h3 style="margin-top: 0;">Score Range</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>+1:</strong> Point is well-matched to its cluster</li>
                    <li><strong>0:</strong> Point is on the border between clusters</li>
                    <li><strong>-1:</strong> Point might be in the wrong cluster</li>
                </ul>
                <p style="margin-top: 15px;"><strong>Choose K that maximizes average silhouette score</strong></p>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 18: Inertia Concept -->
        <div class="slide">
            <h1>Understanding Inertia</h1>
            <p style="margin-top: 30px;"><strong>Inertia</strong> measures how compact and tight our clusters are.</p>

            <div class="example-box" style="margin-top: 40px;">
                <h3 style="margin-top: 0; color: #0066cc;">Calculation Process</h3>
                <p><span class="step-indicator">1</span> For each point, calculate its distance to its cluster center</p>
                <p><span class="step-indicator">2</span> Square each distance</p>
                <p><span class="step-indicator">3</span> Sum all squared distances</p>
            </div>

            <div class="two-column" style="margin-top: 40px;">
                <div class="highlight-box" style="background: #d4edda;">
                    <h3 style="margin-top: 0; color: #28a745;">Low Inertia (Good)</h3>
                    <p>Points are close to their cluster centers</p>
                    <p>Tight, well-defined clusters</p>
                </div>
                <div class="highlight-box" style="background: #f8d7da;">
                    <h3 style="margin-top: 0; color: #dc3545;">High Inertia (Poor)</h3>
                    <p>Points are spread out from centers</p>
                    <p>Loose, poorly-defined clusters</p>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 19: Interactive Elbow Plot -->
        <div class="slide">
            <h1>Interactive: Finding the Elbow</h1>
            <p style="text-align: center;">Hover over points to see inertia values</p>
            <div class="visualization" id="interactiveElbow"></div>
            <div class="highlight-box" style="margin-top: 20px;">
                <strong>Key Insight:</strong> The rate of decrease in inertia slows significantly after K=4, suggesting this is our optimal number of clusters.
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 20: Quiz 3 - Choosing K -->
        <div class="slide">
            <h1>Quick Check: Choosing K</h1>
            <div class="quiz-container">
                <h3 style="margin-top: 0;">Question 3</h3>
                <p>You run K-means with K=2 through K=10. The inertia values are: K=2 (500), K=3 (300), K=4 (200), K=5 (180), K=6 (170). Which K should you choose using the elbow method?</p>
                
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz3')">
                    A) K=2 (lowest K value)
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz3')">
                    B) K=3 (biggest single drop)
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, true, 'quiz3')">
                    C) K=4 (where decreases start to slow)
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz3')">
                    D) K=6 (lowest inertia)
                </div>
                
                <div id="quiz3" class="quiz-feedback">
                    <strong>Correct!</strong> K=4 is the elbow point.
                    <br><br>
                    The drop from K=2→3→4 is significant (500→300→200), but K=4→5→6 shows much smaller improvements (200→180→170). This diminishing return indicates K=4 is optimal.
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 21: Clustering Applications -->
        <div class="slide">
            <h1>Real-World Clustering Applications</h1>
            
            <div class="two-column" style="margin-top: 40px;">
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Customer Segmentation</h3>
                    <p><strong>Retail:</strong> Group customers by purchasing behavior</p>
                    <p><strong>Streaming:</strong> Identify viewer preferences for recommendations</p>
                    <p><strong>Banking:</strong> Segment customers for targeted products</p>
                </div>
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Medical Imaging</h3>
                    <p><strong>Diagnostics:</strong> Group similar medical images</p>
                    <p><strong>Pattern Recognition:</strong> Identify disease markers</p>
                    <p><strong>Treatment:</strong> Cluster patient responses</p>
                </div>
            </div>

            <div class="two-column" style="margin-top: 20px;">
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Social Networks</h3>
                    <p><strong>Community Detection:</strong> Find groups with similar interests</p>
                    <p><strong>Influence:</strong> Identify key network positions</p>
                </div>
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Anomaly Detection</h3>
                    <p><strong>Fraud:</strong> Detect unusual transactions</p>
                    <p><strong>Quality Control:</strong> Identify defective products</p>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 22: Pros and Cons -->
        <div class="slide">
            <h1>K-means: Advantages and Limitations</h1>
            
            <div class="two-column" style="margin-top: 40px;">
                <div>
                    <h3 style="color: #28a745;">Advantages</h3>
                    <ul>
                        <li>Conceptually simple and easy to understand</li>
                        <li>Scales well to large datasets</li>
                        <li>Easy to visualize results</li>
                        <li>Efficient computationally</li>
                        <li>Adapts quickly to new data</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: #dc3545;">Limitations</h3>
                    <ul>
                        <li>Must specify K in advance</li>
                        <li>Sensitive to initial centroid placement</li>
                        <li>Struggles with clusters of different sizes/densities</li>
                        <li>Affected by outliers</li>
                        <li>Assumes spherical clusters</li>
                    </ul>
                </div>
            </div>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>Best Practice:</strong> Run K-means multiple times with different random initializations and choose the result with lowest inertia.
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 23: Hierarchical Clustering -->
        <div class="slide">
            <h1>Alternative: Hierarchical Clustering</h1>
            <p style="margin-top: 30px;">Unlike K-means, hierarchical clustering doesn't require specifying K upfront.</p>

            <div class="two-column" style="margin-top: 40px;">
                <div>
                    <h3>Agglomerative (Bottom-Up)</h3>
                    <ul>
                        <li>Start: Each point is its own cluster</li>
                        <li>Repeatedly merge closest clusters</li>
                        <li>End: One big cluster containing all points</li>
                        <li>Creates a dendrogram (tree diagram)</li>
                    </ul>
                </div>
                <div>
                    <h3>Distance Linkage Methods</h3>
                    <ul>
                        <li><strong>Average:</strong> Average distance between all pairs</li>
                        <li><strong>Complete:</strong> Maximum distance between points</li>
                        <li><strong>Single:</strong> Minimum distance between points</li>
                        <li><strong>Ward:</strong> Minimizes within-cluster variance</li>
                    </ul>
                </div>
            </div>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>Advantage:</strong> Provides a hierarchy of clusters; choose K by "cutting" the dendrogram at desired level
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 24: Business Questions -->
        <div class="slide">
            <h1>Interpreting Clustering Results</h1>
            <p style="margin-top: 30px;">After running clustering, ask these critical business questions:</p>

            <div class="highlight-box" style="margin-top: 40px;">
                <h3 style="margin-top: 0; color: #CC0000;">1. Can you understand the data without clustering?</h3>
                <p>Is there obvious structure, or do clusters reveal hidden patterns?</p>
            </div>

            <div class="highlight-box">
                <h3 style="margin-top: 0; color: #CC0000;">2. How many clusters is reasonable?</h3>
                <p>Balance statistical metrics (elbow, silhouette) with business needs</p>
            </div>

            <div class="highlight-box">
                <h3 style="margin-top: 0; color: #CC0000;">3. What characterizes each cluster?</h3>
                <p>Examine average feature values per cluster - give them meaningful names</p>
            </div>

            <div class="highlight-box">
                <h3 style="margin-top: 0; color: #CC0000;">4. What actions should we take?</h3>
                <p>How do insights translate to marketing strategies, product development, or operations?</p>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 25: Quiz 4 - Business Application -->
        <div class="slide">
            <h1>Quick Check: Business Application</h1>
            <div class="quiz-container">
                <h3 style="margin-top: 0;">Question 4</h3>
                <p>You've identified 3 customer clusters: Cluster A (high income, low purchase frequency), Cluster B (medium income, high purchase frequency), Cluster C (low income, medium purchase frequency). Which cluster should receive discount promotions?</p>
                
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz4')">
                    A) Cluster A - they have money to spend
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, true, 'quiz4')">
                    B) Cluster C - discounts might increase their frequency
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz4')">
                    C) Cluster B - reward loyal customers
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz4')">
                    D) All clusters equally
                </div>
                
                <div id="quiz4" class="quiz-feedback">
                    <strong>Correct!</strong> Cluster C is price-sensitive and might respond well to discounts.
                    <br><br>
                    Cluster A may not need discounts (already high-value), and Cluster B is already purchasing frequently. Cluster C has potential to increase engagement through targeted promotions.
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 26: Curse of Dimensionality -->
        <div class="slide">
            <h1>The Curse of Dimensionality</h1>
            <p style="margin-top: 30px;">As the number of features increases, distances become less meaningful and clustering becomes harder.</p>

            <div class="example-box" style="margin-top: 40px;">
                <h3 style="margin-top: 0; color: #0066cc;">The Problem</h3>
                <p><strong>2 features:</strong> Nearest neighbor at distance 0.2</p>
                <p><strong>10 features:</strong> Nearest neighbor at distance 2.8</p>
                <p><strong>100 features:</strong> All points seem equally distant!</p>
            </div>

            <div class="two-column" style="margin-top: 30px;">
                <div class="highlight-box">
                    <h3 style="margin-top: 0;">Consequences</h3>
                    <ul style="margin-left: 20px;">
                        <li>Clusters become harder to find</li>
                        <li>Distance measures lose meaning</li>
                        <li>Computation becomes expensive</li>
                    </ul>
                </div>
                <div class="highlight-box" style="background: #d4edda;">
                    <h3 style="margin-top: 0; color: #28a745;">Solution</h3>
                    <ul style="margin-left: 20px;">
                        <li>Dimension reduction (PCA)</li>
                        <li>Feature selection</li>
                        <li>Alternative distance metrics</li>
                    </ul>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 27: PCA Introduction -->
        <div class="slide">
            <h1>Principal Component Analysis (PCA)</h1>
            <p style="margin-top: 40px; font-size: 24px;">PCA is a dimension reduction technique that transforms data into a new coordinate system while preserving the most important information.</p>

            <div class="two-column" style="margin-top: 50px;">
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Goal</h3>
                    <p>Reduce number of features from many (e.g., 20) to few (e.g., 2-3) while retaining maximum variance</p>
                </div>
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Benefits</h3>
                    <ul style="margin-left: 20px;">
                        <li>Visualize high-dimensional data</li>
                        <li>Remove noise</li>
                        <li>Speed up algorithms</li>
                        <li>Address curse of dimensionality</li>
                    </ul>
                </div>
            </div>

            <div class="example-box" style="margin-top: 30px;">
                <strong>Analogy:</strong> Taking a photograph of a 3D object creates a 2D image that captures most of the important information. PCA does this mathematically.
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 28: PCA Intuition -->
        <div class="slide">
            <h1>PCA: Finding the Best View</h1>
            <p style="margin-top: 30px;">PCA finds new axes (principal components) that capture maximum variance in the data.</p>

            <div class="visualization" id="pcaIntuition"></div>

            <div class="two-column" style="margin-top: 20px;">
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">First Principal Component (PC1)</h3>
                    <p>Direction of maximum variance in the data</p>
                    <p>Captures the most information</p>
                </div>
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Second Principal Component (PC2)</h3>
                    <p>Perpendicular to PC1</p>
                    <p>Captures next most variance</p>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 29: PCA Process -->
        <div class="slide">
            <h1>The PCA Process</h1>
            
            <div style="margin-top: 40px;">
                <div class="highlight-box">
                    <p><span class="step-indicator">1</span> <strong>Standardize:</strong> Scale all features to have mean=0 and standard deviation=1</p>
                </div>

                <div class="highlight-box">
                    <p><span class="step-indicator">2</span> <strong>Compute Covariance Matrix:</strong> Measure how features vary together</p>
                </div>

                <div class="highlight-box">
                    <p><span class="step-indicator">3</span> <strong>Calculate Eigenvectors:</strong> Find directions of maximum variance (principal components)</p>
                </div>

                <div class="highlight-box">
                    <p><span class="step-indicator">4</span> <strong>Sort by Eigenvalues:</strong> Rank components by variance explained</p>
                </div>

                <div class="highlight-box">
                    <p><span class="step-indicator">5</span> <strong>Transform Data:</strong> Project original data onto top principal components</p>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 30: PCA Visualization -->
        <div class="slide">
            <h1>Visualizing Variance Explained</h1>
            <p style="text-align: center;">Each principal component captures some portion of total variance</p>
            
            <div class="visualization" id="varianceExplained"></div>

            <div class="highlight-box" style="margin-top: 20px;">
                <strong>Decision Rule:</strong> Keep enough components to explain 80-95% of variance. Here, 2 components capture 85% of information.
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 31: Biplot Explanation -->
        <div class="slide">
            <h1>Understanding Biplots</h1>
            <p style="margin-top: 30px;">A biplot combines two visualizations:</p>

            <div class="two-column" style="margin-top: 40px;">
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">1. Scatter Plot</h3>
                    <p>Shows data points in PC1-PC2 space</p>
                    <p>Points close together are similar</p>
                    <p>Reveals natural groupings</p>
                </div>
                <div class="highlight-box">
                    <h3 style="margin-top: 0; color: #0066cc;">2. Loading Vectors</h3>
                    <p>Arrows show original features</p>
                    <p>Direction indicates correlation with PCs</p>
                    <p>Length indicates importance</p>
                </div>
            </div>

            <div class="example-box" style="margin-top: 30px;">
                <h3 style="margin-top: 0;">Interpretation Guide</h3>
                <ul>
                    <li><strong>Long arrows:</strong> Feature contributes strongly to the PCs</li>
                    <li><strong>Arrows pointing same direction:</strong> Features are positively correlated</li>
                    <li><strong>Arrows pointing opposite directions:</strong> Features are negatively correlated</li>
                    <li><strong>Perpendicular arrows:</strong> Features are uncorrelated</li>
                </ul>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 32: Interactive PCA Demo -->
        <div class="slide">
            <h1>Interactive PCA Biplot</h1>
            <div class="visualization" id="biplotDemo"></div>
            <div class="highlight-box" style="margin-top: 20px;">
                <strong>Observation:</strong> Income and TransactionValue point in similar directions (positively correlated). Age points perpendicular (independent). Three distinct customer clusters emerge.
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 33: Quiz 5 - PCA Understanding -->
        <div class="slide">
            <h1>Quick Check: PCA Concepts</h1>
            <div class="quiz-container">
                <h3 style="margin-top: 0;">Question 5</h3>
                <p>You perform PCA on a dataset with 15 features. PC1 explains 40% of variance, PC2 explains 25%, PC3 explains 15%, and PC4 explains 10%. How many components should you keep to retain 80% of variance?</p>
                
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz5')">
                    A) 1 component
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz5')">
                    B) 2 components
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, true, 'quiz5')">
                    C) 3 components
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false, 'quiz5')">
                    D) 4 components
                </div>
                
                <div id="quiz5" class="quiz-feedback">
                    <strong>Correct!</strong> You need 3 components.
                    <br><br>
                    PC1 + PC2 = 65% (not enough)<br>
                    PC1 + PC2 + PC3 = 80% (meets our target)<br>
                    This reduces from 15 features to just 3 while retaining 80% of information!
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 34: Comparison Table -->
        <div class="slide">
            <h1>Clustering vs. PCA Comparison</h1>
            <table style="margin-top: 40px;">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>K-means Clustering</th>
                        <th>PCA</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Purpose</strong></td>
                        <td>Group similar observations</td>
                        <td>Reduce number of features</td>
                    </tr>
                    <tr>
                        <td><strong>Output</strong></td>
                        <td>Cluster labels for each point</td>
                        <td>New transformed features</td>
                    </tr>
                    <tr>
                        <td><strong>Use When</strong></td>
                        <td>Need to segment data</td>
                        <td>Too many features to visualize/process</td>
                    </tr>
                    <tr>
                        <td><strong>Interpretability</strong></td>
                        <td>High - clusters have clear meaning</td>
                        <td>Medium - components are combinations</td>
                    </tr>
                    <tr>
                        <td><strong>Specify in Advance</strong></td>
                        <td>Number of clusters (K)</td>
                        <td>Variance to retain (or # components)</td>
                    </tr>
                    <tr>
                        <td><strong>Best For</strong></td>
                        <td>Customer segmentation, anomaly detection</td>
                        <td>Visualization, noise reduction</td>
                    </tr>
                </tbody>
            </table>
            <div class="highlight-box" style="margin-top: 25px;">
                <strong>They Work Together:</strong> Often use PCA first to reduce dimensions, then cluster in the reduced space!
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 35: Python and Orange Guidance -->
        <div class="slide">
            <h1>Practical Implementation</h1>
            
            <div class="two-column" style="margin-top: 40px;">
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Python (scikit-learn)</h3>
                    <pre style="background: #f5f5f5; padding: 15px; font-size: 16px; overflow-x: auto;">
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

# K-means
kmeans = KMeans(n_clusters=4)
labels = kmeans.fit_predict(data)

# PCA
pca = PCA(n_components=2)
transformed = pca.fit_transform(data)
                    </pre>
                    <p style="margin-top: 15px;"><strong>Google Colab:</strong> Interactive notebooks for practice</p>
                </div>
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Orange Data Mining</h3>
                    <p><strong>Workflow:</strong></p>
                    <ol>
                        <li>File widget → Load CSV</li>
                        <li>K-means widget → Set K</li>
                        <li>Scatter Plot → Visualize</li>
                        <li>Data Table → Examine clusters</li>
                    </ol>
                    <p style="margin-top: 20px;"><strong>Key Settings:</strong></p>
                    <ul style="margin-left: 20px;">
                        <li>Normalize features: Yes</li>
                        <li>Optimization runs: 10+</li>
                        <li>Distance metric: Euclidean</li>
                    </ul>
                </div>
            </div>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

        <!-- Slide 36: Summary -->
        <div class="slide">
            <h1>Workshop Summary</h1>
            
            <div class="highlight-box" style="margin-top: 40px;">
                <h3 style="margin-top: 0; color: #CC0000;">Key Takeaways</h3>
                <ul style="font-size: 20px;">
                    <li><strong>Unsupervised learning</strong> finds patterns in unlabeled data</li>
                    <li><strong>K-means clustering</strong> groups similar observations using distance measures</li>
                    <li><strong>Feature scaling</strong> is essential before calculating distances</li>
                    <li><strong>Choosing K</strong> requires elbow method, silhouette analysis, or domain knowledge</li>
                    <li><strong>PCA</strong> reduces dimensions while preserving variance</li>
                    <li><strong>Biplots</strong> visualize both data points and feature contributions</li>
                </ul>
            </div>

            <div class="two-column" style="margin-top: 30px;">
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Next Steps</h3>
                    <ul style="margin-left: 20px;">
                        <li>Practice with retail dataset</li>
                        <li>Experiment with different K values</li>
                        <li>Interpret business meaning of clusters</li>
                    </ul>
                </div>
                <div class="example-box">
                    <h3 style="margin-top: 0; color: #0066cc;">Resources</h3>
                    <ul style="margin-left: 20px;">
                        <li>Google Colab notebooks</li>
                        <li>Orange Data Mining tutorials</li>
                        <li>scikit-learn documentation</li>
                    </ul>
                </div>
            </div>

            <p style="text-align: center; margin-top: 50px; font-size: 28px; color: #CC0000;"><strong>Questions?</strong></p>
            <div class="logo">KAPLAN BUSINESS SCHOOL</div>
        </div>

    </div>

    <div class="slide-number">
        <span id="currentSlide">1</span> / <span id="totalSlides">36</span>
    </div>

    <div class="navigation">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">← Previous</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">Next →</button>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        document.getElementById('totalSlides').textContent = totalSlides;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            document.getElementById('currentSlide').textContent = currentSlide + 1;
            
            document.getElementById('prevBtn').disabled = currentSlide === 0;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides - 1;

            // Initialize visualizations when slide becomes active (only if D3 is loaded)
            if (typeof d3 !== 'undefined') {
                setTimeout(() => {
                    if (currentSlide === 6) createScalingViz();
                    if (currentSlide === 8) createDistanceViz();
                    if (currentSlide === 12) createKMeansAnimation();
                    if (currentSlide === 15) createElbowPlot();
                    if (currentSlide === 18) createInteractiveElbow();
                    if (currentSlide === 27) createPCAIntuition();
                    if (currentSlide === 29) createVarianceExplained();
                    if (currentSlide === 31) createBiplotDemo();
                }, 100);
            }
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') changeSlide(-1);
            if (e.key === 'ArrowRight') changeSlide(1);
        });

        // Quiz functionality
        function checkAnswer(element, isCorrect, feedbackId) {
            const options = element.parentElement.querySelectorAll('.quiz-option');
            options.forEach(opt => {
                opt.style.pointerEvents = 'none';
                if (opt === element) {
                    opt.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
            });
            
            if (isCorrect) {
                document.getElementById(feedbackId).classList.add('show');
                document.getElementById(feedbackId).style.background = '#d4edda';
                document.getElementById(feedbackId).style.borderLeft = '5px solid #28a745';
            } else {
                document.getElementById(feedbackId).innerHTML = '<strong>Not quite.</strong> Try reviewing the concept and think about what each option means.';
                document.getElementById(feedbackId).classList.add('show');
                document.getElementById(feedbackId).style.background = '#f8d7da';
                document.getElementById(feedbackId).style.borderLeft = '5px solid #dc3545';
            }
        }

        // Visualization: Feature Scaling
        function createScalingViz() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#scalingViz');
            if (container.select('svg').size() > 0) return;

            const width = 1000;
            const height = 300;
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Original data
            const originalData = [
                {label: 'Age', value: 35, color: '#CC0000'},
                {label: 'Income ($k)', value: 45, color: '#0066cc'}
            ];

            // Scaled data
            const scaledData = [
                {label: 'Age (scaled)', value: 0.35, color: '#CC0000'},
                {label: 'Income (scaled)', value: 0.45, color: '#0066cc'}
            ];

            // Draw original
            svg.append('text')
                .attr('x', 150)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('Original Values');

            const xScale1 = d3.scaleLinear().domain([0, 100]).range([50, 250]);
            originalData.forEach((d, i) => {
                const y = 70 + i * 80;
                svg.append('rect')
                    .attr('x', 50)
                    .attr('y', y)
                    .attr('width', xScale1(d.value) - 50)
                    .attr('height', 40)
                    .attr('fill', d.color)
                    .attr('opacity', 0.7);
                
                svg.append('text')
                    .attr('x', xScale1(d.value) + 10)
                    .attr('y', y + 25)
                    .style('font-size', '16px')
                    .text(d.value);

                svg.append('text')
                    .attr('x', 20)
                    .attr('y', y + 25)
                    .attr('text-anchor', 'end')
                    .style('font-size', '14px')
                    .text(d.label);
            });

            // Draw scaled
            svg.append('text')
                .attr('x', 650)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('After Min-Max Scaling [0-1]');

            const xScale2 = d3.scaleLinear().domain([0, 1]).range([550, 750]);
            scaledData.forEach((d, i) => {
                const y = 70 + i * 80;
                svg.append('rect')
                    .attr('x', 550)
                    .attr('y', y)
                    .attr('width', xScale2(d.value) - 550)
                    .attr('height', 40)
                    .attr('fill', d.color)
                    .attr('opacity', 0.7);
                
                svg.append('text')
                    .attr('x', xScale2(d.value) + 10)
                    .attr('y', y + 25)
                    .style('font-size', '16px')
                    .text(d.value.toFixed(2));

                svg.append('text')
                    .attr('x', 530)
                    .attr('y', y + 25)
                    .attr('text-anchor', 'end')
                    .style('font-size', '14px')
                    .text(d.label);
            });
        }

        // Visualization: Distance Measure
        function createDistanceViz() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#distanceViz');
            if (container.select('svg').size() > 0) return;

            const width = 600;
            const height = 400;
            const margin = {top: 40, right: 40, bottom: 60, left: 60};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const xScale = d3.scaleLinear().domain([0, 1]).range([margin.left, width - margin.right]);
            const yScale = d3.scaleLinear().domain([0, 1]).range([height - margin.bottom, margin.top]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).ticks(5))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 40)
                .attr('fill', 'black')
                .style('font-size', '14px')
                .text('Feature X (scaled)');

            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(d3.axisLeft(yScale).ticks(5))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .attr('fill', 'black')
                .style('font-size', '14px')
                .text('Feature Y (scaled)');

            // Points
            const pointA = {x: 0.35, y: 0.45, label: 'Customer A'};
            const pointB = {x: 0.52, y: 0.48, label: 'Customer B'};

            svg.append('circle')
                .attr('cx', xScale(pointA.x))
                .attr('cy', yScale(pointA.y))
                .attr('r', 8)
                .attr('fill', '#CC0000');

            svg.append('text')
                .attr('x', xScale(pointA.x) - 10)
                .attr('y', yScale(pointA.y) - 15)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(pointA.label);

            svg.append('circle')
                .attr('cx', xScale(pointB.x))
                .attr('cy', yScale(pointB.y))
                .attr('r', 8)
                .attr('fill', '#0066cc');

            svg.append('text')
                .attr('x', xScale(pointB.x) + 10)
                .attr('y', yScale(pointB.y) - 15)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(pointB.label);

            // Distance line
            svg.append('line')
                .attr('x1', xScale(pointA.x))
                .attr('y1', yScale(pointA.y))
                .attr('x2', xScale(pointB.x))
                .attr('y2', yScale(pointB.y))
                .attr('stroke', '#666')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            const distance = Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2));
            svg.append('text')
                .attr('x', (xScale(pointA.x) + xScale(pointB.x)) / 2)
                .attr('y', (yScale(pointA.y) + yScale(pointB.y)) / 2 - 10)
                .style('font-size', '14px')
                .style('fill', '#666')
                .text(`Distance = ${distance.toFixed(3)}`);
        }

        // K-means Animation
        let kmeansInterval;
        let kmeansIteration = 0;
        let kmeansData = [];
        let centroids = [];

        function createKMeansAnimation() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#kmeansAnimation');
            if (container.select('svg').size() > 0) return;

            const width = 700;
            const height = 450;
            const margin = {top: 20, right: 20, bottom: 40, left: 40};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Generate random data
            kmeansData = [];
            const clusters = [{x: 0.3, y: 0.3}, {x: 0.7, y: 0.7}, {x: 0.5, y: 0.8}];
            clusters.forEach((center, i) => {
                for (let j = 0; j < 30; j++) {
                    kmeansData.push({
                        x: center.x + (Math.random() - 0.5) * 0.2,
                        y: center.y + (Math.random() - 0.5) * 0.2,
                        cluster: i
                    });
                }
            });

            // Random initial centroids
            centroids = [
                {x: Math.random(), y: Math.random()},
                {x: Math.random(), y: Math.random()},
                {x: Math.random(), y: Math.random()}
            ];

            const xScale = d3.scaleLinear().domain([0, 1]).range([margin.left, width - margin.right]);
            const yScale = d3.scaleLinear().domain([0, 1]).range([height - margin.bottom, margin.top]);
            const colors = ['#CC0000', '#0066cc', '#28a745'];

            window.kmeansXScale = xScale;
            window.kmeansYScale = yScale;
            window.kmeansColors = colors;
            window.kmeansSvg = svg;
        }

        function animateKMeans() {
            if (typeof d3 === 'undefined') {
                alert('Visualization is still loading. Please wait a moment and try again.');
                return;
            }
            
            if (kmeansInterval) clearInterval(kmeansInterval);
            kmeansIteration = 0;
            
            kmeansInterval = setInterval(() => {
                if (kmeansIteration >= 10) {
                    clearInterval(kmeansInterval);
                    document.getElementById('iterationText').textContent = 'Converged! Clusters are stable.';
                    return;
                }

                // Assign points to nearest centroid
                kmeansData.forEach(point => {
                    let minDist = Infinity;
                    let assignedCluster = 0;
                    centroids.forEach((centroid, i) => {
                        const dist = Math.sqrt(Math.pow(point.x - centroid.x, 2) + Math.pow(point.y - centroid.y, 2));
                        if (dist < minDist) {
                            minDist = dist;
                            assignedCluster = i;
                        }
                    });
                    point.cluster = assignedCluster;
                });

                // Update centroids
                centroids.forEach((centroid, i) => {
                    const clusterPoints = kmeansData.filter(p => p.cluster === i);
                    if (clusterPoints.length > 0) {
                        centroid.x = clusterPoints.reduce((sum, p) => sum + p.x, 0) / clusterPoints.length;
                        centroid.y = clusterPoints.reduce((sum, p) => sum + p.y, 0) / clusterPoints.length;
                    }
                });

                updateKMeansViz();
                kmeansIteration++;
                document.getElementById('iterationText').textContent = `Iteration ${kmeansIteration}`;
            }, 1000);
        }

        function updateKMeansViz() {
            if (typeof d3 === 'undefined') return;
            
            const svg = window.kmeansSvg;
            const xScale = window.kmeansXScale;
            const yScale = window.kmeansYScale;
            const colors = window.kmeansColors;

            svg.selectAll('*').remove();

            // Draw points
            svg.selectAll('circle.point')
                .data(kmeansData)
                .join('circle')
                .attr('class', 'point')
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y))
                .attr('r', 5)
                .attr('fill', d => colors[d.cluster])
                .attr('opacity', 0.6);

            // Draw centroids
            svg.selectAll('path.centroid')
                .data(centroids)
                .join('path')
                .attr('class', 'centroid')
                .attr('d', d3.symbol().type(d3.symbolCross).size(200))
                .attr('transform', (d, i) => `translate(${xScale(d.x)}, ${yScale(d.y)})`)
                .attr('fill', (d, i) => colors[i])
                .attr('stroke', 'black')
                .attr('stroke-width', 2);
        }

        function resetKMeans() {
            if (typeof d3 === 'undefined') return;
            
            if (kmeansInterval) clearInterval(kmeansInterval);
            kmeansIteration = 0;
            centroids = [
                {x: Math.random(), y: Math.random()},
                {x: Math.random(), y: Math.random()},
                {x: Math.random(), y: Math.random()}
            ];
            updateKMeansViz();
            document.getElementById('iterationText').textContent = 'Click "Start Animation" to begin';
        }

        // Elbow Plot
        function createElbowPlot() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#elbowPlot');
            if (container.select('svg').size() > 0) return;

            const width = 700;
            const height = 400;
            const margin = {top: 40, right: 40, bottom: 60, left: 80};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const data = [
                {k: 1, inertia: 580},
                {k: 2, inertia: 320},
                {k: 3, inertia: 180},
                {k: 4, inertia: 110},
                {k: 5, inertia: 85},
                {k: 6, inertia: 72},
                {k: 7, inertia: 65},
                {k: 8, inertia: 61}
            ];

            const xScale = d3.scaleLinear()
                .domain([0, 9])
                .range([margin.left, width - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([0, 600])
                .range([height - margin.bottom, margin.top]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).ticks(8))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 45)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('Number of Clusters (K)');

            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(d3.axisLeft(yScale))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -60)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('Inertia (Within-Cluster Sum of Squares)');

            // Line
            const line = d3.line()
                .x(d => xScale(d.k))
                .y(d => yScale(d.inertia));

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#CC0000')
                .attr('stroke-width', 3)
                .attr('d', line);

            // Points
            svg.selectAll('circle')
                .data(data)
                .join('circle')
                .attr('cx', d => xScale(d.k))
                .attr('cy', d => yScale(d.inertia))
                .attr('r', 6)
                .attr('fill', '#CC0000');

            // Highlight elbow at K=4
            svg.append('line')
                .attr('x1', xScale(4))
                .attr('y1', margin.top)
                .attr('x2', xScale(4))
                .attr('y2', height - margin.bottom)
                .attr('stroke', '#28a745')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            svg.append('text')
                .attr('x', xScale(4) + 10)
                .attr('y', margin.top + 20)
                .style('font-size', '14px')
                .style('fill', '#28a745')
                .style('font-weight', 'bold')
                .text('← Elbow at K=4');
        }

        // Interactive Elbow
        function createInteractiveElbow() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#interactiveElbow');
            if (container.select('svg').size() > 0) return;

            const width = 700;
            const height = 400;
            const margin = {top: 40, right: 40, bottom: 60, left: 80};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const data = [
                {k: 2, inertia: 320},
                {k: 3, inertia: 180},
                {k: 4, inertia: 110},
                {k: 5, inertia: 85},
                {k: 6, inertia: 72},
                {k: 7, inertia: 65}
            ];

            const xScale = d3.scaleLinear()
                .domain([1, 8])
                .range([margin.left, width - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([0, 350])
                .range([height - margin.bottom, margin.top]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).ticks(7))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 45)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('Number of Clusters (K)');

            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(d3.axisLeft(yScale))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -60)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('Inertia');

            // Line
            const line = d3.line()
                .x(d => xScale(d.k))
                .y(d => yScale(d.inertia));

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#0066cc')
                .attr('stroke-width', 3)
                .attr('d', line);

            // Tooltip
            const tooltip = container.append('div')
                .style('position', 'absolute')
                .style('background', 'white')
                .style('border', '2px solid #CC0000')
                .style('border-radius', '5px')
                .style('padding', '10px')
                .style('display', 'none')
                .style('font-size', '14px');

            // Interactive points
            svg.selectAll('circle')
                .data(data)
                .join('circle')
                .attr('cx', d => xScale(d.k))
                .attr('cy', d => yScale(d.inertia))
                .attr('r', 8)
                .attr('fill', '#0066cc')
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('r', 12);
                    tooltip.style('display', 'block')
                        .html(`<strong>K = ${d.k}</strong><br>Inertia = ${d.inertia}`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    d3.select(this).attr('r', 8);
                    tooltip.style('display', 'none');
                });
        }

        // PCA Intuition
        function createPCAIntuition() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#pcaIntuition');
            if (container.select('svg').size() > 0) return;

            const width = 700;
            const height = 400;
            const margin = {top: 40, right: 40, bottom: 60, left: 60};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Generate correlated data
            const data = [];
            for (let i = 0; i < 100; i++) {
                const x = Math.random();
                const y = x * 0.7 + Math.random() * 0.3;
                data.push({x, y});
            }

            const xScale = d3.scaleLinear().domain([0, 1]).range([margin.left, width - margin.right]);
            const yScale = d3.scaleLinear().domain([0, 1]).range([height - margin.bottom, margin.top]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .call(d3.axisBottom(xScale))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 40)
                .attr('fill', 'black')
                .style('font-size', '14px')
                .text('Original Feature 1');

            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(d3.axisLeft(yScale))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .attr('fill', 'black')
                .style('font-size', '14px')
                .text('Original Feature 2');

            // Points
            svg.selectAll('circle')
                .data(data)
                .join('circle')
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y))
                .attr('r', 4)
                .attr('fill', '#0066cc')
                .attr('opacity', 0.6);

            // PC1 direction (diagonal)
            svg.append('line')
                .attr('x1', xScale(0.1))
                .attr('y1', yScale(0.1))
                .attr('x2', xScale(0.9))
                .attr('y2', yScale(0.7))
                .attr('stroke', '#CC0000')
                .attr('stroke-width', 3)
                .attr('marker-end', 'url(#arrowRed)');

            svg.append('text')
                .attr('x', xScale(0.95))
                .attr('y', yScale(0.75))
                .style('font-size', '14px')
                .style('fill', '#CC0000')
                .style('font-weight', 'bold')
                .text('PC1 (max variance)');

            // PC2 direction (perpendicular)
            svg.append('line')
                .attr('x1', xScale(0.5))
                .attr('y1', yScale(0.4))
                .attr('x2', xScale(0.3))
                .attr('y2', yScale(0.55))
                .attr('stroke', '#28a745')
                .attr('stroke-width', 3)
                .attr('marker-end', 'url(#arrowGreen)');

            svg.append('text')
                .attr('x', xScale(0.15))
                .attr('y', yScale(0.58))
                .style('font-size', '14px')
                .style('fill', '#28a745')
                .style('font-weight', 'bold')
                .text('PC2');

            // Arrow markers
            svg.append('defs').append('marker')
                .attr('id', 'arrowRed')
                .attr('markerWidth', 10)
                .attr('markerHeight', 10)
                .attr('refX', 9)
                .attr('refY', 3)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', '0 0, 10 3, 0 6')
                .attr('fill', '#CC0000');

            svg.append('defs').append('marker')
                .attr('id', 'arrowGreen')
                .attr('markerWidth', 10)
                .attr('markerHeight', 10)
                .attr('refX', 9)
                .attr('refY', 3)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', '0 0, 10 3, 0 6')
                .attr('fill', '#28a745');
        }

        // Variance Explained
        function createVarianceExplained() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#varianceExplained');
            if (container.select('svg').size() > 0) return;

            const width = 700;
            const height = 400;
            const margin = {top: 40, right: 40, bottom: 60, left: 80};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const data = [
                {pc: 'PC1', variance: 55, cumulative: 55},
                {pc: 'PC2', variance: 30, cumulative: 85},
                {pc: 'PC3', variance: 10, cumulative: 95},
                {pc: 'PC4', variance: 3, cumulative: 98},
                {pc: 'PC5', variance: 2, cumulative: 100}
            ];

            const xScale = d3.scaleBand()
                .domain(data.map(d => d.pc))
                .range([margin.left, width - margin.right])
                .padding(0.2);

            const yScale = d3.scaleLinear()
                .domain([0, 100])
                .range([height - margin.bottom, margin.top]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0, ${height - margin.bottom})`)
                .call(d3.axisBottom(xScale))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 45)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('Principal Component');

            svg.append('g')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(d3.axisLeft(yScale))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -60)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('Variance Explained (%)');

            // Bars
            svg.selectAll('rect')
                .data(data)
                .join('rect')
                .attr('x', d => xScale(d.pc))
                .attr('y', d => yScale(d.variance))
                .attr('width', xScale.bandwidth())
                .attr('height', d => height - margin.bottom - yScale(d.variance))
                .attr('fill', '#0066cc');

            // Line for cumulative
            const line = d3.line()
                .x(d => xScale(d.pc) + xScale.bandwidth() / 2)
                .y(d => yScale(d.cumulative));

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#CC0000')
                .attr('stroke-width', 3)
                .attr('d', line);

            svg.selectAll('circle.cumulative')
                .data(data)
                .join('circle')
                .attr('class', 'cumulative')
                .attr('cx', d => xScale(d.pc) + xScale.bandwidth() / 2)
                .attr('cy', d => yScale(d.cumulative))
                .attr('r', 5)
                .attr('fill', '#CC0000');

            // Legend
            svg.append('rect')
                .attr('x', width - 200)
                .attr('y', margin.top)
                .attr('width', 20)
                .attr('height', 20)
                .attr('fill', '#0066cc');

            svg.append('text')
                .attr('x', width - 175)
                .attr('y', margin.top + 15)
                .style('font-size', '14px')
                .text('Individual Variance');

            svg.append('line')
                .attr('x1', width - 200)
                .attr('y1', margin.top + 40)
                .attr('x2', width - 180)
                .attr('y2', margin.top + 40)
                .attr('stroke', '#CC0000')
                .attr('stroke-width', 3);

            svg.append('text')
                .attr('x', width - 175)
                .attr('y', margin.top + 45)
                .style('font-size', '14px')
                .text('Cumulative Variance');

            // 80% threshold line
            svg.append('line')
                .attr('x1', margin.left)
                .attr('y1', yScale(80))
                .attr('x2', width - margin.right)
                .attr('y2', yScale(80))
                .attr('stroke', '#28a745')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            svg.append('text')
                .attr('x', margin.left + 10)
                .attr('y', yScale(80) - 5)
                .style('font-size', '12px')
                .style('fill', '#28a745')
                .text('80% threshold');
        }

        // Biplot Demo
        function createBiplotDemo() {
            if (typeof d3 === 'undefined') {
                console.error('D3 not loaded yet');
                return;
            }
            
            const container = d3.select('#biplotDemo');
            if (container.select('svg').size() > 0) return;

            const width = 700;
            const height = 500;
            const margin = {top: 40, right: 40, bottom: 60, left: 60};

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Generate sample data (3 clusters)
            const clusters = [
                {center: {pc1: -2, pc2: 1}, color: '#CC0000', n: 25},
                {center: {pc1: 0, pc2: -1.5}, color: '#0066cc', n: 25},
                {center: {pc1: 2.5, pc2: 0.5}, color: '#28a745', n: 25}
            ];

            const data = [];
            clusters.forEach(cluster => {
                for (let i = 0; i < cluster.n; i++) {
                    data.push({
                        pc1: cluster.center.pc1 + (Math.random() - 0.5) * 1.5,
                        pc2: cluster.center.pc2 + (Math.random() - 0.5) * 1.5,
                        color: cluster.color
                    });
                }
            });

            const xScale = d3.scaleLinear().domain([-4, 4]).range([margin.left, width - margin.right]);
            const yScale = d3.scaleLinear().domain([-3, 3]).range([height - margin.bottom, margin.top]);

            // Axes
            svg.append('g')
                .attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('PC1 (55% variance)');

            svg.append('g')
                .attr('transform', `translate(${xScale(0)}, 0)`)
                .call(d3.axisLeft(yScale))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .attr('fill', 'black')
                .style('font-size', '16px')
                .text('PC2 (30% variance)');

            // Data points
            svg.selectAll('circle.data')
                .data(data)
                .join('circle')
                .attr('class', 'data')
                .attr('cx', d => xScale(d.pc1))
                .attr('cy', d => yScale(d.pc2))
                .attr('r', 4)
                .attr('fill', d => d.color)
                .attr('opacity', 0.6);

            // Loading vectors (arrows)
            const loadings = [
                {name: 'Age', pc1: -1.5, pc2: 0.5},
                {name: 'Income', pc1: 2, pc2: 1},
                {name: 'TransactionValue', pc1: 2.2, pc2: 0.8},
                {name: 'EmailOpenRate', pc1: 0.5, pc2: -1.8}
            ];

            loadings.forEach(loading => {
                const scale = 1.5;
                svg.append('line')
                    .attr('x1', xScale(0))
                    .attr('y1', yScale(0))
                    .attr('x2', xScale(loading.pc1 * scale))
                    .attr('y2', yScale(loading.pc2 * scale))
                    .attr('stroke', '#666')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowBiplot)');

                svg.append('text')
                    .attr('x', xScale(loading.pc1 * scale * 1.1))
                    .attr('y', yScale(loading.pc2 * scale * 1.1))
                    .style('font-size', '13px')
                    .style('font-weight', 'bold')
                    .text(loading.name);
            });

            // Arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowBiplot')
                .attr('markerWidth', 10)
                .attr('markerHeight', 10)
                .attr('refX', 9)
                .attr('refY', 3)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', '0 0, 10 3, 0 6')
                .attr('fill', '#666');
        }

        // Initialize first slide
        function initPresentation() {
            if (typeof d3 !== 'undefined') {
                showSlide(0);
            } else {
                // Wait for D3 to load
                setTimeout(initPresentation, 100);
            }
        }
        
        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPresentation);
        } else {
            initPresentation();
        }
    </script>
</body>
</html>
