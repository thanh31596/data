<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 6: Advanced Classification Methods</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: white;
            color: #333;
            overflow: hidden;
        }

        .slide-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px;
        }

        .slide {
            display: none;
            width: 100%;
            max-width: 1200px;
            height: 100%;
        }

        .slide.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        h1 {
            color: #CC0000;
            font-size: 48px;
            margin-bottom: 30px;
            font-weight: 300;
        }

        h2 {
            color: #CC0000;
            font-size: 36px;
            margin-bottom: 25px;
            font-weight: 300;
        }

        h3 {
            color: #CC0000;
            font-size: 28px;
            margin-bottom: 20px;
            font-weight: 300;
        }

        .subtitle {
            font-size: 24px;
            color: #666;
            margin-bottom: 20px;
        }

        .content {
            font-size: 20px;
            line-height: 1.6;
            color: #333;
        }

        .bullet-point {
            margin: 15px 0;
            padding-left: 30px;
            position: relative;
        }

        .bullet-point:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #CC0000;
            font-size: 24px;
        }

        .navigation {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        button {
            background: #CC0000;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        button:hover {
            background: #AA0000;
        }

        button:disabled {
            background: #CCC;
            cursor: not-allowed;
        }

        .slide-number {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 16px;
            color: #666;
        }

        .viz-container {
            margin: 30px 0;
            padding: 20px;
            background: #FAFAFA;
            border: 1px solid #E0E0E0;
            border-radius: 4px;
        }

        .quiz-container {
            margin: 30px 0;
            padding: 30px;
            background: #F5F5F5;
            border-left: 4px solid #CC0000;
        }

        .quiz-option {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border: 2px solid #DDD;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .quiz-option:hover {
            border-color: #CC0000;
            background: #FFF5F5;
        }

        .quiz-option.correct {
            border-color: #4CAF50;
            background: #E8F5E9;
        }

        .quiz-option.incorrect {
            border-color: #F44336;
            background: #FFEBEE;
        }

        .quiz-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            font-weight: bold;
        }

        .quiz-feedback.correct {
            background: #E8F5E9;
            color: #2E7D32;
        }

        .quiz-feedback.incorrect {
            background: #FFEBEE;
            color: #C62828;
        }

        .formula {
            font-size: 22px;
            text-align: center;
            margin: 25px 0;
            padding: 20px;
            background: #F5F5F5;
            border-radius: 4px;
            font-family: 'Times New Roman', serif;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 18px;
        }

        th {
            background: #CC0000;
            color: white;
            padding: 12px;
            text-align: left;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #DDD;
        }

        tr:nth-child(even) {
            background: #F9F9F9;
        }

        .highlight-box {
            background: #FFF9E6;
            border-left: 4px solid #CC0000;
            padding: 20px;
            margin: 20px 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .example-box {
            background: #F0F7FF;
            border: 2px solid #2196F3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .step-indicator {
            display: inline-block;
            background: #CC0000;
            color: white;
            padding: 5px 12px;
            border-radius: 3px;
            margin-right: 10px;
            font-weight: bold;
        }

        svg {
            display: block;
            margin: 0 auto;
        }

        .control-panel {
            text-align: center;
            margin: 20px 0;
        }

        .control-button {
            background: #2196F3;
            margin: 5px;
            padding: 10px 20px;
        }

        .control-button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div class="slide-container">
        <!-- Slide 1: Title -->
        <div class="slide active">
            <div style="text-align: center; padding-top: 15%;">
                <h1 style="font-size: 56px;">Week 6: Advanced Classification Methods</h1>
                <div class="subtitle" style="font-size: 28px; margin-top: 40px;">
                    Naïve Bayes, Support Vector Machines, and Gradient Boosting
                </div>
                <div class="subtitle" style="font-size: 22px; margin-top: 60px; color: #999;">
                    DATA4800: Artificial Intelligence and Machine Learning
                </div>
            </div>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h2>Learning Objectives</h2>
            <div class="content">
                <p style="margin-bottom: 30px;">By the end of this workshop, you will be able to:</p>
                <div class="bullet-point">Understand and apply Naïve Bayes classification using probability theory</div>
                <div class="bullet-point">Implement Support Vector Machines for complex classification problems</div>
                <div class="bullet-point">Utilize Gradient Boosting for high-accuracy predictions</div>
                <div class="bullet-point">Compare classification methods and select appropriate algorithms for business problems</div>
                <div class="bullet-point">Evaluate model performance using appropriate metrics</div>
                
                <div class="highlight-box" style="margin-top: 40px;">
                    <strong>Key Focus:</strong> Understanding when and why to use different classification methods in real-world business scenarios
                </div>
            </div>
        </div>

        <!-- Slide 3: Week Overview -->
        <div class="slide">
            <h2>Classification Methods Overview</h2>
            <div class="content">
                <div class="two-column">
                    <div>
                        <h3>What We'll Cover</h3>
                        <div class="bullet-point">Probabilistic Classification (Naïve Bayes)</div>
                        <div class="bullet-point">Margin-Based Classification (SVM)</div>
                        <div class="bullet-point">Ensemble Boosting Methods</div>
                        <div class="bullet-point">Comparative Analysis</div>
                    </div>
                    <div>
                        <h3>Business Applications</h3>
                        <div class="bullet-point">Email spam detection</div>
                        <div class="bullet-point">Customer segmentation</div>
                        <div class="bullet-point">Employee attrition prediction</div>
                        <div class="bullet-point">Medical diagnosis</div>
                    </div>
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Real-World Context:</strong> Each method solves different types of business problems. Understanding their strengths and weaknesses helps you choose the right tool for your specific challenge.
                </div>
            </div>
        </div>

        <!-- Slide 4: Introduction to Naïve Bayes -->
        <div class="slide">
            <h2>Naïve Bayes Classification</h2>
            <div class="content">
                <h3>What is Naïve Bayes?</h3>
                <p style="margin-bottom: 20px;">A probabilistic classifier that predicts outcomes based on the likelihood of features occurring together.</p>
                
                <div class="example-box">
                    <strong>Business Analogy:</strong> Think of email spam filters. The algorithm learns from thousands of emails:
                    <div class="bullet-point">Emails with words like "FREE", "WINNER", "CLICK NOW" are usually spam</div>
                    <div class="bullet-point">Emails from unknown senders with attachments are suspicious</div>
                    <div class="bullet-point">When a new email arrives, it calculates the probability it's spam based on these learned patterns</div>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <strong>Why "Naïve"?</strong> The algorithm assumes all features are independent of each other (which is rarely true in reality, but often works well in practice).
                </div>
            </div>
        </div>

        <!-- Slide 5: Bayes Theorem Foundation -->
        <div class="slide">
            <h2>The Foundation: Conditional Probability</h2>
            <div class="content">
                <p style="margin-bottom: 30px;">Naïve Bayes is built on a simple question: <em>What is the probability of event A given that event B has occurred?</em></p>
                
                <div class="formula">
                    P(A|B) = P(B|A) × P(A) / P(B)
                </div>
                
                <div class="two-column">
                    <div>
                        <h3>In Plain English</h3>
                        <div class="bullet-point"><strong>P(A|B)</strong>: Probability of A given B happened</div>
                        <div class="bullet-point"><strong>P(B|A)</strong>: Probability of B given A happened</div>
                        <div class="bullet-point"><strong>P(A)</strong>: Overall probability of A</div>
                        <div class="bullet-point"><strong>P(B)</strong>: Overall probability of B</div>
                    </div>
                    <div>
                        <h3>Email Spam Example</h3>
                        <div class="bullet-point"><strong>P(Spam|"FREE")</strong>: Probability email is spam given it contains "FREE"</div>
                        <div class="bullet-point"><strong>P("FREE"|Spam)</strong>: Probability spam contains "FREE"</div>
                        <div class="bullet-point"><strong>P(Spam)</strong>: Overall spam rate</div>
                        <div class="bullet-point"><strong>P("FREE")</strong>: Overall frequency of "FREE"</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 6: Interactive Naïve Bayes Visualization -->
        <div class="slide">
            <h2>How Naïve Bayes Makes Decisions</h2>
            <div class="content">
                <p style="margin-bottom: 20px;">Customer Purchase Prediction Example: Will a customer buy based on their browsing behavior?</p>
                
                <div class="viz-container">
                    <div id="naive-bayes-viz"></div>
                </div>
                
                <div class="control-panel">
                    <button class="control-button" onclick="updateNaiveBayes('email')">Email Campaign</button>
                    <button class="control-button" onclick="updateNaiveBayes('browse')">Browsed Products</button>
                    <button class="control-button" onclick="updateNaiveBayes('cart')">Added to Cart</button>
                    <button class="control-button" onclick="updateNaiveBayes('reset')">Reset</button>
                </div>
                
                <div id="nb-explanation" style="margin-top: 20px; padding: 15px; background: #F5F5F5; border-radius: 4px;"></div>
            </div>
        </div>

        <!-- Slide 7: Naïve Bayes Calculation Example -->
        <div class="slide">
            <h2>Step-by-Step Calculation</h2>
            <div class="content">
                <h3>Business Problem: Email Classification</h3>
                <p style="margin-bottom: 20px;">Dataset: 1,000 emails (700 legitimate, 300 spam)</p>
                
                <table>
                    <tr>
                        <th>Feature</th>
                        <th>Spam Emails (300)</th>
                        <th>Legitimate (700)</th>
                    </tr>
                    <tr>
                        <td>Contains "FREE"</td>
                        <td>240 (80%)</td>
                        <td>70 (10%)</td>
                    </tr>
                    <tr>
                        <td>Contains "Meeting"</td>
                        <td>30 (10%)</td>
                        <td>490 (70%)</td>
                    </tr>
                    <tr>
                        <td>Unknown Sender</td>
                        <td>270 (90%)</td>
                        <td>140 (20%)</td>
                    </tr>
                </table>
                
                <div class="example-box" style="margin-top: 20px;">
                    <strong>New Email:</strong> Contains "FREE" and from Unknown Sender
                    <br><br>
                    <span class="step-indicator">Question</span> Is this email spam or legitimate?
                </div>
            </div>
        </div>

        <!-- Slide 8: Naïve Bayes Calculation Steps -->
        <div class="slide">
            <h2>Calculating the Probabilities</h2>
            <div class="content">
                <div style="font-size: 18px;">
                    <div class="highlight-box">
                        <span class="step-indicator">Step 1</span> <strong>Calculate P(Spam):</strong> 300/1000 = 0.30 (30% of emails are spam)
                    </div>
                    
                    <div class="highlight-box">
                        <span class="step-indicator">Step 2</span> <strong>Calculate P(Features|Spam):</strong>
                        <br>• P("FREE"|Spam) = 240/300 = 0.80
                        <br>• P(Unknown|Spam) = 270/300 = 0.90
                        <br>• Combined: 0.80 × 0.90 = 0.72
                    </div>
                    
                    <div class="highlight-box">
                        <span class="step-indicator">Step 3</span> <strong>Calculate P(Features|Legitimate):</strong>
                        <br>• P("FREE"|Legitimate) = 70/700 = 0.10
                        <br>• P(Unknown|Legitimate) = 140/700 = 0.20
                        <br>• Combined: 0.10 × 0.20 = 0.02
                    </div>
                    
                    <div class="highlight-box">
                        <span class="step-indicator">Step 4</span> <strong>Final Calculation:</strong>
                        <br>• Spam Score: 0.72 × 0.30 = 0.216
                        <br>• Legitimate Score: 0.02 × 0.70 = 0.014
                        <br><br>
                        <strong style="color: #CC0000; font-size: 20px;">Prediction: SPAM (0.216 > 0.014)</strong>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 9: Quiz 1 - Naïve Bayes -->
        <div class="slide">
            <h2>Knowledge Check: Naïve Bayes</h2>
            <div class="quiz-container">
                <h3 style="color: #333; margin-bottom: 20px;">Question: Why is the Naïve Bayes classifier called "naïve"?</h3>
                
                <div class="quiz-option" onclick="checkQuiz(1, 'A', false)">
                    <strong>A)</strong> It only works with small datasets
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(1, 'B', false)">
                    <strong>B)</strong> It requires extensive feature engineering
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(1, 'C', true)">
                    <strong>C)</strong> It assumes all features are independent of each other
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(1, 'D', false)">
                    <strong>D)</strong> It cannot handle categorical variables
                </div>
                
                <div id="quiz1-feedback"></div>
            </div>
        </div>

        <!-- Slide 10: Naïve Bayes Strengths and Limitations -->
        <div class="slide">
            <h2>Naïve Bayes: When to Use It</h2>
            <div class="content">
                <div class="two-column">
                    <div>
                        <h3>Strengths</h3>
                        <div class="bullet-point">Fast training and prediction</div>
                        <div class="bullet-point">Works well with small datasets</div>
                        <div class="bullet-point">Handles high-dimensional data effectively</div>
                        <div class="bullet-point">Provides probability estimates</div>
                        <div class="bullet-point">Simple to implement and interpret</div>
                    </div>
                    <div>
                        <h3>Limitations</h3>
                        <div class="bullet-point">Assumes feature independence (rarely true)</div>
                        <div class="bullet-point">Sensitive to irrelevant features</div>
                        <div class="bullet-point">Requires sufficient data per class</div>
                        <div class="bullet-point">Cannot learn feature interactions</div>
                        <div class="bullet-point">Zero probability problem with unseen features</div>
                    </div>
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Best Use Cases:</strong> Text classification (spam detection, sentiment analysis), medical diagnosis with independent symptoms, real-time prediction systems where speed is critical
                </div>
            </div>
        </div>

        <!-- Slide 11: Introduction to SVM -->
        <div class="slide">
            <h2>Support Vector Machines (SVM)</h2>
            <div class="content">
                <h3>What is SVM?</h3>
                <p style="margin-bottom: 20px;">A classification method that finds the optimal boundary (hyperplane) between classes with the maximum margin of separation.</p>
                
                <div class="example-box">
                    <strong>Business Analogy:</strong> Imagine you're a retail analyst separating customers into "likely to buy" vs "unlikely to buy":
                    <div class="bullet-point">You want the clearest possible boundary between the two groups</div>
                    <div class="bullet-point">The boundary should have the widest "safety margin" to minimize errors</div>
                    <div class="bullet-point">The customers closest to the boundary (support vectors) define where this line should be drawn</div>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <strong>Key Concept:</strong> SVM doesn't just find any boundary—it finds the boundary with the maximum margin, making it more robust to new data.
                </div>
            </div>
        </div>

        <!-- Slide 12: SVM Visual Demonstration -->
        <div class="slide">
            <h2>Finding the Optimal Boundary</h2>
            <div class="content">
                <p style="margin-bottom: 20px;">Customer Segmentation: Spending vs Visit Frequency</p>
                
                <div class="viz-container">
                    <div id="svm-viz"></div>
                </div>
                
                <div class="control-panel">
                    <button class="control-button" onclick="toggleSVMMargin()">Toggle Margin</button>
                    <button class="control-button" onclick="highlightSupportVectors()">Show Support Vectors</button>
                    <button class="control-button" onclick="resetSVM()">Reset</button>
                </div>
                
                <div class="highlight-box" style="margin-top: 20px;">
                    <strong>Support Vectors:</strong> The data points closest to the decision boundary that actually determine where the boundary is placed. If we removed other points, the boundary wouldn't change, but removing support vectors would.
                </div>
            </div>
        </div>

        <!-- Slide 13: The Kernel Trick -->
        <div class="slide">
            <h2>The Kernel Trick: Handling Complex Patterns</h2>
            <div class="content">
                <h3>When Simple Boundaries Don't Work</h3>
                <p style="margin-bottom: 20px;">Sometimes data cannot be separated by a straight line in its original form.</p>
                
                <div class="two-column">
                    <div>
                        <h3>The Problem</h3>
                        <div class="bullet-point">Real-world data often has complex, non-linear patterns</div>
                        <div class="bullet-point">A straight line cannot separate circular or curved patterns</div>
                        <div class="bullet-point">Example: Customer clusters based on multiple behaviors</div>
                    </div>
                    <div>
                        <h3>The Solution</h3>
                        <div class="bullet-point">Transform data into higher dimensions</div>
                        <div class="bullet-point">Find linear separation in new space</div>
                        <div class="bullet-point">Project decision boundary back to original space</div>
                    </div>
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Business Analogy:</strong> Imagine trying to separate customers using only "age" and "income". Adding a third dimension like "purchase history" might make the separation much clearer—the kernel trick does this mathematically without explicitly creating new features.
                </div>
            </div>
        </div>

        <!-- Slide 14: Kernel Visualization -->
        <div class="slide">
            <h2>Kernel Transformation in Action</h2>
            <div class="content">
                <p style="margin-bottom: 20px;">Watch how data that cannot be separated linearly becomes separable in higher dimensions:</p>
                
                <div class="viz-container">
                    <div id="kernel-viz"></div>
                </div>
                
                <div class="control-panel">
                    <button class="control-button" onclick="showOriginalSpace()">Original 2D Space</button>
                    <button class="control-button" onclick="showTransformedSpace()">Transformed 3D Space</button>
                    <button class="control-button" onclick="animateKernel()">Animate Transformation</button>
                </div>
                
                <div class="highlight-box" style="margin-top: 20px;">
                    <strong>Common Kernels:</strong> Linear (straight line), Polynomial (curves), RBF/Gaussian (complex patterns), Sigmoid (S-shaped boundaries)
                </div>
            </div>
        </div>

        <!-- Slide 15: Quiz 2 - SVM -->
        <div class="slide">
            <h2>Knowledge Check: Support Vector Machines</h2>
            <div class="quiz-container">
                <h3 style="color: #333; margin-bottom: 20px;">Question: What is the primary objective of Support Vector Machines?</h3>
                
                <div class="quiz-option" onclick="checkQuiz(2, 'A', false)">
                    <strong>A)</strong> Minimize the number of support vectors
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(2, 'B', true)">
                    <strong>B)</strong> Find the decision boundary with the maximum margin between classes
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(2, 'C', false)">
                    <strong>C)</strong> Classify data points as quickly as possible
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(2, 'D', false)">
                    <strong>D)</strong> Reduce the dimensionality of the feature space
                </div>
                
                <div id="quiz2-feedback"></div>
            </div>
        </div>

        <!-- Slide 16: SVM Applications -->
        <div class="slide">
            <h2>SVM Business Applications</h2>
            <div class="content">
                <h3>Real-World Use Cases</h3>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Medical Diagnosis:</strong> Classifying patients as high-risk or low-risk based on multiple health indicators where clear separation is crucial for treatment decisions.
                </div>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Customer Segmentation:</strong> Identifying premium customers from regular customers using purchase patterns, demographics, and engagement metrics when boundaries are complex.
                </div>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Fraud Detection:</strong> Separating legitimate from fraudulent transactions using transaction features where the cost of misclassification is high.
                </div>
                
                <div class="highlight-box">
                    <strong>When to Choose SVM:</strong> Use when you need high accuracy with complex non-linear boundaries, have moderate-sized datasets, and can afford longer training times for better performance.
                </div>
            </div>
        </div>

        <!-- Slide 17: SVM Strengths and Limitations -->
        <div class="slide">
            <h2>SVM: When to Use It</h2>
            <div class="content">
                <div class="two-column">
                    <div>
                        <h3>Strengths</h3>
                        <div class="bullet-point">Effective in high-dimensional spaces</div>
                        <div class="bullet-point">Works well with clear margin of separation</div>
                        <div class="bullet-point">Handles non-linear boundaries via kernels</div>
                        <div class="bullet-point">Memory efficient (only uses support vectors)</div>
                        <div class="bullet-point">Robust against overfitting in high dimensions</div>
                    </div>
                    <div>
                        <h3>Limitations</h3>
                        <div class="bullet-point">Slow training time on large datasets</div>
                        <div class="bullet-point">Requires careful parameter tuning</div>
                        <div class="bullet-point">No probability estimates by default</div>
                        <div class="bullet-point">Sensitive to feature scaling</div>
                        <div class="bullet-point">Difficult to interpret with complex kernels</div>
                    </div>
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Best Use Cases:</strong> Binary classification with clear but complex boundaries, high-dimensional data (text, genomics), problems where accuracy is more important than speed
                </div>
            </div>
        </div>

        <!-- Slide 18: Introduction to Gradient Boosting -->
        <div class="slide">
            <h2>Gradient Boosting</h2>
            <div class="content">
                <h3>What is Gradient Boosting?</h3>
                <p style="margin-bottom: 20px;">An ensemble method that builds multiple weak learners sequentially, where each new model focuses on correcting the errors of previous models.</p>
                
                <div class="example-box">
                    <strong>Business Analogy:</strong> Think of a team of analysts predicting employee attrition:
                    <div class="bullet-point">Analyst 1 makes initial predictions (70% accuracy)</div>
                    <div class="bullet-point">Analyst 2 focuses only on the cases Analyst 1 got wrong</div>
                    <div class="bullet-point">Analyst 3 corrects remaining errors from both previous analysts</div>
                    <div class="bullet-point">Final prediction combines all analysts' insights, achieving 95% accuracy</div>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <strong>Key Concept:</strong> Each new model is trained to predict the errors (residuals) of the combined previous models, gradually improving overall accuracy.
                </div>
            </div>
        </div>

        <!-- Slide 19: How Gradient Boosting Works -->
        <div class="slide">
            <h2>Sequential Error Correction</h2>
            <div class="content">
                <h3>Building Models Step by Step</h3>
                
                <div class="viz-container">
                    <div id="boosting-viz"></div>
                </div>
                
                <div class="control-panel">
                    <button class="control-button" onclick="boostingStep(1)">Model 1</button>
                    <button class="control-button" onclick="boostingStep(2)">Model 2</button>
                    <button class="control-button" onclick="boostingStep(3)">Model 3</button>
                    <button class="control-button" onclick="boostingStep(4)">Final Ensemble</button>
                    <button class="control-button" onclick="resetBoosting()">Reset</button>
                </div>
                
                <div id="boosting-explanation" style="margin-top: 20px; padding: 15px; background: #F5F5F5; border-radius: 4px;"></div>
            </div>
        </div>

        <!-- Slide 20: Gradient Boosting vs Random Forest -->
        <div class="slide">
            <h2>Boosting vs Bagging: Key Differences</h2>
            <div class="content">
                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>Random Forest (Bagging)</th>
                        <th>Gradient Boosting</th>
                    </tr>
                    <tr>
                        <td><strong>Training</strong></td>
                        <td>Parallel (independent trees)</td>
                        <td>Sequential (each tree learns from previous errors)</td>
                    </tr>
                    <tr>
                        <td><strong>Focus</strong></td>
                        <td>Reduce variance through averaging</td>
                        <td>Reduce bias by correcting errors</td>
                    </tr>
                    <tr>
                        <td><strong>Speed</strong></td>
                        <td>Fast (can parallelize)</td>
                        <td>Slower (sequential process)</td>
                    </tr>
                    <tr>
                        <td><strong>Accuracy</strong></td>
                        <td>Good</td>
                        <td>Typically higher</td>
                    </tr>
                    <tr>
                        <td><strong>Overfitting Risk</strong></td>
                        <td>Lower</td>
                        <td>Higher (needs careful tuning)</td>
                    </tr>
                    <tr>
                        <td><strong>Interpretability</strong></td>
                        <td>Moderate</td>
                        <td>Lower</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Slide 21: Quiz 3 - Gradient Boosting -->
        <div class="slide">
            <h2>Knowledge Check: Gradient Boosting</h2>
            <div class="quiz-container">
                <h3 style="color: #333; margin-bottom: 20px;">Question: How does Gradient Boosting differ from Random Forest in building models?</h3>
                
                <div class="quiz-option" onclick="checkQuiz(3, 'A', false)">
                    <strong>A)</strong> It uses more trees than Random Forest
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(3, 'B', true)">
                    <strong>B)</strong> It builds trees sequentially, with each tree correcting previous errors
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(3, 'C', false)">
                    <strong>C)</strong> It only works with numerical features
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(3, 'D', false)">
                    <strong>D)</strong> It trains all trees simultaneously in parallel
                </div>
                
                <div id="quiz3-feedback"></div>
            </div>
        </div>

        <!-- Slide 22: Gradient Boosting Parameters -->
        <div class="slide">
            <h2>Key Parameters in Gradient Boosting</h2>
            <div class="content">
                <div class="bullet-point"><strong>Number of Trees (n_estimators):</strong> More trees generally improve accuracy but increase training time and risk overfitting</div>
                
                <div class="bullet-point"><strong>Learning Rate:</strong> Controls how much each tree contributes to the final prediction. Lower rates need more trees but often perform better</div>
                
                <div class="bullet-point"><strong>Max Depth:</strong> Maximum depth of each tree. Deeper trees can capture complex patterns but risk overfitting</div>
                
                <div class="bullet-point"><strong>Subsample:</strong> Fraction of samples used for training each tree. Values < 1.0 introduce randomness and prevent overfitting</div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <strong>Practical Tip:</strong> Start with learning_rate=0.1, n_estimators=100, max_depth=3. Monitor validation performance and adjust gradually. Lower learning rates with more trees often yield best results.
                </div>
            </div>
        </div>

        <!-- Slide 23: Gradient Boosting Applications -->
        <div class="slide">
            <h2>Gradient Boosting Business Applications</h2>
            <div class="content">
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Employee Attrition Prediction:</strong> Combining multiple factors (salary, performance, tenure, department) to predict which employees are likely to leave, achieving high accuracy for proactive retention strategies.
                </div>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Credit Risk Assessment:</strong> Evaluating loan applicants using financial history, employment data, and behavioral patterns where prediction accuracy directly impacts financial risk.
                </div>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Customer Lifetime Value:</strong> Predicting long-term customer value based on purchase patterns, engagement metrics, and demographics for targeted marketing strategies.
                </div>
                
                <div class="highlight-box">
                    <strong>Industry Standard:</strong> Gradient Boosting (especially XGBoost and LightGBM implementations) frequently wins machine learning competitions and is widely used in industry for high-stakes predictions.
                </div>
            </div>
        </div>

        <!-- Slide 24: Gradient Boosting Strengths and Limitations -->
        <div class="slide">
            <h2>Gradient Boosting: When to Use It</h2>
            <div class="content">
                <div class="two-column">
                    <div>
                        <h3>Strengths</h3>
                        <div class="bullet-point">Often provides highest accuracy</div>
                        <div class="bullet-point">Handles mixed data types well</div>
                        <div class="bullet-point">Automatically captures feature interactions</div>
                        <div class="bullet-point">Handles missing values effectively</div>
                        <div class="bullet-point">Provides feature importance rankings</div>
                        <div class="bullet-point">Robust to outliers</div>
                    </div>
                    <div>
                        <h3>Limitations</h3>
                        <div class="bullet-point">Longer training time</div>
                        <div class="bullet-point">Requires careful hyperparameter tuning</div>
                        <div class="bullet-point">Risk of overfitting with too many trees</div>
                        <div class="bullet-point">Less interpretable than single trees</div>
                        <div class="bullet-point">Cannot be parallelized during training</div>
                        <div class="bullet-point">Sensitive to noisy data</div>
                    </div>
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Best Use Cases:</strong> High-stakes predictions where accuracy is paramount, structured/tabular data, kaggle competitions, situations where you have time for proper hyperparameter tuning
                </div>
            </div>
        </div>

        <!-- Slide 25: Comparing All Three Methods -->
        <div class="slide">
            <h2>Method Comparison Overview</h2>
            <div class="content">
                <table>
                    <tr>
                        <th>Criteria</th>
                        <th>Naïve Bayes</th>
                        <th>SVM</th>
                        <th>Gradient Boosting</th>
                    </tr>
                    <tr>
                        <td><strong>Training Speed</strong></td>
                        <td>Very Fast</td>
                        <td>Slow</td>
                        <td>Moderate</td>
                    </tr>
                    <tr>
                        <td><strong>Prediction Speed</strong></td>
                        <td>Very Fast</td>
                        <td>Fast</td>
                        <td>Moderate</td>
                    </tr>
                    <tr>
                        <td><strong>Typical Accuracy</strong></td>
                        <td>Good</td>
                        <td>Very Good</td>
                        <td>Excellent</td>
                    </tr>
                    <tr>
                        <td><strong>Interpretability</strong></td>
                        <td>High</td>
                        <td>Low</td>
                        <td>Moderate</td>
                    </tr>
                    <tr>
                        <td><strong>Handles Non-linearity</strong></td>
                        <td>No</td>
                        <td>Yes (with kernels)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Dataset Size</strong></td>
                        <td>Small to Medium</td>
                        <td>Small to Medium</td>
                        <td>Medium to Large</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Slide 26: Decision Framework -->
        <div class="slide">
            <h2>Choosing the Right Method</h2>
            <div class="content">
                <div class="viz-container">
                    <div id="decision-tree-viz"></div>
                </div>
                
                <div class="highlight-box" style="margin-top: 20px;">
                    <strong>General Guidelines:</strong>
                    <div class="bullet-point">Need fast results with limited data? → Naïve Bayes</div>
                    <div class="bullet-point">Complex boundaries with moderate data? → SVM</div>
                    <div class="bullet-point">Maximum accuracy on structured data? → Gradient Boosting</div>
                    <div class="bullet-point">Need interpretability? → Naïve Bayes or Random Forest</div>
                    <div class="bullet-point">Real-time predictions at scale? → Naïve Bayes or pre-trained SVM</div>
                </div>
            </div>
        </div>

        <!-- Slide 27: Quiz 4 - Method Selection -->
        <div class="slide">
            <h2>Knowledge Check: Method Selection</h2>
            <div class="quiz-container">
                <h3 style="color: #333; margin-bottom: 20px;">Question: You need to build a real-time spam filter that processes millions of emails per day. Which method would be most appropriate?</h3>
                
                <div class="quiz-option" onclick="checkQuiz(4, 'A', true)">
                    <strong>A)</strong> Naïve Bayes - fast training and prediction with good accuracy for text
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(4, 'B', false)">
                    <strong>B)</strong> SVM - highest accuracy regardless of speed
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(4, 'C', false)">
                    <strong>C)</strong> Gradient Boosting - best overall performance
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(4, 'D', false)">
                    <strong>D)</strong> All methods would work equally well
                </div>
                
                <div id="quiz4-feedback"></div>
            </div>
        </div>

        <!-- Slide 28: Performance Metrics -->
        <div class="slide">
            <h2>Evaluating Classification Performance</h2>
            <div class="content">
                <h3>Key Metrics for Model Evaluation</h3>
                
                <div class="two-column">
                    <div>
                        <div class="bullet-point"><strong>Accuracy:</strong> Overall correct predictions / total predictions</div>
                        <div class="bullet-point"><strong>Precision:</strong> True positives / (True positives + False positives)</div>
                        <div class="bullet-point"><strong>Recall:</strong> True positives / (True positives + False negatives)</div>
                        <div class="bullet-point"><strong>F1-Score:</strong> Harmonic mean of precision and recall</div>
                    </div>
                    <div>
                        <div class="bullet-point"><strong>When to use Accuracy:</strong> Balanced datasets</div>
                        <div class="bullet-point"><strong>When to use Precision:</strong> False positives are costly</div>
                        <div class="bullet-point"><strong>When to use Recall:</strong> False negatives are costly</div>
                        <div class="bullet-point"><strong>When to use F1:</strong> Balance both concerns</div>
                    </div>
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Business Example:</strong> In fraud detection, missing actual fraud (false negative) is worse than flagging legitimate transactions (false positive). Therefore, prioritize Recall over Precision.
                </div>
            </div>
        </div>

        <!-- Slide 29: Confusion Matrix -->
        <div class="slide">
            <h2>Understanding the Confusion Matrix</h2>
            <div class="content">
                <div class="viz-container">
                    <div id="confusion-matrix-viz"></div>
                </div>
                
                <table style="margin-top: 30px;">
                    <tr>
                        <th>Metric</th>
                        <th>Formula</th>
                        <th>Example Value</th>
                    </tr>
                    <tr>
                        <td>Accuracy</td>
                        <td>(TP + TN) / Total</td>
                        <td>(85 + 10) / 120 = 79.2%</td>
                    </tr>
                    <tr>
                        <td>Precision</td>
                        <td>TP / (TP + FP)</td>
                        <td>85 / (85 + 15) = 85.0%</td>
                    </tr>
                    <tr>
                        <td>Recall</td>
                        <td>TP / (TP + FN)</td>
                        <td>85 / (85 + 10) = 89.5%</td>
                    </tr>
                    <tr>
                        <td>F1-Score</td>
                        <td>2 × (Precision × Recall) / (Precision + Recall)</td>
                        <td>87.2%</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Slide 30: Practical Implementation Tips -->
        <div class="slide">
            <h2>Best Practices for Implementation</h2>
            <div class="content">
                <h3>Before Building Models</h3>
                <div class="bullet-point">Understand your business problem and cost of errors</div>
                <div class="bullet-point">Examine class distribution (balanced vs imbalanced)</div>
                <div class="bullet-point">Perform exploratory data analysis</div>
                <div class="bullet-point">Handle missing values appropriately</div>
                <div class="bullet-point">Scale/normalize features (especially for SVM)</div>
                
                <h3 style="margin-top: 30px;">During Model Development</h3>
                <div class="bullet-point">Always use train/test split or cross-validation</div>
                <div class="bullet-point">Start simple, then increase complexity</div>
                <div class="bullet-point">Monitor for overfitting vs underfitting</div>
                <div class="bullet-point">Compare multiple algorithms</div>
                <div class="bullet-point">Tune hyperparameters systematically</div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <strong>Remember:</strong> The best algorithm is the one that solves your specific business problem effectively, not necessarily the most complex one.
                </div>
            </div>
        </div>

        <!-- Slide 31: Quiz 5 - Comprehensive -->
        <div class="slide">
            <h2>Knowledge Check: Comprehensive Review</h2>
            <div class="quiz-container">
                <h3 style="color: #333; margin-bottom: 20px;">Question: A healthcare company needs to predict patient readmission risk. They have a medium-sized dataset with complex feature interactions, and false negatives (missing high-risk patients) are very costly. Which method would be most appropriate?</h3>
                
                <div class="quiz-option" onclick="checkQuiz(5, 'A', false)">
                    <strong>A)</strong> Naïve Bayes - simple and fast
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(5, 'B', false)">
                    <strong>B)</strong> SVM with linear kernel - good for moderate datasets
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(5, 'C', true)">
                    <strong>C)</strong> Gradient Boosting - handles complex interactions, high accuracy, can optimize for recall
                </div>
                
                <div class="quiz-option" onclick="checkQuiz(5, 'D', false)">
                    <strong>D)</strong> Random Forest - faster than Gradient Boosting
                </div>
                
                <div id="quiz5-feedback"></div>
            </div>
        </div>

        <!-- Slide 32: Case Study: Employee Attrition -->
        <div class="slide">
            <h2>Case Study: Employee Attrition Prediction</h2>
            <div class="content">
                <h3>Business Context</h3>
                <p>A company wants to predict which employees are likely to leave to implement proactive retention strategies.</p>
                
                <table style="margin-top: 20px;">
                    <tr>
                        <th>Method</th>
                        <th>Accuracy</th>
                        <th>Precision</th>
                        <th>Recall</th>
                        <th>Training Time</th>
                    </tr>
                    <tr>
                        <td>Naïve Bayes</td>
                        <td>76%</td>
                        <td>71%</td>
                        <td>68%</td>
                        <td>2 seconds</td>
                    </tr>
                    <tr>
                        <td>SVM (RBF kernel)</td>
                        <td>84%</td>
                        <td>82%</td>
                        <td>79%</td>
                        <td>45 seconds</td>
                    </tr>
                    <tr>
                        <td>Gradient Boosting</td>
                        <td>89%</td>
                        <td>87%</td>
                        <td>86%</td>
                        <td>28 seconds</td>
                    </tr>
                </table>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <strong>Decision:</strong> Gradient Boosting was selected because the 5% improvement in recall means catching 5% more at-risk employees, which justifies the extra 26 seconds of training time.
                </div>
            </div>
        </div>

        <!-- Slide 33: Workshop Activities Overview -->
        <div class="slide">
            <h2>Today's Workshop Activities</h2>
            <div class="content">
                <h3>Hands-On Practice</h3>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Activity 1: Naïve Bayes Email Classification</strong>
                    <div class="bullet-point">Build a spam filter using Naïve Bayes</div>
                    <div class="bullet-point">Calculate probabilities manually</div>
                    <div class="bullet-point">Implement in Orange Data Mining</div>
                </div>
                
                <div class="example-box" style="margin-bottom: 20px;">
                    <strong>Activity 2: SVM Customer Segmentation</strong>
                    <div class="bullet-point">Classify customer purchase likelihood</div>
                    <div class="bullet-point">Experiment with different kernels</div>
                    <div class="bullet-point">Visualize decision boundaries</div>
                </div>
                
                <div class="example-box">
                    <strong>Activity 3: Model Comparison Challenge</strong>
                    <div class="bullet-point">Apply all three methods to employee attrition dataset</div>
                    <div class="bullet-point">Compare performance metrics</div>
                    <div class="bullet-point">Recommend best approach with justification</div>
                </div>
            </div>
        </div>

        <!-- Slide 34: Summary and Key Takeaways -->
        <div class="slide">
            <h2>Key Takeaways</h2>
            <div class="content">
                <div class="highlight-box" style="margin-bottom: 20px;">
                    <h3>Naïve Bayes</h3>
                    <strong>Use when:</strong> You need fast, simple classification with independent features (text classification, real-time systems)
                    <br><strong>Remember:</strong> Based on probability, assumes feature independence
                </div>
                
                <div class="highlight-box" style="margin-bottom: 20px;">
                    <h3>Support Vector Machines</h3>
                    <strong>Use when:</strong> You have complex non-linear boundaries and can afford training time
                    <br><strong>Remember:</strong> Finds maximum margin boundary, uses kernel trick for complex patterns
                </div>
                
                <div class="highlight-box" style="margin-bottom: 20px;">
                    <h3>Gradient Boosting</h3>
                    <strong>Use when:</strong> You need highest accuracy on structured data and have time for tuning
                    <br><strong>Remember:</strong> Sequential error correction, requires careful parameter tuning
                </div>
                
                <div class="example-box" style="margin-top: 30px;">
                    <strong>Next Steps:</strong> Practice with real datasets, experiment with different parameters, and always validate your results with appropriate metrics!
                </div>
            </div>
        </div>
    </div>

    <div class="slide-number">Slide <span id="current-slide">1</span> of 34</div>

    <div class="navigation">
        <button id="prev-btn" onclick="previousSlide()">Previous</button>
        <button id="next-btn" onclick="nextSlide()">Next</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        // Quiz state
        const quizAnswered = {1: false, 2: false, 3: false, 4: false, 5: false};
        
        // Track which visualizations have been initialized
        const vizInitialized = {
            naiveBayes: false,
            svm: false,
            kernel: false,
            boosting: false,
            decision: false,
            confusion: false
        };

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            document.getElementById('current-slide').textContent = currentSlide + 1;
            
            document.getElementById('prev-btn').disabled = currentSlide === 0;
            document.getElementById('next-btn').disabled = currentSlide === totalSlides - 1;
            
            // Initialize visualizations when slides become active (only once)
            if (currentSlide === 5 && !vizInitialized.naiveBayes) {
                vizInitialized.naiveBayes = true;
                initNaiveBayesViz();
            }
            if (currentSlide === 11 && !vizInitialized.svm) {
                vizInitialized.svm = true;
                initSVMViz();
            }
            if (currentSlide === 13 && !vizInitialized.kernel) {
                vizInitialized.kernel = true;
                initKernelViz();
            }
            if (currentSlide === 18 && !vizInitialized.boosting) {
                vizInitialized.boosting = true;
                initBoostingViz();
            }
            if (currentSlide === 25 && !vizInitialized.decision) {
                vizInitialized.decision = true;
                initDecisionTreeViz();
            }
            if (currentSlide === 28 && !vizInitialized.confusion) {
                vizInitialized.confusion = true;
                initConfusionMatrixViz();
            }
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                showSlide(currentSlide + 1);
            }
        }

        function previousSlide() {
            if (currentSlide > 0) {
                showSlide(currentSlide - 1);
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight') nextSlide();
            if (e.key === 'ArrowLeft') previousSlide();
        });

        // Quiz functionality
        function checkQuiz(quizNum, selected, isCorrect) {
            if (quizAnswered[quizNum]) return;
            
            quizAnswered[quizNum] = true;
            const options = document.querySelectorAll(`#quiz${quizNum}-feedback`).parentNode.querySelectorAll('.quiz-option');
            const feedback = document.getElementById(`quiz${quizNum}-feedback`);
            
            options.forEach(opt => {
                opt.style.pointerEvents = 'none';
                if (opt.textContent.includes(selected)) {
                    opt.classList.add(isCorrect ? 'correct' : 'incorrect');
                }
            });
            
            if (isCorrect) {
                feedback.className = 'quiz-feedback correct';
                feedback.textContent = '✓ Correct! Well done.';
            } else {
                feedback.className = 'quiz-feedback incorrect';
                feedback.textContent = '✗ Not quite. Review the concepts and try the next quiz!';
            }
        }

        // Naïve Bayes Visualization
        let nbState = {email: false, browse: false, cart: false};
        
        function initNaiveBayesViz() {
            const container = document.getElementById('naive-bayes-viz');
            
            // Create SVG element directly
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '800');
            svg.setAttribute('height', '300');
            container.appendChild(svg);
            
            // Draw base probability bar
            const baseRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            baseRect.setAttribute('x', '50');
            baseRect.setAttribute('y', '100');
            baseRect.setAttribute('width', '700');
            baseRect.setAttribute('height', '40');
            baseRect.setAttribute('fill', '#E0E0E0');
            baseRect.setAttribute('stroke', '#999');
            svg.appendChild(baseRect);
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', '400');
            label.setAttribute('y', '90');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '16px');
            label.textContent = 'Purchase Probability';
            svg.appendChild(label);
            
            // Initial state
            updateNaiveBayesDisplay();
        }

        function updateNaiveBayes(feature) {
            if (feature === 'reset') {
                nbState = {email: false, browse: false, cart: false};
            } else {
                nbState[feature] = !nbState[feature];
            }
            updateNaiveBayesDisplay();
        }

        function updateNaiveBayesDisplay() {
            let prob = 0.20; // Base probability
            let features = [];
            
            if (nbState.email) { prob *= 1.3; features.push('Email Campaign (+30%)'); }
            if (nbState.browse) { prob *= 1.5; features.push('Browsed Products (+50%)'); }
            if (nbState.cart) { prob *= 2.0; features.push('Added to Cart (+100%)'); }
            
            prob = Math.min(prob, 0.95);
            
            const svg = document.querySelector('#naive-bayes-viz svg');
            
            // Remove old probability bar and text
            const oldBar = svg.querySelector('.prob-bar');
            const oldText = svg.querySelector('.prob-text');
            if (oldBar) oldBar.remove();
            if (oldText) oldText.remove();
            
            // Update probability bar
            const probBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            probBar.setAttribute('class', 'prob-bar');
            probBar.setAttribute('x', '50');
            probBar.setAttribute('y', '100');
            probBar.setAttribute('width', (700 * prob).toString());
            probBar.setAttribute('height', '40');
            probBar.setAttribute('fill', '#CC0000');
            svg.appendChild(probBar);
            
            const probText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            probText.setAttribute('class', 'prob-text');
            probText.setAttribute('x', (50 + 700 * prob + 10).toString());
            probText.setAttribute('y', '125');
            probText.setAttribute('font-size', '18px');
            probText.setAttribute('font-weight', 'bold');
            probText.textContent = `${(prob * 100).toFixed(1)}%`;
            svg.appendChild(probText);
            
            // Update explanation
            let explanation = `<strong>Base Purchase Rate:</strong> 20%<br>`;
            if (features.length > 0) {
                explanation += `<strong>Active Features:</strong> ${features.join(', ')}<br>`;
                explanation += `<strong>Updated Probability:</strong> ${(prob * 100).toFixed(1)}%`;
            } else {
                explanation += `Click buttons above to add features and see how probability changes.`;
            }
            
            document.getElementById('nb-explanation').innerHTML = explanation;
        }

        // SVM Visualization
        let svmShowMargin = false;
        let svmShowSV = false;
        let svmData = [];
        
        function initSVMViz() {
            const container = document.getElementById('svm-viz');
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '800');
            svg.setAttribute('height', '400');
            container.appendChild(svg);
            
            // Generate sample data
            const class1 = [];
            const class2 = [];
            
            for (let i = 0; i < 30; i++) {
                class1.push({
                    x: Math.random() * 300 + 50,
                    y: Math.random() * 150 + 50,
                    class: 0
                });
            }
            
            for (let i = 0; i < 30; i++) {
                class2.push({
                    x: Math.random() * 300 + 450,
                    y: Math.random() * 150 + 200,
                    class: 1
                });
            }
            
            svmData = [...class1, ...class2];
            
            // Draw decision boundary
            const boundary = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            boundary.setAttribute('class', 'decision-boundary');
            boundary.setAttribute('x1', '400');
            boundary.setAttribute('y1', '50');
            boundary.setAttribute('x2', '250');
            boundary.setAttribute('y2', '350');
            boundary.setAttribute('stroke', '#CC0000');
            boundary.setAttribute('stroke-width', '2');
            svg.appendChild(boundary);
            
            // Draw points
            svmData.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'data-point');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '6');
                circle.setAttribute('fill', point.class === 0 ? '#2196F3' : '#FF9800');
                circle.setAttribute('stroke', '#333');
                circle.setAttribute('stroke-width', '1');
                svg.appendChild(circle);
            });
            
            // Labels
            const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label1.setAttribute('x', '150');
            label1.setAttribute('y', '30');
            label1.setAttribute('fill', '#2196F3');
            label1.setAttribute('font-size', '16px');
            label1.setAttribute('font-weight', 'bold');
            label1.textContent = 'Unlikely to Buy';
            svg.appendChild(label1);
            
            const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label2.setAttribute('x', '550');
            label2.setAttribute('y', '380');
            label2.setAttribute('fill', '#FF9800');
            label2.setAttribute('font-size', '16px');
            label2.setAttribute('font-weight', 'bold');
            label2.textContent = 'Likely to Buy';
            svg.appendChild(label2);
        }

        function toggleSVMMargin() {
            svmShowMargin = !svmShowMargin;
            const svg = document.querySelector('#svm-viz svg');
            
            // Remove existing margin lines
            const existingLines = svg.querySelectorAll('.margin-line');
            existingLines.forEach(line => line.remove());
            
            if (svmShowMargin) {
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('class', 'margin-line');
                line1.setAttribute('x1', '430');
                line1.setAttribute('y1', '50');
                line1.setAttribute('x2', '280');
                line1.setAttribute('y2', '350');
                line1.setAttribute('stroke', '#CC0000');
                line1.setAttribute('stroke-width', '1');
                line1.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(line1);
                
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('class', 'margin-line');
                line2.setAttribute('x1', '370');
                line2.setAttribute('y1', '50');
                line2.setAttribute('x2', '220');
                line2.setAttribute('y2', '350');
                line2.setAttribute('stroke', '#CC0000');
                line2.setAttribute('stroke-width', '1');
                line2.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(line2);
            }
        }

        function highlightSupportVectors() {
            svmShowSV = !svmShowSV;
            const svg = document.querySelector('#svm-viz svg');
            
            // Remove existing highlights
            const existingHighlights = svg.querySelectorAll('.sv-highlight');
            existingHighlights.forEach(h => h.remove());
            
            if (svmShowSV) {
                // Highlight support vectors (points near decision boundary)
                const svPoints = [
                    {x: 350, y: 200},
                    {x: 320, y: 250},
                    {x: 380, y: 150}
                ];
                
                svPoints.forEach(point => {
                    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    highlight.setAttribute('class', 'sv-highlight');
                    highlight.setAttribute('cx', point.x);
                    highlight.setAttribute('cy', point.y);
                    highlight.setAttribute('r', '12');
                    highlight.setAttribute('fill', 'none');
                    highlight.setAttribute('stroke', '#4CAF50');
                    highlight.setAttribute('stroke-width', '3');
                    svg.appendChild(highlight);
                });
            }
        }

        function resetSVM() {
            svmShowMargin = false;
            svmShowSV = false;
            const container = document.getElementById('svm-viz');
            container.innerHTML = '';
            vizInitialized.svm = false;
            initSVMViz();
        }

        // Kernel Visualization
        function initKernelViz() {
            const container = document.getElementById('kernel-viz');
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '800');
            svg.setAttribute('height', '400');
            container.appendChild(svg);
            
            // 2D circular pattern
            for (let i = 0; i < 20; i++) {
                const angle = i * Math.PI / 10;
                const x = 200 + 50 * Math.cos(angle);
                const y = 200 + 50 * Math.sin(angle);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'kernel-point');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#2196F3');
                svg.appendChild(circle);
            }
            
            for (let i = 0; i < 30; i++) {
                const angle = i * Math.PI / 15;
                const x = 200 + 120 * Math.cos(angle);
                const y = 200 + 120 * Math.sin(angle);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'kernel-point');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#FF9800');
                svg.appendChild(circle);
            }
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', '400');
            label.setAttribute('y', '30');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '16px');
            label.setAttribute('font-weight', 'bold');
            label.textContent = 'Original 2D Space - Non-linearly Separable';
            svg.appendChild(label);
        }

        function showOriginalSpace() {
            const container = document.getElementById('kernel-viz');
            container.innerHTML = '';
            vizInitialized.kernel = false;
            initKernelViz();
        }

        function showTransformedSpace() {
            const container = document.getElementById('kernel-viz');
            const svg = container.querySelector('svg');
            svg.innerHTML = '';
            
            const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label1.setAttribute('x', '400');
            label1.setAttribute('y', '25');
            label1.setAttribute('text-anchor', 'middle');
            label1.setAttribute('font-size', '16px');
            label1.setAttribute('font-weight', 'bold');
            label1.textContent = 'Kernel Transformation: Adding a 3rd Dimension (Z)';
            svg.appendChild(label1);
            
            // LEFT SIDE: Top-down view (X-Y plane) - showing circular pattern
            const leftTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            leftTitle.setAttribute('x', '200');
            leftTitle.setAttribute('y', '60');
            leftTitle.setAttribute('text-anchor', 'middle');
            leftTitle.setAttribute('font-size', '14px');
            leftTitle.setAttribute('font-weight', 'bold');
            leftTitle.setAttribute('fill', '#666');
            leftTitle.textContent = 'Top View (X-Y plane)';
            svg.appendChild(leftTitle);
            
            // Draw circle patterns on left (top-down view)
            for (let i = 0; i < 20; i++) {
                const angle = i * Math.PI / 10;
                const x = 200 + 50 * Math.cos(angle);
                const y = 200 + 50 * Math.sin(angle);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#2196F3');
                svg.appendChild(circle);
            }
            
            for (let i = 0; i < 30; i++) {
                const angle = i * Math.PI / 15;
                const x = 200 + 100 * Math.cos(angle);
                const y = 200 + 100 * Math.sin(angle);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#FF9800');
                svg.appendChild(circle);
            }
            
            // Draw axes for left view
            const leftXAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            leftXAxis.setAttribute('x1', '100');
            leftXAxis.setAttribute('y1', '200');
            leftXAxis.setAttribute('x2', '300');
            leftXAxis.setAttribute('y2', '200');
            leftXAxis.setAttribute('stroke', '#CCC');
            leftXAxis.setAttribute('stroke-width', '1');
            svg.appendChild(leftXAxis);
            
            const leftYAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            leftYAxis.setAttribute('x1', '200');
            leftYAxis.setAttribute('y1', '100');
            leftYAxis.setAttribute('x2', '200');
            leftYAxis.setAttribute('y2', '300');
            leftYAxis.setAttribute('stroke', '#CCC');
            leftYAxis.setAttribute('stroke-width', '1');
            svg.appendChild(leftYAxis);
            
            const leftXLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            leftXLabel.setAttribute('x', '310');
            leftXLabel.setAttribute('y', '205');
            leftXLabel.setAttribute('font-size', '12px');
            leftXLabel.setAttribute('fill', '#999');
            leftXLabel.textContent = 'X';
            svg.appendChild(leftXLabel);
            
            const leftYLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            leftYLabel.setAttribute('x', '205');
            leftYLabel.setAttribute('y', '95');
            leftYLabel.setAttribute('font-size', '12px');
            leftYLabel.setAttribute('fill', '#999');
            leftYLabel.textContent = 'Y';
            svg.appendChild(leftYLabel);
            
            const leftNote = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            leftNote.setAttribute('x', '200');
            leftNote.setAttribute('y', '330');
            leftNote.setAttribute('text-anchor', 'middle');
            leftNote.setAttribute('font-size', '11px');
            leftNote.setAttribute('fill', '#666');
            leftNote.textContent = 'Still circular (not separable)';
            svg.appendChild(leftNote);
            
            // DIVIDER
            const divider = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            divider.setAttribute('x1', '400');
            divider.setAttribute('y1', '50');
            divider.setAttribute('x2', '400');
            divider.setAttribute('y2', '350');
            divider.setAttribute('stroke', '#DDD');
            divider.setAttribute('stroke-width', '2');
            svg.appendChild(divider);
            
            // RIGHT SIDE: Side view showing Z (height) dimension
            const rightTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            rightTitle.setAttribute('x', '600');
            rightTitle.setAttribute('y', '60');
            rightTitle.setAttribute('text-anchor', 'middle');
            rightTitle.setAttribute('font-size', '14px');
            rightTitle.setAttribute('font-weight', 'bold');
            rightTitle.setAttribute('fill', '#666');
            rightTitle.textContent = 'Side View (Distance-Z plane)';
            svg.appendChild(rightTitle);
            
            // Draw side view axes
            const sideXAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            sideXAxis.setAttribute('x1', '450');
            sideXAxis.setAttribute('y1', '280');
            sideXAxis.setAttribute('x2', '750');
            sideXAxis.setAttribute('y2', '280');
            sideXAxis.setAttribute('stroke', '#999');
            sideXAxis.setAttribute('stroke-width', '2');
            svg.appendChild(sideXAxis);
            
            const sideZAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            sideZAxis.setAttribute('x1', '450');
            sideZAxis.setAttribute('y1', '100');
            sideZAxis.setAttribute('x2', '450');
            sideZAxis.setAttribute('y2', '280');
            sideZAxis.setAttribute('stroke', '#999');
            sideZAxis.setAttribute('stroke-width', '2');
            svg.appendChild(sideZAxis);
            
            const sideXLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sideXLabel.setAttribute('x', '600');
            sideXLabel.setAttribute('y', '300');
            sideXLabel.setAttribute('text-anchor', 'middle');
            sideXLabel.setAttribute('font-size', '12px');
            sideXLabel.setAttribute('fill', '#666');
            sideXLabel.textContent = 'Distance from Center';
            svg.appendChild(sideXLabel);
            
            const sideZLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sideZLabel.setAttribute('x', '420');
            sideZLabel.setAttribute('y', '190');
            sideZLabel.setAttribute('text-anchor', 'middle');
            sideZLabel.setAttribute('font-size', '12px');
            sideZLabel.setAttribute('font-weight', 'bold');
            sideZLabel.setAttribute('fill', '#666');
            sideZLabel.textContent = 'Z';
            svg.appendChild(sideZLabel);
            
            const sideZLabel2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sideZLabel2.setAttribute('x', '420');
            sideZLabel2.setAttribute('y', '205');
            sideZLabel2.setAttribute('text-anchor', 'middle');
            sideZLabel2.setAttribute('font-size', '10px');
            sideZLabel2.setAttribute('fill', '#666');
            sideZLabel2.textContent = '(Height)';
            svg.appendChild(sideZLabel2);
            
            // Plot inner circle points (blue) - near center, LOW z
            for (let i = 0; i < 20; i++) {
                const radius = 50;
                const distance = radius + (Math.random() - 0.5) * 15;
                const x = 450 + distance * 1.2;
                const z = 260 - distance * 0.3; // Lower height
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', z);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#2196F3');
                circle.setAttribute('stroke', '#1976D2');
                circle.setAttribute('stroke-width', '1');
                svg.appendChild(circle);
            }
            
            // Plot outer circle points (orange) - far from center, HIGH z
            for (let i = 0; i < 30; i++) {
                const radius = 100;
                const distance = radius + (Math.random() - 0.5) * 20;
                const x = 450 + distance * 1.2;
                const z = 260 - distance * 1.2; // Higher height (inverse relationship)
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', z);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#FF9800');
                circle.setAttribute('stroke', '#F57C00');
                circle.setAttribute('stroke-width', '1');
                svg.appendChild(circle);
            }
            
            // Draw separating plane (horizontal line in side view)
            const plane = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            plane.setAttribute('x1', '450');
            plane.setAttribute('y1', '190');
            plane.setAttribute('x2', '750');
            plane.setAttribute('y2', '190');
            plane.setAttribute('stroke', '#CC0000');
            plane.setAttribute('stroke-width', '3');
            plane.setAttribute('stroke-dasharray', '8,4');
            svg.appendChild(plane);
            
            const planeLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            planeLabel.setAttribute('x', '755');
            planeLabel.setAttribute('y', '195');
            planeLabel.setAttribute('font-size', '12px');
            planeLabel.setAttribute('font-weight', 'bold');
            planeLabel.setAttribute('fill', '#CC0000');
            planeLabel.textContent = '← Separating Plane';
            svg.appendChild(planeLabel);
            
            // Add group labels on right
            const blueGroupLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            blueGroupLabel.setAttribute('x', '520');
            blueGroupLabel.setAttribute('y', '270');
            blueGroupLabel.setAttribute('font-size', '11px');
            blueGroupLabel.setAttribute('font-weight', 'bold');
            blueGroupLabel.setAttribute('fill', '#2196F3');
            blueGroupLabel.textContent = 'Blue: Low Z';
            svg.appendChild(blueGroupLabel);
            
            const orangeGroupLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            orangeGroupLabel.setAttribute('x', '650');
            orangeGroupLabel.setAttribute('y', '120');
            orangeGroupLabel.setAttribute('font-size', '11px');
            orangeGroupLabel.setAttribute('font-weight', 'bold');
            orangeGroupLabel.setAttribute('fill', '#FF9800');
            orangeGroupLabel.textContent = 'Orange: High Z';
            svg.appendChild(orangeGroupLabel);
            
            const rightNote = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            rightNote.setAttribute('x', '600');
            rightNote.setAttribute('y', '330');
            rightNote.setAttribute('text-anchor', 'middle');
            rightNote.setAttribute('font-size', '11px');
            rightNote.setAttribute('fill', '#666');
            rightNote.textContent = 'NOW linearly separable!';
            svg.appendChild(rightNote);
            
            // Bottom explanation
            const explanation = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            explanation.setAttribute('x', '400');
            explanation.setAttribute('y', '370');
            explanation.setAttribute('text-anchor', 'middle');
            explanation.setAttribute('font-size', '13px');
            explanation.setAttribute('font-weight', 'bold');
            explanation.setAttribute('fill', '#333');
            explanation.textContent = 'The kernel function adds height (Z) based on distance from center → Simple plane now separates the classes!';
            svg.appendChild(explanation);
        }

        function animateKernel() {
            showOriginalSpace();
            setTimeout(showTransformedSpace, 1500);
        }

        // Gradient Boosting Visualization
        let boostingCurrentStep = 0;
        
        function initBoostingViz() {
            const container = document.getElementById('boosting-viz');
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '800');
            svg.setAttribute('height', '300');
            container.appendChild(svg);
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', '400');
            label.setAttribute('y', '30');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '16px');
            label.setAttribute('font-weight', 'bold');
            label.textContent = 'Sequential Model Building';
            svg.appendChild(label);
            
            boostingStep(0);
        }

        function boostingStep(step) {
            boostingCurrentStep = step;
            const svg = document.querySelector('#boosting-viz svg');
            
            // Remove old elements
            const oldElements = svg.querySelectorAll('.boosting-elements');
            oldElements.forEach(el => el.remove());
            
            const models = ['Model 1', 'Model 2', 'Model 3', 'Final'];
            const accuracies = [70, 85, 92, 95];
            const colors = ['#90CAF9', '#64B5F6', '#42A5F5', '#CC0000'];
            
            for (let i = 0; i <= step && i < 4; i++) {
                const x = 50 + i * 180;
                
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('class', 'boosting-elements');
                rect.setAttribute('x', x);
                rect.setAttribute('y', '100');
                rect.setAttribute('width', '150');
                rect.setAttribute('height', '150');
                rect.setAttribute('fill', colors[i]);
                rect.setAttribute('stroke', '#333');
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);
                
                const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text1.setAttribute('class', 'boosting-elements');
                text1.setAttribute('x', x + 75);
                text1.setAttribute('y', '140');
                text1.setAttribute('text-anchor', 'middle');
                text1.setAttribute('font-size', '16px');
                text1.setAttribute('font-weight', 'bold');
                text1.setAttribute('fill', 'white');
                text1.textContent = models[i];
                svg.appendChild(text1);
                
                const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text2.setAttribute('class', 'boosting-elements');
                text2.setAttribute('x', x + 75);
                text2.setAttribute('y', '180');
                text2.setAttribute('text-anchor', 'middle');
                text2.setAttribute('font-size', '24px');
                text2.setAttribute('font-weight', 'bold');
                text2.setAttribute('fill', 'white');
                text2.textContent = `${accuracies[i]}%`;
                svg.appendChild(text2);
                
                if (i < 3 && i < step) {
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    arrow.setAttribute('class', 'boosting-elements');
                    arrow.setAttribute('x', x + 160);
                    arrow.setAttribute('y', '180');
                    arrow.setAttribute('text-anchor', 'middle');
                    arrow.setAttribute('font-size', '24px');
                    arrow.textContent = '→';
                    svg.appendChild(arrow);
                }
            }
            
            const explanations = [
                'Click Model 1 to start',
                'Model 1: First attempt with 70% accuracy',
                'Model 2: Focuses on errors from Model 1, combined accuracy 85%',
                'Model 3: Further corrects remaining errors, combined accuracy 92%',
                'Final Ensemble: All models combined achieve 95% accuracy'
            ];
            
            document.getElementById('boosting-explanation').innerHTML = 
                `<strong>Step ${step}:</strong> ${explanations[step]}`;
        }

        function resetBoosting() {
            boostingStep(0);
        }

        // Decision Tree Visualization
        function initDecisionTreeViz() {
            const container = document.getElementById('decision-tree-viz');
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '1000');
            svg.setAttribute('height', '450');
            container.appendChild(svg);
            
            // Draw decision tree
            const nodes = [
                {x: 500, y: 50, text: 'Need real-time predictions?', type: 'question'},
                {x: 300, y: 150, text: 'YES', type: 'answer'},
                {x: 700, y: 150, text: 'NO', type: 'answer'},
                {x: 300, y: 220, text: 'Naïve Bayes', type: 'result'},
                {x: 550, y: 250, text: 'Complex non-linear\nboundaries?', type: 'question'},
                {x: 450, y: 350, text: 'YES', type: 'answer'},
                {x: 650, y: 350, text: 'NO', type: 'answer'},
                {x: 450, y: 420, text: 'SVM', type: 'result'},
                {x: 650, y: 420, text: 'Gradient Boosting', type: 'result'}
            ];
            
            // Draw connections
            const connections = [
                {x1: 500, y1: 50, x2: 300, y2: 150},
                {x1: 500, y1: 50, x2: 700, y2: 150},
                {x1: 300, y1: 150, x2: 300, y2: 220},
                {x1: 700, y1: 150, x2: 550, y2: 250},
                {x1: 550, y1: 250, x2: 450, y2: 350},
                {x1: 550, y1: 250, x2: 650, y2: 350},
                {x1: 450, y1: 350, x2: 450, y2: 420},
                {x1: 650, y1: 350, x2: 650, y2: 420}
            ];
            
            connections.forEach(conn => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', conn.x1);
                line.setAttribute('y1', conn.y1);
                line.setAttribute('x2', conn.x2);
                line.setAttribute('y2', conn.y2);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            });
            
            nodes.forEach(node => {
                const color = node.type === 'result' ? '#CC0000' : 
                              node.type === 'question' ? '#2196F3' : '#666';
                
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', node.x - 70);
                rect.setAttribute('y', node.y - 25);
                rect.setAttribute('width', '140');
                rect.setAttribute('height', '50');
                rect.setAttribute('rx', '5');
                rect.setAttribute('fill', color);
                rect.setAttribute('stroke', '#333');
                rect.setAttribute('stroke-width', '1');
                svg.appendChild(rect);
                
                const lines = node.text.split('\n');
                lines.forEach((line, i) => {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x);
                    text.setAttribute('y', node.y + (lines.length === 1 ? 5 : -5 + i * 15));
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '12px');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-weight', node.type === 'result' ? 'bold' : 'normal');
                    text.textContent = line;
                    svg.appendChild(text);
                });
            });
        }

        // Confusion Matrix Visualization
        function initConfusionMatrixViz() {
            const container = document.getElementById('confusion-matrix-viz');
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '500');
            svg.setAttribute('height', '400');
            container.appendChild(svg);
            
            const matrix = [
                {row: 'Actual Positive', col: 'Predicted Positive', value: 85, label: 'TP: 85', color: '#4CAF50'},
                {row: 'Actual Positive', col: 'Predicted Negative', value: 10, label: 'FN: 10', color: '#F44336'},
                {row: 'Actual Negative', col: 'Predicted Positive', value: 15, label: 'FP: 15', color: '#F44336'},
                {row: 'Actual Negative', col: 'Predicted Negative', value: 10, label: 'TN: 10', color: '#4CAF50'}
            ];
            
            const cellSize = 150;
            const startX = 100;
            const startY = 50;
            
            // Labels
            const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label1.setAttribute('x', startX + cellSize);
            label1.setAttribute('y', startY - 10);
            label1.setAttribute('text-anchor', 'middle');
            label1.setAttribute('font-weight', 'bold');
            label1.textContent = 'Predicted Positive';
            svg.appendChild(label1);
            
            const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label2.setAttribute('x', startX + cellSize * 2);
            label2.setAttribute('y', startY - 10);
            label2.setAttribute('text-anchor', 'middle');
            label2.setAttribute('font-weight', 'bold');
            label2.textContent = 'Predicted Negative';
            svg.appendChild(label2);
            
            const label3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label3.setAttribute('x', startX - 10);
            label3.setAttribute('y', startY + cellSize / 2);
            label3.setAttribute('text-anchor', 'end');
            label3.setAttribute('font-weight', 'bold');
            label3.textContent = 'Actual Positive';
            svg.appendChild(label3);
            
            const label4 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label4.setAttribute('x', startX - 10);
            label4.setAttribute('y', startY + cellSize * 1.5);
            label4.setAttribute('text-anchor', 'end');
            label4.setAttribute('font-weight', 'bold');
            label4.textContent = 'Actual Negative';
            svg.appendChild(label4);
            
            // Matrix cells
            matrix.forEach((cell, i) => {
                const row = i < 2 ? 0 : 1;
                const col = i % 2;
                
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', startX + col * cellSize);
                rect.setAttribute('y', startY + row * cellSize);
                rect.setAttribute('width', cellSize);
                rect.setAttribute('height', cellSize);
                rect.setAttribute('fill', cell.color);
                rect.setAttribute('opacity', '0.7');
                rect.setAttribute('stroke', '#333');
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', startX + col * cellSize + cellSize / 2);
                text.setAttribute('y', startY + row * cellSize + cellSize / 2);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '24px');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', 'white');
                text.textContent = cell.label;
                svg.appendChild(text);
            });
        }

        // Initialize first slide
        showSlide(0);
    </script>
</body>
</html>