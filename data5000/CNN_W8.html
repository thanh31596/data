<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN Animation: How Convolutional Neural Networks Work</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        
        h1, h2, h3 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.2em;
        }
        
        .intro {
            background-color: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        
        .animation-container {
            position: relative;
            height: 500px;
            margin: 40px 0;
            perspective: 1000px;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            position: relative;
        }
        
        .step-indicator::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background-color: #e0e0e0;
            transform: translateY(-50%);
            z-index: 1;
        }
        
        .progress-bar {
            position: absolute;
            top: 50%;
            left: 0;
            height: 4px;
            background-color: #3498db;
            transform: translateY(-50%);
            z-index: 2;
            transition: width 0.3s;
        }
        
        .step {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: white;
            border: 2px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            z-index: 3;
            transition: all 0.3s;
        }
        
        .step.active {
            border-color: #3498db;
            background-color: #3498db;
            color: white;
        }
        
        .step.completed {
            border-color: #2ecc71;
            background-color: #2ecc71;
            color: white;
        }
        
        .step-content {
            display: none;
        }
        
        .step-content.active {
            display: block;
        }
        
        .image-container {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
            margin: 20px 0;
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .canvas-container {
            position: relative;
            margin: 0 auto;
        }
        
        canvas {
            border: 1px solid #ddd;
            background-color: white;
        }
        
        .highlight-box {
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
        }
        
        .cnn-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 1s ease-in-out;
            opacity: 0;
        }
        
        .cnn-layer.active {
            opacity: 1;
        }
        
        .info-panel {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-top: 20px;
            max-width: 400px;
        }
        
        .info-panel h3 {
            margin-top: 0;
            color: #3498db;
        }
        
        /* Convolution animation */
        .convolution-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .conv-grid {
            display: grid;
            gap: 1px;
            margin: 10px;
        }
        
        .conv-cell {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            transition: all 0.3s;
        }
        
        .conv-cell.highlighted {
            background-color: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }
        
        .conv-cell.kernel {
            background-color: rgba(231, 76, 60, 0.2);
            border-color: #e74c3c;
        }
        
        .conv-cell.output-highlight {
            background-color: rgba(46, 204, 113, 0.3);
            border-color: #2ecc71;
        }
        
        .animation-row {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }
        
        .arrow {
            font-size: 24px;
            margin: 0 15px;
            color: #7f8c8d;
        }
        
        .equals {
            font-size: 24px;
            margin: 0 15px;
            font-weight: bold;
            color: #7f8c8d;
        }
        
        .operation {
            font-size: 18px;
            margin: 10px 0;
            text-align: center;
        }

        /* Neuron Network Visualization */
        .neuron-network {
            position: relative;
            height: 300px;
            margin: 30px 0;
        }
        
        .layer-container {
            display: flex;
            justify-content: space-between;
            height: 100%;
            position: relative;
        }
        
        .layer-group {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .layer-label {
            font-weight: bold;
            margin-bottom: 10px;
            color: #3498db;
        }
        
        .neuron-layer {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 80%;
        }
        
        .neuron {
            width: 30px;
            height: 30px;
            background-color: #3498db;
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .neuron.highlighted {
            background-color: #e74c3c;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
            transform: scale(1.2);
        }
        
        .connection-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .connection {
            position: absolute;
            height: 2px;
            background-color: #bdc3c7;
            transform-origin: left center;
            pointer-events: none;
            transition: background-color 0.3s;
        }
        
        .connection.active {
            background-color: #e74c3c;
            height: 3px;
        }
        
        .feature-map {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
        }
        
        .feature-map-image {
            width: 60px;
            height: 60px;
            background-color: white;
            border: 1px solid #ddd;
            margin-top: 5px;
        }
        
        .feature-map-label {
            font-size: 12px;
            margin-top: 5px;
        }
        
        .feature-maps-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .classification-result {
            margin: 30px 0;
        }
        
        .class-bar {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .class-label {
            width: 100px;
            text-align: right;
            padding-right: 10px;
            font-weight: bold;
        }
        
        .class-bar-container {
            flex-grow: 1;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .class-bar-fill {
            height: 100%;
            background-color: #3498db;
            width: 0;
            transition: width 1s;
        }
        
        .class-value {
            width: 50px;
            padding-left: 10px;
        }
        
        .highest .class-bar-fill {
            background-color: #2ecc71;
        }
        
        .highest .class-label {
            color: #2ecc71;
        }
        
        /* Input image animation */
        .pixel-grid {
            display: grid;
            gap: 1px;
            margin: 0 auto;
        }
        
        .pixel {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            transition: background-color 0.3s;
        }
        
        /* Pooling animation */
        .pooling-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        
        .pooling-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .pooling-grid {
            display: grid;
            grid-template-columns: repeat(4, 30px);
            gap: 1px;
        }
        
        .pooling-result {
            display: grid;
            grid-template-columns: repeat(2, 30px);
            gap: 1px;
            margin-left: 20px;
        }
        
        .pooling-arrow {
            font-size: 24px;
            margin: 0 15px;
            color: #7f8c8d;
        }
        
        .highlight-region {
            border: 2px solid #e74c3c;
        }
        
        /* CNN Architecture Visualization */
        .cnn-architecture {
            position: relative;
            height: 150px;
            margin: 30px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .arch-layer {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            padding: 10px;
            transition: all 0.3s;
        }
        
        .arch-layer.active {
            transform: translateY(-10px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        
        .arch-box {
            width: 80px;
            height: 80px;
            background-color: white;
            border: 2px solid #3498db;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .arch-label {
            font-size: 12px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }
        
        .arch-connect {
            position: absolute;
            top: 50%;
            height: 2px;
            background-color: #bdc3c7;
            z-index: 1;
        }
        
        .arch-icon {
            font-size: 24px;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>How Convolutional Neural Networks Work</h1>
        
        <div class="intro">
            <p>This interactive visualization explains how Convolutional Neural Networks (CNNs) process images for classification tasks. CNNs are deep learning algorithms particularly effective at analyzing visual imagery, as they can automatically learn and detect spatial hierarchies of features from images.</p>
            <p>Follow each step of the process from input image to final classification to understand how CNNs learn to recognize patterns and make predictions.</p>
        </div>
        
        <!-- Animation Controls -->
        <div class="controls">
            <button id="prev-btn" disabled>Previous Step</button>
            <button id="play-btn">Play Animation</button>
            <button id="next-btn">Next Step</button>
            <button id="restart-btn">Restart</button>
        </div>
        
        <!-- Step Indicator -->
        <div class="step-indicator">
            <div class="progress-bar" id="progress-bar"></div>
            <div class="step active" data-step="1">1</div>
            <div class="step" data-step="2">2</div>
            <div class="step" data-step="3">3</div>
            <div class="step" data-step="4">4</div>
            <div class="step" data-step="5">5</div>
            <div class="step" data-step="6">6</div>
            <div class="step" data-step="7">7</div>
        </div>
        
        <!-- CNN Architecture Overview -->
        <div class="cnn-architecture">
            <div class="arch-layer" id="arch-input">
                <div class="arch-box">
                    <div class="arch-icon">üì∑</div>
                </div>
                <div class="arch-label">Input Image<br>28√ó28√ó1</div>
            </div>
            
            <div class="arch-connect" style="left: 120px; width: 60px;"></div>
            
            <div class="arch-layer" id="arch-conv1">
                <div class="arch-box">
                    <div class="arch-icon">üîç</div>
                </div>
                <div class="arch-label">Convolution<br>26√ó26√ó6</div>
            </div>
            
            <div class="arch-connect" style="left: 250px; width: 60px;"></div>
            
            <div class="arch-layer" id="arch-relu">
                <div class="arch-box">
                    <div class="arch-icon">üìà</div>
                </div>
                <div class="arch-label">ReLU<br>Activation</div>
            </div>
            
            <div class="arch-connect" style="left: 380px; width: 60px;"></div>
            
            <div class="arch-layer" id="arch-pool">
                <div class="arch-box">
                    <div class="arch-icon">‚¨áÔ∏è</div>
                </div>
                <div class="arch-label">Pooling<br>13√ó13√ó6</div>
            </div>
            
            <div class="arch-connect" style="left: 510px; width: 60px;"></div>
            
            <div class="arch-layer" id="arch-flatten">
                <div class="arch-box">
                    <div class="arch-icon">‚ÜîÔ∏è</div>
                </div>
                <div class="arch-label">Flatten<br>1014 neurons</div>
            </div>
            
            <div class="arch-connect" style="left: 640px; width: 60px;"></div>
            
            <div class="arch-layer" id="arch-fc">
                <div class="arch-box">
                    <div class="arch-icon">üîó</div>
                </div>
                <div class="arch-label">Fully Connected<br>120 ‚Üí 84</div>
            </div>
            
            <div class="arch-connect" style="left: 770px; width: 60px;"></div>
            
            <div class="arch-layer" id="arch-output">
                <div class="arch-box">
                    <div class="arch-icon">üèÜ</div>
                </div>
                <div class="arch-label">Output<br>10 classes</div>
            </div>
        </div>
        
        <!-- Step Content Sections -->
        <div class="step-content active" id="step-1">
            <h2>Step 1: Input Image</h2>
            <p>A Convolutional Neural Network (CNN) takes a digital image as input. For this example, we'll use a grayscale image of the digit "7" with dimensions 28√ó28 pixels.</p>
            
            <div class="grid-container">
                <div>
                    <h3>Original Input Image</h3>
                    <div class="canvas-container">
                        <canvas id="input-image" width="280" height="280"></canvas>
                    </div>
                </div>
                
                <div>
                    <h3>Digital Representation</h3>
                    <p>Each pixel in the image has a value between 0 (black) and 255 (white). These pixel values form a 28√ó28 matrix, which is the raw input to the CNN.</p>
                    <div class="pixel-grid" id="pixel-values" style="grid-template-columns: repeat(8, 30px);">
                        <!-- Populated by JavaScript -->
                    </div>
                    <div class="highlight-box">
                        <p>The input image is just a matrix of numbers to the CNN. The network learns to recognize patterns in these numbers that correspond to visual features.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="step-content" id="step-2">
            <h2>Step 2: Convolution Operation</h2>
            <p>The first operation in a CNN is convolution. This process involves sliding a small matrix (called a filter or kernel) over the input image and computing element-wise multiplications followed by a sum.</p>
            
            <div class="convolution-animation">
                <h3>Convolution in Action</h3>
                
                <div class="animation-row">
                    <div>
                        <h4>Input Section</h4>
                        <div class="conv-grid" id="conv-input" style="grid-template-columns: repeat(5, 30px);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="operation">
                        <span>convolve with</span>
                    </div>
                    
                    <div>
                        <h4>Kernel/Filter</h4>
                        <div class="conv-grid" id="conv-kernel" style="grid-template-columns: repeat(3, 30px);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="equals">=</div>
                    
                    <div>
                        <h4>Output Feature Map</h4>
                        <div class="conv-grid" id="conv-output" style="grid-template-columns: repeat(3, 30px);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <div class="highlight-box">
                    <p>The convolution operation detects features like edges, textures, and shapes. Each filter is specialized to detect different patterns in the image.</p>
                    <p>The animation shows how a filter slides across the image, computing dot products at each position to create a feature map.</p>
                </div>
                
                <h3>Mathematical Process</h3>
                <p>At each position, the convolution performs these steps:</p>
                <ol>
                    <li>Element-wise multiplication between the filter and the current patch of the image</li>
                    <li>Sum all the resulting values</li>
                    <li>Place the sum in the corresponding position in the output feature map</li>
                </ol>
                <p>This process is repeated as the filter slides across the entire image with a specified stride (usually 1 pixel at a time).</p>
            </div>
        </div>
        
        <div class="step-content" id="step-3">
            <h2>Step 3: Activation Function (ReLU)</h2>
            <p>After the convolution operation, an activation function is applied to introduce non-linearity into the model. The most commonly used activation function in CNNs is the Rectified Linear Unit (ReLU).</p>
            
            <div class="grid-container">
                <div>
                    <h3>Before ReLU Activation</h3>
                    <canvas id="pre-relu" width="260" height="260"></canvas>
                    <p>The raw output from the convolution layer contains both positive and negative values.</p>
                </div>
                
                <div>
                    <h3>After ReLU Activation</h3>
                    <canvas id="post-relu" width="260" height="260"></canvas>
                    <div class="highlight-box">
                        <p>ReLU function: f(x) = max(0, x)</p>
                        <p>ReLU replaces all negative values with zero, keeping positive values unchanged. This introduces non-linearity which helps the network learn complex patterns.</p>
                    </div>
                </div>
            </div>
            
            <h3>Why ReLU?</h3>
            <p>ReLU has several advantages:</p>
            <ul>
                <li>It's computationally efficient (simpler than other activation functions)</li>
                <li>It helps solve the vanishing gradient problem</li>
                <li>It creates sparse activations (many neurons output 0), which is beneficial for neural networks</li>
            </ul>
        </div>
        
        <div class="step-content" id="step-4">
            <h2>Step 4: Pooling Layer</h2>
            <p>After convolution and activation, pooling layers reduce the spatial dimensions of the feature maps. This reduces computation and helps make the network invariant to small translations in the input.</p>
            
            <div class="pooling-animation">
                <h3>Max Pooling Operation</h3>
                
                <div class="pooling-container">
                    <div>
                        <h4>Feature Map Section (4√ó4)</h4>
                        <div class="pooling-grid" id="pooling-input">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="pooling-arrow">‚Üí</div>
                    
                    <div>
                        <h4>After Max Pooling (2√ó2)</h4>
                        <div class="pooling-result" id="pooling-output">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <div class="highlight-box">
                    <p>Max pooling divides the input into rectangular pooling regions and outputs the maximum value of each region.</p>
                    <p>In this example, we use 2√ó2 pooling with a stride of 2, which reduces the spatial dimensions by half.</p>
                </div>
                
                <h3>Benefits of Pooling</h3>
                <ul>
                    <li>Reduces the spatial dimensions, decreasing computational load</li>
                    <li>Provides translation invariance (small shifts in input don't change the output)</li>
                    <li>Helps extract dominant features that are rotational and positional invariant</li>
                    <li>Reduces the risk of overfitting</li>
                </ul>
            </div>
        </div>
        
        <div class="step-content" id="step-5">
            <h2>Step 5: Multiple Feature Maps</h2>
            <p>A CNN uses multiple filters in each convolutional layer to capture different features from the input. Each filter creates its own feature map, which together form a 3D volume of activations.</p>
            
            <div class="feature-maps-container" id="feature-maps">
                <!-- Populated by JavaScript -->
            </div>
            
            <div class="highlight-box">
                <p>Different filters detect different patterns in the image:</p>
                <ul>
                    <li>Early layers detect simple features like edges and textures</li>
                    <li>Middle layers detect more complex patterns like shapes and parts of objects</li>
                    <li>Deeper layers detect high-level features and entire objects</li>
                </ul>
            </div>
            
            <p>As we go deeper into the network, the feature maps become more abstract and specialized for the particular classification task.</p>
        </div>
        
        <div class="step-content" id="step-6">
            <h2>Step 6: Fully Connected Layers</h2>
            <p>After several convolutional and pooling layers, the feature maps are flattened into a one-dimensional vector. This vector is then passed through one or more fully connected layers, similar to a traditional neural network.</p>
            
            <div class="neuron-network">
                <div class="layer-container">
                    <div class="layer-group">
                        <div class="layer-label">Flattened Features</div>
                        <div class="neuron-layer" id="flatten-layer">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="layer-group">
                        <div class="layer-label">Hidden Layer 1</div>
                        <div class="neuron-layer" id="fc-layer-1">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="layer-group">
                        <div class="layer-label">Hidden Layer 2</div>
                        <div class="neuron-layer" id="fc-layer-2">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="layer-group">
                        <div class="layer-label">Output Layer</div>
                        <div class="neuron-layer" id="output-layer">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <div class="connection-container" id="connections">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            
            <div class="highlight-box">
                <p>Fully connected layers combine the high-level features extracted by the convolutional and pooling layers to make the final classification decision.</p>
                <p>Each neuron in a fully connected layer is connected to every neuron in the previous layer, with each connection having its own weight.</p>
            </div>
            
            <p>The fully connected layers learn which features most strongly correlate with specific classes. In our example, they learn which feature combinations are most indicative of the digit "7".</p>
        </div>
        
        <div class="step-content" id="step-7">
            <h2>Step 7: Output Classification</h2>
            <p>The final layer of the CNN is the output layer, which produces probabilities for each possible class using the softmax function. The class with the highest probability is the network's prediction.</p>
            
            <div class="classification-result">
                <h3>Class Probabilities</h3>
                
                <div id="classification-bars">
                    <div class="class-bar" id="class-0">
                        <div class="class-label">Digit 0</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.01</div>
                    </div>
                    
                    <div class="class-bar" id="class-1">
                        <div class="class-label">Digit 1</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.02</div>
                    </div>
                    
                    <div class="class-bar" id="class-2">
                        <div class="class-label">Digit 2</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.01</div>
                    </div>
                    
                    <div class="class-bar" id="class-3">
                        <div class="class-label">Digit 3</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.03</div>
                    </div>
                    
                    <div class="class-bar" id="class-4">
                        <div class="class-label">Digit 4</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.01</div>
                    </div>
                    
                    <div class="class-bar" id="class-5">
                        <div class="class-label">Digit 5</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.00</div>
                    </div>
                    
                    <div class="class-bar" id="class-6">
                        <div class="class-label">Digit 6</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.02</div>
                    </div>
                    
                    <div class="class-bar highest" id="class-7">
                        <div class="class-label">Digit 7</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.86</div>
                    </div>
                    
                    <div class="class-bar" id="class-8">
                        <div class="class-label">Digit 8</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.03</div>
                    </div>
                    
                    <div class="class-bar" id="class-9">
                        <div class="class-label">Digit 9</div>
                        <div class="class-bar-container">
                            <div class="class-bar-fill"></div>
                        </div>
                        <div class="class-value">0.01</div>
                    </div>
                </div>
                
                <div class="highlight-box">
                    <p>The CNN correctly classifies the input as the digit "7" with 86% confidence.</p>
                    <p>The softmax function converts the raw output scores into probabilities that sum to 1, making them easier to interpret as confidence levels.</p>
                </div>
            </div>
            
            <h3>How CNNs Learn</h3>
            <p>CNNs learn through backpropagation and gradient descent:</p>
            <ol>
                <li><strong>Forward Pass:</strong> Process images through the network to get predictions</li>
                <li><strong>Calculate Loss:</strong> Measure the difference between predictions and actual labels</li>
                <li><strong>Backpropagation:</strong> Compute gradients of the loss with respect to all weights</li>
                <li><strong>Weight Update:</strong> Adjust weights in the direction that reduces the loss</li>
                <li><strong>Repeat:</strong> Iterate over many examples until convergence</li>
            </ol>
            <p>Through this process, CNNs learn hierarchical representations of visual data, making them extraordinarily powerful for image classification tasks.</p>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentStep = 1;
        const totalSteps = 7;
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const playBtn = document.getElementById('play-btn');
        const restartBtn = document.getElementById('restart-btn');
        const progressBar = document.getElementById('progress-bar');
        let isPlaying = false;
        let animationInterval;
        
        // Initialize
        initializeAnimation();
        
        // Event listeners
        prevBtn.addEventListener('click', previousStep);
        nextBtn.addEventListener('click', nextStep);
        playBtn.addEventListener('click', togglePlayPause);
        restartBtn.addEventListener('click', restart);
        
        // Initialize animation
        function initializeAnimation() {
            // Set up initial state
            updateStepIndicator();
            updateProgressBar();
            highlightArchitectureLayer();
            
            // Initialize the first step
            drawInputImage();
            displayPixelValues();
            
            // Set up convolution visualization for step 2
            setupConvolutionVisualization();
            
            // Set up ReLU visualization for step 3
            setupReLUVisualization();
            
            // Set up pooling visualization for step 4
            setupPoolingVisualization();
            
            // Set up feature maps for step 5
            setupFeatureMaps();
            
            // Set up fully connected visualization for step 6
            setupFullyConnectedVisualization();
            
            // Set up classification visualization for step 7
            setupClassificationVisualization();
        }
        
        function updateStepIndicator() {
            // Update step indicators
            document.querySelectorAll('.step').forEach(step => {
                const stepNum = parseInt(step.getAttribute('data-step'));
                step.classList.remove('active', 'completed');
                
                if (stepNum < currentStep) {
                    step.classList.add('completed');
                } else if (stepNum === currentStep) {
                    step.classList.add('active');
                }
            });
        }
        
        function updateProgressBar() {
            // Update progress bar
            const progressPercentage = ((currentStep - 1) / (totalSteps - 1)) * 100;
            progressBar.style.width = `${progressPercentage}%`;
        }
        
        function highlightArchitectureLayer() {
            // Remove active class from all layers
            document.querySelectorAll('.arch-layer').forEach(layer => {
                layer.classList.remove('active');
            });
            
            // Add active class to current layer based on step
            let activeLayerId;
            switch(currentStep) {
                case 1:
                    activeLayerId = 'arch-input';
                    break;
                case 2:
                    activeLayerId = 'arch-conv1';
                    break;
                case 3:
                    activeLayerId = 'arch-relu';
                    break;
                case 4:
                    activeLayerId = 'arch-pool';
                    break;
                case 5:
                    activeLayerId = 'arch-conv1'; // Feature maps are part of convolution
                    break;
                case 6:
                    activeLayerId = 'arch-flatten';
                    break;
                case 7:
                    activeLayerId = 'arch-output';
                    break;
            }
            
            if (activeLayerId) {
                document.getElementById(activeLayerId).classList.add('active');
            }
        }
        
        function drawInputImage() {
            const canvas = document.getElementById('input-image');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw a '7' digit (simplified)
            ctx.fillStyle = 'white';
            ctx.fillRect(70, 50, 160, 30);  // Top horizontal line
            ctx.fillRect(190, 50, 30, 180); // Right vertical line
        }
        
        function displayPixelValues() {
            const container = document.getElementById('pixel-values');
            container.innerHTML = '';
            
            // Display an 8x8 grid of sample pixel values
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'pixel';
                    cell.style.width = '30px';
                    cell.style.height = '30px';
                    
                    // Simplify: pixels are white where the digit 7 would be
                    let value = 0;
                    if ((i === 1 && j < 6) || (j === 5 && i >= 1)) {
                        value = 255;
                    }
                    
                    cell.style.backgroundColor = `rgb(${value}, ${value}, ${value})`;
                    container.appendChild(cell);
                }
            }
        }
        
        function setupConvolutionVisualization() {
            // Create input grid
            const inputGrid = document.getElementById('conv-input');
            inputGrid.innerHTML = '';
            
            // Sample 5x5 input values (simplified)
            const inputValues = [
                [0, 0, 0, 0, 0],
                [255, 255, 255, 255, 0],
                [0, 0, 0, 255, 0],
                [0, 0, 0, 255, 0],
                [0, 0, 0, 255, 0]
            ];
            
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'conv-cell';
                    const value = inputValues[i][j];
                    cell.style.backgroundColor = `rgb(${value}, ${value}, ${value})`;
                    inputGrid.appendChild(cell);
                }
            }
            
            // Create kernel grid
            const kernelGrid = document.getElementById('conv-kernel');
            kernelGrid.innerHTML = '';
            
            // Edge detection filter (simplified)
            const kernelValues = [
                [-1, -1, -1],
                [-1, 8, -1],
                [-1, -1, -1]
            ];
            
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'conv-cell kernel';
                    cell.textContent = kernelValues[i][j];
                    kernelGrid.appendChild(cell);
                }
            }
            
            // Create output grid
            const outputGrid = document.getElementById('conv-output');
            outputGrid.innerHTML = '';
            
            // Output values (simplified, will be computed properly during animation)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'conv-cell';
                    cell.textContent = '?';
                    outputGrid.appendChild(cell);
                }
            }
        }
        
        function animateConvolution() {
            // Get the grids
            const inputGrid = document.getElementById('conv-input');
            const outputGrid = document.getElementById('conv-output');
            
            // Sample input values (simplified)
            const inputValues = [
                [0, 0, 0, 0, 0],
                [255, 255, 255, 255, 0],
                [0, 0, 0, 255, 0],
                [0, 0, 0, 255, 0],
                [0, 0, 0, 255, 0]
            ];
            
            // Edge detection filter
            const kernelValues = [
                [-1, -1, -1],
                [-1, 8, -1],
                [-1, -1, -1]
            ];
            
            // Pre-compute output values for the animation
            const outputValues = [];
            for (let i = 0; i < 3; i++) {
                outputValues[i] = [];
                for (let j = 0; j < 3; j++) {
                    // Compute convolution result at position (i,j)
                    let sum = 0;
                    for (let ki = 0; ki < 3; ki++) {
                        for (let kj = 0; kj < 3; kj++) {
                            const inputValue = inputValues[i + ki][j + kj];
                            const kernelValue = kernelValues[ki][kj];
                            sum += inputValue * kernelValue;
                        }
                    }
                    // Normalize for visualization
                    sum = Math.min(255, Math.max(0, sum / 255));
                    outputValues[i][j] = Math.round(sum);
                }
            }
            
            // Animation variables
            let currentI = 0;
            let currentJ = 0;
            const inputCells = inputGrid.querySelectorAll('.conv-cell');
            const outputCells = outputGrid.querySelectorAll('.conv-cell');
            
            // Reset all highlights
            inputCells.forEach(cell => cell.classList.remove('highlighted'));
            outputCells.forEach(cell => {
                cell.classList.remove('output-highlight');
                cell.textContent = '?';
            });
            
            // Start animation
            function animateStep() {
                // Remove previous highlights
                inputCells.forEach(cell => cell.classList.remove('highlighted'));
                outputCells.forEach(cell => cell.classList.remove('output-highlight'));
                
                // Highlight current kernel position in input
                for (let ki = 0; ki < 3; ki++) {
                    for (let kj = 0; kj < 3; kj++) {
                        const cellIndex = (currentI + ki) * 5 + (currentJ + kj);
                        inputCells[cellIndex].classList.add('highlighted');
                    }
                }
                
                // Update output cell
                const outputCellIndex = currentI * 3 + currentJ;
                const outputCell = outputCells[outputCellIndex];
                outputCell.textContent = outputValues[currentI][currentJ];
                outputCell.classList.add('output-highlight');
                
                // Move to next position
                currentJ++;
                if (currentJ >= 3) {
                    currentJ = 0;
                    currentI++;
                    if (currentI >= 3) {
                        currentI = 0;
                    }
                }
            }
            
            // Run animation sequence
            let animationStep = 0;
            const animationInterval = setInterval(() => {
                animateStep();
                animationStep++;
                if (animationStep >= 9) {
                    clearInterval(animationInterval);
                }
            }, 800);
        }
        
        function setupReLUVisualization() {
            const preReluCanvas = document.getElementById('pre-relu');
            const postReluCanvas = document.getElementById('post-relu');
            
            const preCtx = preReluCanvas.getContext('2d');
            const postCtx = postReluCanvas.getContext('2d');
            
            // Clear canvases
            preCtx.fillStyle = 'black';
            preCtx.fillRect(0, 0, preReluCanvas.width, preReluCanvas.height);
            postCtx.fillStyle = 'black';
            postCtx.fillRect(0, 0, postReluCanvas.width, postReluCanvas.height);
            
            // Draw example feature map values
            // For visualization, we'll use a simplified representation
            for (let i = 0; i < 26; i++) {
                for (let j = 0; j < 26; j++) {
                    // Create a pattern with both positive and negative values
                    let value = 0;
                    
                    // Pattern representing the digit 7
                    if ((i === 0 && j < 20) || (j === 19 && i < 20)) {
                        value = 150;  // Strong positive response at the digit
                    } else if ((i === 1 && j < 19) || (j === 18 && i < 19)) {
                        value = -50;  // Negative response adjacent to edges
                    }
                    
                    // Draw on pre-ReLU canvas
                    // Use grayscale for positive, blue tint for negative
                    if (value > 0) {
                        preCtx.fillStyle = `rgb(${value}, ${value}, ${value})`;
                    } else if (value < 0) {
                        preCtx.fillStyle = `rgb(0, 0, ${Math.abs(value)})`;
                    } else {
                        preCtx.fillStyle = 'black';
                    }
                    preCtx.fillRect(j * 10, i * 10, 10, 10);
                    
                    // Draw on post-ReLU canvas (ReLU sets negative values to zero)
                    const reluValue = Math.max(0, value);
                    if (reluValue > 0) {
                        postCtx.fillStyle = `rgb(${reluValue}, ${reluValue}, ${reluValue})`;
                    } else {
                        postCtx.fillStyle = 'black';
                    }
                    postCtx.fillRect(j * 10, i * 10, 10, 10);
                }
            }
        }
        
        function animateReLU() {
            // Already visualized in setup - no need for additional animation
        }
        
        function setupPoolingVisualization() {
            const inputContainer = document.getElementById('pooling-input');
            const outputContainer = document.getElementById('pooling-output');
            
            inputContainer.innerHTML = '';
            outputContainer.innerHTML = '';
            
            // Sample 4x4 values for pooling demonstration
            const poolingValues = [
                [23, 45, 12, 56],
                [34, 89, 5, 24],
                [67, 2, 46, 91],
                [15, 37, 82, 63]
            ];
            
            // Fill the input grid
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'conv-cell';
                    cell.textContent = poolingValues[i][j];
                    cell.style.fontSize = '10px';
                    inputContainer.appendChild(cell);
                }
            }
            
            // Calculate max pooling (2x2 windows)
            const poolingResult = [
                [Math.max(poolingValues[0][0], poolingValues[0][1], poolingValues[1][0], poolingValues[1][1])],
                [Math.max(poolingValues[0][2], poolingValues[0][3], poolingValues[1][2], poolingValues[1][3])],
                [Math.max(poolingValues[2][0], poolingValues[2][1], poolingValues[3][0], poolingValues[3][1])],
                [Math.max(poolingValues[2][2], poolingValues[2][3], poolingValues[3][2], poolingValues[3][3])]
            ];
            
            // Create a 2x2 output grid
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'conv-cell';
                    cell.textContent = '?'; // Will be filled during animation
                    cell.style.fontSize = '10px';
                    outputContainer.appendChild(cell);
                }
            }
        }
        
        function animatePooling() {
            const inputContainer = document.getElementById('pooling-input');
            const outputContainer = document.getElementById('pooling-output');
            
            const inputCells = inputContainer.querySelectorAll('.conv-cell');
            const outputCells = outputContainer.querySelectorAll('.conv-cell');
            
            // Sample values from setup
            const poolingValues = [
                [23, 45, 12, 56],
                [34, 89, 5, 24],
                [67, 2, 46, 91],
                [15, 37, 82, 63]
            ];
            
            // Calculate max pooling results
            const poolingResults = [
                Math.max(poolingValues[0][0], poolingValues[0][1], poolingValues[1][0], poolingValues[1][1]),
                Math.max(poolingValues[0][2], poolingValues[0][3], poolingValues[1][2], poolingValues[1][3]),
                Math.max(poolingValues[2][0], poolingValues[2][1], poolingValues[3][0], poolingValues[3][1]),
                Math.max(poolingValues[2][2], poolingValues[2][3], poolingValues[3][2], poolingValues[3][3])
            ];
            
            // Pooling animation sequence
            let poolingRegions = [
                [0, 1, 4, 5],    // Top-left region
                [2, 3, 6, 7],    // Top-right region
                [8, 9, 12, 13],  // Bottom-left region
                [10, 11, 14, 15] // Bottom-right region
            ];
            
            let currentRegion = 0;
            
            function animatePoolingStep() {
                // Remove all highlights
                inputCells.forEach(cell => cell.classList.remove('highlighted'));
                outputCells.forEach(cell => {
                    cell.classList.remove('output-highlight');
                    cell.textContent = '?';
                });
                
                // Highlight current pooling region
                poolingRegions[currentRegion].forEach(index => {
                    inputCells[index].classList.add('highlighted');
                });
                
                // Update output cell
                outputCells[currentRegion].textContent = poolingResults[currentRegion];
                outputCells[currentRegion].classList.add('output-highlight');
                
                // Move to next region
                currentRegion++;
                if (currentRegion >= 4) {
                    currentRegion = 0;
                }
            }
            
            // Run animation sequence
            let animationStep = 0;
            const animationInterval = setInterval(() => {
                animatePoolingStep();
                animationStep++;
                if (animationStep >= 4) {
                    clearInterval(animationInterval);
                }
            }, 1000);
        }
        
        function setupFeatureMaps() {
            const container = document.getElementById('feature-maps');
            container.innerHTML = '';
            
            // Define 6 different feature maps for demonstration
            const featureMaps = [
                { name: 'Horizontal Edges', color: '#3498db' },
                { name: 'Vertical Edges', color: '#e74c3c' },
                { name: 'Diagonal Edges', color: '#2ecc71' },
                { name: 'Corners', color: '#9b59b6' },
                { name: 'Textures', color: '#f39c12' },
                { name: 'Shapes', color: '#1abc9c' }
            ];
            
            // Create a visualization for each feature map
            featureMaps.forEach((map, index) => {
                const featureMapDiv = document.createElement('div');
                featureMapDiv.className = 'feature-map';
                
                const label = document.createElement('div');
                label.className = 'feature-map-label';
                label.textContent = map.name;
                label.style.color = map.color;
                featureMapDiv.appendChild(label);
                
                const mapCanvas = document.createElement('canvas');
                mapCanvas.width = 60;
                mapCanvas.height = 60;
                mapCanvas.className = 'feature-map-image';
                featureMapDiv.appendChild(mapCanvas);
                
                container.appendChild(featureMapDiv);
                
                // Draw feature map visualization
                const ctx = mapCanvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, 60, 60);
                
                // Different pattern for each feature map type
                ctx.fillStyle = map.color;
                
                switch(index) {
                    case 0: // Horizontal edges
                        ctx.fillRect(10, 20, 40, 2);
                        ctx.fillRect(10, 40, 40, 2);
                        break;
                    case 1: // Vertical edges
                        ctx.fillRect(20, 10, 2, 40);
                        ctx.fillRect(40, 10, 2, 40);
                        break;
                    case 2: // Diagonal edges
                        ctx.beginPath();
                        ctx.moveTo(10, 10);
                        ctx.lineTo(50, 50);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = map.color;
                        ctx.stroke();
                        break;
                    case 3: // Corners
                        ctx.beginPath();
                        ctx.moveTo(10, 10);
                        ctx.lineTo(10, 30);
                        ctx.lineTo(30, 10);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 4: // Textures
                        for (let i = 0; i < 6; i++) {
                            for (let j = 0; j < 6; j++) {
                                if ((i + j) % 2 === 0) {
                                    ctx.fillRect(10 + i*7, 10 + j*7, 4, 4);
                                }
                            }
                        }
                        break;
                    case 5: // Shapes
                        ctx.beginPath();
                        ctx.arc(30, 30, 15, 0, Math.PI*2);
                        ctx.fill();
                        break;
                }
            });
        }
        
        function animateFeatureMaps() {
            // No additional animation needed, static visualization is sufficient
        }
        
        function setupFullyConnectedVisualization() {
            const flattenLayer = document.getElementById('flatten-layer');
            const fcLayer1 = document.getElementById('fc-layer-1');
            const fcLayer2 = document.getElementById('fc-layer-2');
            const outputLayer = document.getElementById('output-layer');
            const connectionsContainer = document.getElementById('connections');
            
            // Clear previous content
            flattenLayer.innerHTML = '';
            fcLayer1.innerHTML = '';
            fcLayer2.innerHTML = '';
            outputLayer.innerHTML = '';
            connectionsContainer.innerHTML = '';
            
            // Create neurons for each layer
            const flattenNeurons = 8;
            const fcLayer1Neurons = 6;
            const fcLayer2Neurons = 4;
            const outputNeurons = 10;
            
            // Add neurons to flatten layer
            for (let i = 0; i < flattenNeurons; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron';
                neuron.id = `flatten-${i}`;
                flattenLayer.appendChild(neuron);
            }
            
            // Add neurons to hidden layer 1
            for (let i = 0; i < fcLayer1Neurons; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron';
                neuron.id = `fc1-${i}`;
                fcLayer1.appendChild(neuron);
            }
            
            // Add neurons to hidden layer 2
            for (let i = 0; i < fcLayer2Neurons; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron';
                neuron.id = `fc2-${i}`;
                fcLayer2.appendChild(neuron);
            }
            
            // Add neurons to output layer
            for (let i = 0; i < outputNeurons; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'neuron';
                neuron.id = `output-${i}`;
                neuron.textContent = i;
                outputLayer.appendChild(neuron);
            }
        }
        
        function animateFullyConnected() {
            // Get all neurons
            const flattenNeurons = document.querySelectorAll('#flatten-layer .neuron');
            const fc1Neurons = document.querySelectorAll('#fc-layer-1 .neuron');
            const fc2Neurons = document.querySelectorAll('#fc-layer-2 .neuron');
            const outputNeurons = document.querySelectorAll('#output-layer .neuron');
            const connectionsContainer = document.getElementById('connections');
            
            // Clear existing connections
            connectionsContainer.innerHTML = '';
            
            // Remove all highlights
            document.querySelectorAll('.neuron').forEach(neuron => {
                neuron.classList.remove('highlighted');
            });
            
            // Highlight path to digit 7
            // Highlight some neurons to simulate activation
            setTimeout(() => {
                // Highlight a path from input to output-7
                flattenNeurons[2].classList.add('highlighted');
                flattenNeurons[5].classList.add('highlighted');
                
                fc1Neurons[1].classList.add('highlighted');
                fc1Neurons[3].classList.add('highlighted');
                
                fc2Neurons[1].classList.add('highlighted');
                fc2Neurons[2].classList.add('highlighted');
                
                outputNeurons[7].classList.add('highlighted');
                
                // Draw connections for the highlighted path
                drawConnection(flattenNeurons[2], fc1Neurons[1], true);
                drawConnection(flattenNeurons[5], fc1Neurons[3], true);
                
                drawConnection(fc1Neurons[1], fc2Neurons[1], true);
                drawConnection(fc1Neurons[3], fc2Neurons[2], true);
                
                drawConnection(fc2Neurons[1], outputNeurons[7], true);
                drawConnection(fc2Neurons[2], outputNeurons[7], true);
                
                // Draw some inactive connections
                drawConnection(flattenNeurons[0], fc1Neurons[0], false);
                drawConnection(flattenNeurons[1], fc1Neurons[0], false);
                drawConnection(flattenNeurons[3], fc1Neurons[2], false);
                drawConnection(flattenNeurons[4], fc1Neurons[2], false);
                drawConnection(flattenNeurons[6], fc1Neurons[4], false);
                drawConnection(flattenNeurons[7], fc1Neurons[5], false);
                
                drawConnection(fc1Neurons[0], fc2Neurons[0], false);
                drawConnection(fc1Neurons[2], fc2Neurons[0], false);
                drawConnection(fc1Neurons[4], fc2Neurons[3], false);
                drawConnection(fc1Neurons[5], fc2Neurons[3], false);
                
                drawConnection(fc2Neurons[0], outputNeurons[1], false);
                drawConnection(fc2Neurons[0], outputNeurons[3], false);
                drawConnection(fc2Neurons[3], outputNeurons[6], false);
                drawConnection(fc2Neurons[3], outputNeurons[9], false);
            }, 500);
            
            function drawConnection(fromNeuron, toNeuron, isActive) {
                // Get positions of neurons
                const fromRect = fromNeuron.getBoundingClientRect();
                const toRect = toNeuron.getBoundingClientRect();
                const containerRect = connectionsContainer.getBoundingClientRect();
                
                // Calculate centers relative to container
                const fromX = fromRect.left + fromRect.width/2 - containerRect.left;
                const fromY = fromRect.top + fromRect.height/2 - containerRect.top;
                const toX = toRect.left + toRect.width/2 - containerRect.left;
                const toY = toRect.top + toRect.height/2 - containerRect.top;
                
                // Create connection element
                const connection = document.createElement('div');
                connection.className = `connection ${isActive ? 'active' : ''}`;
                
                // Calculate length and angle
                const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
                const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                
                // Position and rotate
                connection.style.width = `${length}px`;
                connection.style.left = `${fromX}px`;
                connection.style.top = `${fromY}px`;
                connection.style.transform = `rotate(${angle}deg)`;
                
                connectionsContainer.appendChild(connection);
            }
        }
        
        function setupClassificationVisualization() {
            // Already set up in HTML structure
        }
        
        function animateClassification() {
            // Animate probability bars
            const probabilityValues = [0.01, 0.02, 0.01, 0.03, 0.01, 0.00, 0.02, 0.86, 0.03, 0.01];
            
            for (let i = 0; i < 10; i++) {
                const barFill = document.querySelector(`#class-${i} .class-bar-fill`);
                
                // Animate width
                setTimeout(() => {
                    barFill.style.width = `${probabilityValues[i] * 100}%`;
                }, i * 100);
            }
        }
        
        function nextStep() {
            if (currentStep < totalSteps) {
                // Hide current step
                document.querySelector(`.step-content[id=step-${currentStep}]`).classList.remove('active');
                
                // Increment step
                currentStep++;
                
                // Show next step
                document.querySelector(`.step-content[id=step-${currentStep}]`).classList.add('active');
                
                // Update UI
                updateStepIndicator();
                updateProgressBar();
                highlightArchitectureLayer();
                updateButtonStates();
                
                // Run animation for the current step
                runStepAnimation();
            }
        }
        
        function previousStep() {
            if (currentStep > 1) {
                // Hide current step
                document.querySelector(`.step-content[id=step-${currentStep}]`).classList.remove('active');
                
                // Decrement step
                currentStep--;
                
                // Show previous step
                document.querySelector(`.step-content[id=step-${currentStep}]`).classList.add('active');
                
                // Update UI
                updateStepIndicator();
                updateProgressBar();
                highlightArchitectureLayer();
                updateButtonStates();
                
                // Run animation for the current step
                runStepAnimation();
            }
        }
        
        function restart() {
            // Reset to first step
            document.querySelector(`.step-content[id=step-${currentStep}]`).classList.remove('active');
            currentStep = 1;
            document.querySelector(`.step-content[id=step-${currentStep}]`).classList.add('active');
            
            // Update UI
            updateStepIndicator();
            updateProgressBar();
            highlightArchitectureLayer();
            updateButtonStates();
            
            // Run animation for the first step
            runStepAnimation();
        }
        
        function togglePlayPause() {
            if (isPlaying) {
                // Stop auto playback
                clearInterval(animationInterval);
                playBtn.textContent = 'Play Animation';
                isPlaying = false;
            } else {
                // Start auto playback
                playBtn.textContent = 'Pause Animation';
                isPlaying = true;
                
                animationInterval = setInterval(() => {
                    if (currentStep < totalSteps) {
                        nextStep();
                    } else {
                        // Stop playback at the end
                        clearInterval(animationInterval);
                        playBtn.textContent = 'Play Animation';
                        isPlaying = false;
                    }
                }, 5000); // Advance every 5 seconds
                
                // Run the animation for the current step immediately
                runStepAnimation();
            }
        }
        
        function updateButtonStates() {
            prevBtn.disabled = currentStep === 1;
            nextBtn.disabled = currentStep === totalSteps;
        }
        
        function runStepAnimation() {
            // Run the appropriate animation based on current step
            switch(currentStep) {
                case 1:
                    // Nothing to animate for the first step
                    break;
                case 2:
                    animateConvolution();
                    break;
                case 3:
                    animateReLU();
                    break;
                case 4:
                    animatePooling();
                    break;
                case 5:
                    animateFeatureMaps();
                    break;
                case 6:
                    animateFullyConnected();
                    break;
                case 7:
                    animateClassification();
                    break;
            }
        }
    </script>
</body>
</html>
